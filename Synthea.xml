<?xml version="1.0" encoding="UTF-8"?>
<Export generator="Cache" version="25" zv="Cache for UNIX (Red Hat Enterprise Linux for x86-64) 2018.1.1 (Build 312_1_18859U)" ts="2019-08-12 18:54:06">
<Class name="Synthea.CCDADemographicsExtractor">
<Description><![CDATA[
Isolates demographic data from a CCDA <br>
NOTE: work in progress, and potentially buggy]]></Description>
<TimeChanged>65190,59860.501594</TimeChanged>
<TimeCreated>65190,59860.501594</TimeCreated>

<Method name="RemovePatientData">
<ClassMethod>1</ClassMethod>
<FormalSpec>pInputPath:%String="C:\Users\dkirk\synthea\output\ccda\Kacy732_Rowe323_8e25bd23-269a-4b92-9405-ced2f9c4d640.xml",pOutputPath:%String="C:\Users\dkirk\synthea\output\ccda\TestStrip.xml"</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	set tStartTime = $EXTRACT($NOW(), 7, 20)
	set tFile = ##class(%File).%New(pInputPath)
	set tNewFile = ##class(%File).%New(pOutputPath)
	set tLine = ""
	do tFile.Open("RS")
	do tNewFile.Open("WSN")
	while 'tFile.AtEnd {
		
		if tLine = "  <component>" {
			//write !, tLine, " = <component>"
			quit
		} else {
			do tNewFile.WriteLine(tLine)
		}
		set tLine = tFile.ReadLine()
	}
	do tNewFile.Write("</ClinicalDocument>")
	do tFile.Close()
	do tNewFile.Close()
	set tEndTime = $EXTRACT($NOW(), 7, 20) write ?30, "Time elapsed: ", tEndTime - tStartTime, " seconds", ?90, "[DONE]"
	
	return 1
]]></Implementation>
</Method>

<Method name="StripDirectory">
<ClassMethod>1</ClassMethod>
<FormalSpec>pInputDir:%String="C:\Users\dkirk\synthea\output\ccda",pOutputDir:%String="C:\Users\dkirk\synthea\output\ccda\"</FormalSpec>
<Implementation><![CDATA[
	Set tSC = ..GetFilesFromSourceDirectory(pInputDir, pOutputDir, .pArray)
	If $$$ISERR(tSC) {
		do $system.Status.DisplayError(tSC)
		Return tSC
	}
	
	For tFileCounter = 1:1:pArray {
		set tSelectedFilePath = pArray(tFileCounter, "PathAndName")
		if $EXTRACT(tSelectedFilePath, *-3, *) '= ".xml" {
			write !, "Not XML: ", tSelectedFilePath
		}
		write !, "Stripping ", pArray(tFileCounter, "Name")
		set tOutputPath = pOutputDir _ "DEMOGRAPHIC_" _ pArray(tFileCounter, "Name")
		set tSC = ..RemovePatientData(tSelectedFilePath, tOutputPath)
		
		kill pArray(tFileCounter) //removes this array element from memory
	}
]]></Implementation>
</Method>

<Method name="GetFilesFromSourceDirectory">
<Description><![CDATA[
Usage: set st = ##class(SDAManip.PatientManipulator).GetFilesFromSourceDirectory(pSourceDirectory, pTargetDirectory, pArray) <br>
Taken from qd.user.ImportSyntheaData <br>
pSourceDirectory - the directory to be read
pTargetDirectory - a directory that may be used for file output <br>
pArray 			 - an array of file names and file paths for every file in pSourceDirectory <br>]]></Description>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pSourceDirectory:%String,pTargetDirectory:%String,&pArray]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
		If (##class(%File).DirectoryExists(pSourceDirectory)=0) {
			Quit $$$ERROR(5001,"Source directory does not exist  "_pSourceDirectory)
		}
		If (##class(%File).DirectoryExists(pTargetDirectory)=0) {
			Quit $$$ERROR(5001,"Target directory does not exist  "_pTargetDirectory)
		}
		
		Set tSC = ##class(QDHS.Util.Files).GetFiles(pSourceDirectory, .pArray)
		If $$$ISERR(tSC) {
			do $system.Status.DisplayError(tSC)
			Quit tSC
		}
		Quit $$$OK
]]></Implementation>
</Method>
</Class>


<Class name="Synthea.CCDAtoSDAConverter">
<TimeChanged>65190,59859.250402</TimeChanged>
<TimeCreated>65190,59859.250402</TimeCreated>

<Method name="ConvertCCDA">
<Description>
Usage:  Set tSC = ##class(qd.User.ImportSyntheaData).ConvertAllFiles(tSourceDirectory, tOutputDirectory)
Converts all the CCDA files in tSourceDirectory to SDA files in tOutputDirectory
Will return an error if tSourceDirectory includes files that are not CCDA</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>tSourceDirectory="/home/synthea/output/CCDA",tTargetDirectory="/home/synthea/output/SDA",pFilename:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	set startTime = $EXTRACT($NOW(), 7, 20)

	
	Set tSC = ..GetFilesFromSourceDirectory(tSourceDirectory,tTargetDirectory, .pArray, pFilename)
	If $$$ISERR(tSC) {
		Return tSC
	}
	For tFileCount = 1:1:pArray {
		Set tCCDA = pArray(tFileCount,"PathAndName") // CCDA output file from Synthea
		
		Set tSDA = tTargetDirectory_"/"_pArray(tFileCount,"Name") // the name of the SDA file to create
		Set tXSL = "/SDA3/CCDAv21-to-SDA.xsl" 
		Set tTransformer = ##class(HS.Util.XSLTTransformer).%New()
		
		write !, "Converting ", pArray(tFileCount, "Name")
		Try {
			Set tSC = tTransformer.TransformFile(tCCDA, tXSL, tSDA)
			If $$$ISERR(tSC) {
				Return tSC
			}
			write ?90, "[DONE]"
		} 
		catch ex {
			Set tSC = ex.AsStatus()
		}
		kill pArray(tFileCount) //removes this array element from memory
		
	}
	
	set endTime = $EXTRACT($NOW(), 7, 20)
	write !, "Time elapsed: ", endTime - startTime, " seconds"
	
	// KT - remove CCDA file, we are done with it at this point
	//set tSC = $ZF(-100,"","sudo","rm","-f",tCCDA)
	
	// **** KT - 5/3/19 ****
	// TODO: parameterize directories in manifest when ready
	set tInstallDirectory = $System.Util.InstallDirectory()
	set tSC = ##class(Synthea.SDASplitter).SplitDirectory(tTargetDirectory, tInstallDirectory,"/home/synthea/output/sdarepo/future", pFilename)	
	
	Quit tSC
]]></Implementation>
</Method>

<Method name="ConvertFHIR">
<Description>
Usage:  Set tSC = ##class(qd.User.ImportSyntheaData).ConvertAllFiles(tSourceDirectory, tOutputDirectory)
Converts all the FHIR JSON files in tSourceDirectory to SDA files in tOutputDirectory
Will return an error if tSourceDirectory includes files that are not CCDA
*** This doesn't work yet ***</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>tSourceDirectory="C:\Users\jparker\synthea\output\fhir_dstu2",tTargetDirectory="C:\Users\jparker\synthea\output\SDA"</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tSC = ..GetFilesFromSourceDirectory(tSourceDirectory, tTargetDirectory, .pArray)
	If $$$ISERR(tSC) {
		Quit tSC
	}
	For tFileCount = 1:1:pArray {
		Set tJSON = pArray(tFileCount,"PathAndName") // JSON output file from Synthea
		Set tSDA = tTargetDirectory_"\"_pArray(tFileCount,"Name") // the name of the SDA file to create
	}
	Set tStream=##class(%Stream.FileCharacter).%New()
	Set tSC=tStream.LinkToFile(tJSON)
	If $$$ISERR(tSC) {
		Quit tSC
	}
	Set tSC=##class(HS.FHIR.Utils).FHIRToHSFHIR("json",tStream,,.pHSFHIRObj,"HS.FHIR.Model")
	If $$$ISERR(tSC) {
		Quit tSC
	}
	
	
	Quit $$$OK
]]></Implementation>
</Method>

<Method name="GetFilesFromSourceDirectory">
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pSourceDirectory:%String,pTargetDirectory:%String,&pArray,pFilename:%String]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	If (##class(%File).DirectoryExists(pSourceDirectory)=0) {
		Quit $$$ERROR(5001,"Source directory does not exist  "_pSourceDirectory)
	}
	If (##class(%File).DirectoryExists(pTargetDirectory)=0) {
		Quit $$$ERROR(5001,"Target directory does not exist  "_pTargetDirectory)
	}
	
	Set tSC = ##class(QDHS.Util.Files).GetFiles(pSourceDirectory, .pArray, , pFilename)
	If $$$ISERR(tSC) {
		Quit tSC
	}
	Quit $$$OK
]]></Implementation>
</Method>
</Class>


<Class name="Synthea.Generator.AlertRule">
<Description>
</Description>
<Super>Ens.Rule.Definition</Super>
<TimeChanged>65204,49173</TimeChanged>
<TimeCreated>65162,40555.604891</TimeCreated>

<Parameter name="RuleAssistClass">
<Default>EnsLib.MsgRouter.RuleAssist</Default>
</Parameter>

<XData name="RuleDefinition">
<XMLNamespace>http://www.intersystems.com/rule</XMLNamespace>
<Data><![CDATA[
<ruleDefinition alias="" context="EnsLib.MsgRouter.RoutingEngine" production="Synthea.Generator">
<ruleSet name="" effectiveBegin="" effectiveEnd="">
<rule name="">
</rule>
</ruleSet>
</ruleDefinition>
]]></Data>
</XData>
</Class>


<Class name="Synthea.Generator.RoutingRule">
<Description>
</Description>
<Super>Ens.Rule.Definition</Super>
<TimeChanged>65204,49173</TimeChanged>
<TimeCreated>65162,40555.375077</TimeCreated>

<Parameter name="RuleAssistClass">
<Default>EnsLib.HL7.MsgRouter.RuleAssist</Default>
</Parameter>

<XData name="RuleDefinition">
<XMLNamespace>http://www.intersystems.com/rule</XMLNamespace>
<Data><![CDATA[
<ruleDefinition alias="" context="EnsLib.HL7.MsgRouter.RoutingEngine" production="Synthea.Generator">
<ruleSet name="" effectiveBegin="" effectiveEnd="">
<rule name="">
<constraint name="source" value="HL7FileService"></constraint>
<when condition="1">
<send transform="" target="HL7FileOperation"></send>
</when>
</rule>
</ruleSet>
</ruleDefinition>
]]></Data>
</XData>
</Class>


<Class name="Synthea.Generator">
<Super>Ens.Production</Super>
<TimeChanged>65190,59858.17482</TimeChanged>
<TimeCreated>65190,59858.17482</TimeCreated>

<XData name="ProductionDefinition">
<Data><![CDATA[
<Production Name="Synthea.Generator" LogGeneralTraceEvents="false">
  <Description></Description>
  <ActorPoolSize>2</ActorPoolSize>
  <Item Name="Synthea.HL7Generator" Category="" ClassName="Synthea.HL7Generator" PoolSize="1" Enabled="true" Foreground="false" Comment="" LogTraceEvents="false" Schedule="">
    <Setting Target="Host" Name="MaxPatients">2</Setting>
    <Setting Target="Host" Name="MaxHL7">995</Setting>
    <Setting Target="Host" Name="FacilityList">NEWTONWELLESLEY,MORTON,ADCARE,STVINCENT,NANTUCKET,MARTHAS,BETHISRAEL</Setting>
  </Item>
  <Item Name="ADTIn" Category="" ClassName="EnsLib.HL7.Service.TCPService" PoolSize="1" Enabled="true" Foreground="false" Comment="" LogTraceEvents="false" Schedule="">
    <Setting Target="Host" Name="MessageSchemaCategory">2.5.1</Setting>
    <Setting Target="Host" Name="TargetConfigNames">FileOut</Setting>
    <Setting Target="Adapter" Name="Port">9871</Setting>
  </Item>
  <Item Name="ADTOut" Category="" ClassName="EnsLib.HL7.Operation.TCPOperation" PoolSize="1" Enabled="true" Foreground="false" Comment="" LogTraceEvents="false" Schedule="">
    <Setting Target="Adapter" Name="IPAddress">127.0.0.1</Setting>
    <Setting Target="Adapter" Name="Port">9871</Setting>
  </Item>
  <Item Name="FileOut" Category="" ClassName="EnsLib.HL7.Operation.FileOperation" PoolSize="1" Enabled="false" Foreground="false" Comment="" LogTraceEvents="false" Schedule="">
    <Setting Target="Adapter" Name="FilePath"></Setting>
    <Setting Target="Host" Name="Filename">%f_%Q%!+(_a)</Setting>
  </Item>
</Production>
]]></Data>
</XData>
</Class>


<Class name="Synthea.HL7Generator">
<Super>Ens.BusinessService</Super>
<TimeChanged>65210,45888.838008</TimeChanged>
<TimeCreated>65190,59860.25021</TimeCreated>

<Parameter name="ADAPTER">
<Default>Synthea.InboundHL7Adapter</Default>
</Parameter>

<Property name="MaxHL7">
<Description>
Maximum number of HL7 messages to be sent</Description>
<Type>%Integer</Type>
<InitialExpression>995</InitialExpression>
</Property>

<Property name="MaxPatients">
<Description>
Maximum number of patients to be sent</Description>
<Type>%Integer</Type>
<InitialExpression>500</InitialExpression>
</Property>

<UDLText name="T">
<Content><![CDATA[
// Property FacilityList As %String(MAXLEN = 10000000) [ InitialExpression = "NEWTONWELLESLEY,MORTON,ADCARE" ];

]]></Content>
</UDLText>

<Parameter name="SETTINGS">
<Description>
List of possible facilities for patient</Description>
<Default>MaxHL7:Basic, MaxPatients:Basic, FacilityList:Basic</Default>
</Parameter>

<Method name="OnProcessInput">
<Description>
Override this method to process incoming data. Do not call SendRequestSync/Async() from outside this method (e.g. in a SOAP Service or a CSP page).</Description>
<FormalSpec><![CDATA[pInput:%RegisteredObject,*pOutput:%RegisteredObject,&pHint:%String]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	try {
		Set tSC=$$$OK
		Set tWorkingMRN = ""
		Set tPatientCount = 0
		//Set tEncounterCount = 0
		Set tFacilityList = $ZSTRIP(^stConfig("HospitalList"),"*W") //Config
		Set tListLength = $LENGTH(tFacilityList,",")
		Set tHomeFacilityList = $ZSTRIP(^stConfig("HomeFacilityList"),"*W") //Config
		Set tHomeListLength = $LENGTH(tFacilityList,",")
		Set tToday = $ZDATE($PIECE($NOW(),",",1),3)
		Set tToday = tToday_" 23:59"
		Set tThreshold = 40*^stConfig("PatientLoyalty") //Config
		Set tStartFromLast = ^stConfig("FromLastMRN") //Config
		Set tLast = 0 
		Set tMaxPatients = ^stConfig("MaxPatients") //Config\
		Set tMax = tMaxPatients * 80 //MaxRecords (supposedly)
	
		/*if (..MaxHL7'="") {
			Set tMax = ..MaxHL7
		}
		else {
			Set tMax = 10000000000000
		}*/
		
		
		/*if (..MaxPatients'="") {
			Set tMaxPatients = ..MaxPatients
			}
		else {
			Set tMaxPatients = 1000000000
		}*/
		
		s ^timer("start query")=$ZDATETIME($H,3,1,3)
		
		
		try {
			if (tStartFromLast) {
				Set tLast = ^stConfig("LastMRN") //Config
			}
		} catch {}
		
		&sql(declare hl7cursor cursor for select top :tMax ID,EncounterDate, HL7, MRN into
														:tID,:tEncounterDate, :tHL7, :tMRN
														from synthea.hl7table 
														where encounterdate<=:tToday AND MRN >= :tLast
														order by mrn,encounterdate asc)
		&sql(open hl7cursor)
			QUIT:(SQLCODE'=0)

		//Query is over
		
		&sql(FETCH hl7cursor)
		s ^timer("start")=$ZDATETIME($H,3,1,3)
		While ((SQLCODE = 0)) {
			If (tWorkingMRN '= tMRN & tThreshold '= 0) {
				//Initial Encounter, set Home Facility
				
				Set hIndex = $RANDOM(tHomeListLength)+1
				Set hFacility = $PIECE(tHomeFacilityList, hIndex)
				
				Set tHL7 = $REPLACE(tHL7,"{XX}",hFacility)
				Set tWorkingMRN = tMRN
				Set tPatientCount = tPatientCount + 1
			}
			ElseIf ($RANDOM(100) < tThreshold) {
				//tThreshold chance original facility in rest of encounters
				Set tHL7 = $REPLACE(tHL7,"{XX}",hFacility)
			}
			Else {
				//Else pick random other facility
				Set oFacility = hFacility
				while (hFacility = oFacility & tThreshold '= 0) {
					Set tIndex = $RANDOM(tListLength) + 1
					Set hFacility = $PIECE(tFacilityList,",",tIndex)
				}

				Set tHL7 = $REPLACE(tHL7,"{XX}", hFacility)
				}
			
			If (tPatientCount <= tMaxPatients) {
				Set tRequest = ##class(EnsLib.HL7.Message).ImportFromString(tHL7)
				Do ..SendRequestAsync("ADTOut_"_hFacility,tRequest)
				}
			Else {
				//For last MRN
				set ^stConfig("LastMRN") = tMRN
				Quit
			}
			
			&sql(FETCH hl7cursor)
		}
				
		&sql(CLOSE hl7cursor)
		
		Set tSC = ##class(Ens.Director).EnableConfigItem(..%ConfigName,0,1)
		Set tSC = ##class(Ens.Director).UpdateProduction()
	} catch ex {
		Set tSC = ex.AsStatus()
	}
	s ^timer("end")=$ZDATETIME($H,3,1,3)
	Quit tSC
]]></Implementation>
</Method>

<Storage name="Default">
<Type>%Library.CacheStorage</Type>
</Storage>
</Class>


<Class name="Synthea.HL7GeneratorProduction">
<Super>Ens.Production</Super>
<TimeChanged>65205,57644</TimeChanged>
<TimeCreated>65196,48307.481895</TimeCreated>

<XData name="ProductionDefinition">
<Data><![CDATA[
<Production Name="Synthea.HL7GeneratorProduction" LogGeneralTraceEvents="false">
  <Description></Description>
  <ActorPoolSize>2</ActorPoolSize>
  <Item Name="ADTOut_ADCARE" Category="" ClassName="EnsLib.HL7.Operation.TCPOperation" PoolSize="1" Enabled="true" Foreground="false" Comment="" LogTraceEvents="false" Schedule="">
    <Setting Target="Adapter" Name="IPAddress">qdhsst-edg2</Setting>
    <Setting Target="Adapter" Name="Port">6821</Setting>
    <Setting Target="Host" Name="ThrottleDelay">20</Setting>
  </Item>
  <Item Name="ADTOut_BETHISRAEL" Category="" ClassName="EnsLib.HL7.Operation.TCPOperation" PoolSize="1" Enabled="true" Foreground="false" Comment="" LogTraceEvents="false" Schedule="">
    <Setting Target="Adapter" Name="IPAddress">qdhsst-edg2</Setting>
    <Setting Target="Adapter" Name="Port">6822</Setting>
    <Setting Target="Host" Name="ThrottleDelay">20</Setting>
  </Item>
  <Item Name="ADTOut_HEALTHALLIANCE" Category="" ClassName="EnsLib.HL7.Operation.TCPOperation" PoolSize="1" Enabled="true" Foreground="false" Comment="" LogTraceEvents="false" Schedule="">
    <Setting Target="Adapter" Name="IPAddress">qdhsst-edg1</Setting>
    <Setting Target="Adapter" Name="Port">6811</Setting>
    <Setting Target="Host" Name="ThrottleDelay">0</Setting>
  </Item>
  <Item Name="ADTOut_LOWELL" Category="" ClassName="EnsLib.HL7.Operation.TCPOperation" PoolSize="1" Enabled="true" Foreground="false" Comment="" LogTraceEvents="false" Schedule="">
    <Setting Target="Adapter" Name="IPAddress">qdhsst-edg2</Setting>
    <Setting Target="Adapter" Name="Port">6823</Setting>
    <Setting Target="Host" Name="ThrottleDelay">20</Setting>
  </Item>
  <Item Name="ADTOut_MARTHAS" Category="" ClassName="EnsLib.HL7.Operation.TCPOperation" PoolSize="1" Enabled="true" Foreground="false" Comment="" LogTraceEvents="false" Schedule="">
    <Setting Target="Adapter" Name="IPAddress">qdhsst-edg3</Setting>
    <Setting Target="Adapter" Name="Port">6831</Setting>
    <Setting Target="Host" Name="ThrottleDelay">20</Setting>
  </Item>
  <Item Name="ADTOut_MASSGENERAL" Category="" ClassName="EnsLib.HL7.Operation.TCPOperation" PoolSize="1" Enabled="true" Foreground="false" Comment="" LogTraceEvents="false" Schedule="">
    <Setting Target="Adapter" Name="IPAddress">qdhsst-edg4</Setting>
    <Setting Target="Adapter" Name="Port">6801</Setting>
    <Setting Target="Host" Name="ThrottleDelay">0</Setting>
  </Item>
  <Item Name="ADTOut_MORTON" Category="" ClassName="EnsLib.HL7.Operation.TCPOperation" PoolSize="1" Enabled="true" Foreground="false" Comment="" LogTraceEvents="false" Schedule="">
    <Setting Target="Adapter" Name="IPAddress">qdhsst-edg4</Setting>
    <Setting Target="Adapter" Name="Port">6802</Setting>
    <Setting Target="Host" Name="ThrottleDelay">0</Setting>
  </Item>
  <Item Name="ADTOut_MOUNTAUBURN" Category="" ClassName="EnsLib.HL7.Operation.TCPOperation" PoolSize="1" Enabled="true" Foreground="false" Comment="" LogTraceEvents="false" Schedule="">
    <Setting Target="Adapter" Name="IPAddress">qdhsst-edg1</Setting>
    <Setting Target="Adapter" Name="Port">6812</Setting>
    <Setting Target="Host" Name="ThrottleDelay">0</Setting>
  </Item>
  <Item Name="ADTOut_NANTUCKET" Category="" ClassName="EnsLib.HL7.Operation.TCPOperation" PoolSize="1" Enabled="true" Foreground="false" Comment="" LogTraceEvents="false" Schedule="">
    <Setting Target="Adapter" Name="IPAddress">qdhsst-edg3</Setting>
    <Setting Target="Adapter" Name="Port">6832</Setting>
    <Setting Target="Host" Name="ThrottleDelay">20</Setting>
  </Item>
  <Item Name="ADTOut_NEWTONWELLESLEY" Category="" ClassName="EnsLib.HL7.Operation.TCPOperation" PoolSize="1" Enabled="true" Foreground="false" Comment="" LogTraceEvents="false" Schedule="">
    <Setting Target="Adapter" Name="IPAddress">qdhsst-edg4</Setting>
    <Setting Target="Adapter" Name="Port">6803</Setting>
    <Setting Target="Host" Name="ThrottleDelay">20</Setting>
  </Item>
  <Item Name="ADTOut_STURDYMEMORIAL" Category="" ClassName="EnsLib.HL7.Operation.TCPOperation" PoolSize="1" Enabled="true" Foreground="false" Comment="" LogTraceEvents="false" Schedule="">
    <Setting Target="Adapter" Name="IPAddress">qdhsst-edg1</Setting>
    <Setting Target="Adapter" Name="Port">6813</Setting>
    <Setting Target="Host" Name="ThrottleDelay">0</Setting>
  </Item>
  <Item Name="ADTOut_STVINCENT" Category="" ClassName="EnsLib.HL7.Operation.TCPOperation" PoolSize="1" Enabled="true" Foreground="false" Comment="" LogTraceEvents="false" Schedule="">
    <Setting Target="Adapter" Name="IPAddress">qdhsst-edg3</Setting>
    <Setting Target="Adapter" Name="Port">6833</Setting>
    <Setting Target="Host" Name="ThrottleDelay">20</Setting>
  </Item>
  <Item Name="Synthea.HL7Generator" Category="" ClassName="Synthea.HL7Generator" PoolSize="1" Enabled="true" Foreground="false" Comment="" LogTraceEvents="false" Schedule="">
  </Item>
</Production>
]]></Data>
</XData>
</Class>


<Class name="Synthea.HL7RouterRoutingRule">
<Description>
</Description>
<Super>Ens.Rule.Definition</Super>
<TimeChanged>65190,59859.881064</TimeChanged>
<TimeCreated>65190,59859.881064</TimeCreated>

<Parameter name="RuleAssistClass">
<Default>EnsLib.HL7.MsgRouter.RuleAssist</Default>
</Parameter>

<XData name="RuleDefinition">
<XMLNamespace>http://www.intersystems.com/rule</XMLNamespace>
<Data><![CDATA[
<ruleDefinition alias="" context="EnsLib.HL7.MsgRouter.RoutingEngine" production="Synthea.Generator">
<ruleSet name="" effectiveBegin="" effectiveEnd="">
<send transform="" target="ADTOut"></send>
</ruleSet>
</ruleDefinition>
]]></Data>
</XData>
</Class>


<Class name="Synthea.HL7Table">
<Super>%Persistent</Super>
<TimeChanged>65190,59859.033882</TimeChanged>
<TimeCreated>65190,59859.033882</TimeCreated>

<UDLText name="T">
<Content><![CDATA[
// Property HL7 As EnsLib.HL7.Message;

]]></Content>
</UDLText>

<Property name="HL7">
<Type>%String</Type>
<Parameter name="MAXLEN" value="10000000"/>
</Property>

<Property name="EncounterDate">
<Type>%String</Type>
</Property>

<Property name="MRN">
<Type>%String</Type>
</Property>

<Property name="Facility">
<Type>%String</Type>
</Property>

<Property name="PatientSeed">
<Type>%String</Type>
</Property>

<Property name="PopulationSeed">
<Type>%String</Type>
</Property>

<Property name="DateCreated">
<Type>%String</Type>
</Property>

<Index name="EncounterDate">
<Properties>EncounterDate</Properties>
</Index>

<Index name="Facility">
<Properties>Facility</Properties>
</Index>

<Index name="MRN">
<Properties>MRN</Properties>
</Index>

<Index name="DateCreated">
<Properties>DateCreated</Properties>
</Index>

<Storage name="Default">
<Type>%Library.CacheStorage</Type>
<DataLocation>^Synthea.HL7TableD</DataLocation>
<DefaultData>HL7TableDefaultData</DefaultData>
<IdLocation>^Synthea.HL7TableD</IdLocation>
<IndexLocation>^Synthea.HL7TableI</IndexLocation>
<StreamLocation>^Synthea.HL7TableS</StreamLocation>
<Data name="HL7TableDefaultData">
<Value name="1">
<Value>%%CLASSNAME</Value>
</Value>
<Value name="2">
<Value>HL7</Value>
</Value>
<Value name="3">
<Value>EncounterDate</Value>
</Value>
<Value name="4">
<Value>MRN</Value>
</Value>
<Value name="5">
<Value>Facility</Value>
</Value>
<Value name="6">
<Value>PatientSeed</Value>
</Value>
<Value name="7">
<Value>PopulationSeed</Value>
</Value>
<Value name="8">
<Value>DateCreated</Value>
</Value>
</Data>
</Storage>
</Class>


<Class name="Synthea.HS.Gateway.Access.Manager">
<Description><![CDATA[
The default Fetch Manager component.<br>
Manages communication with the edge gateway production.]]></Description>
<IncludeCode>%ZHSLIB,HS.Common</IncludeCode>
<Super>HS.Gateway.ECR.Manager</Super>
<TimeChanged>65231,51591.85809</TimeChanged>
<TimeCreated>60834,47998.069</TimeCreated>

<Parameter name="INVOCATION">
<Description><![CDATA[
for now - check session management & viewer cache before changing]]></Description>
<Default>InProc</Default>
</Parameter>

<Property name="GatewayOperations">
<Description><![CDATA[
Name of the Edge Gateway Remote Operations component in this production. <br> 
Should be the name of a business host that performs actual communications with the<br>
edge gateway Web service(s), via SOAP messages. ]]></Description>
<Type>Ens.DataType.ConfigName</Type>
<InitialExpression>"GATEWAY"</InitialExpression>
</Property>

<Property name="RegistryOperations">
<Description>
Name of the business host that performs communications with the hub Web service, via SOAP messages.</Description>
<Type>Ens.DataType.ConfigName</Type>
<InitialExpression>"HUB"</InitialExpression>
</Property>

<Property name="NotificationOperations">
<Description>
Name of an optional business operation that receives notifications as data arrives and is processed in the aggregation cache</Description>
<Type>Ens.DataType.ConfigName</Type>
</Property>

<Property name="FlashOperations">
<Description><![CDATA[
Name of the Flash Gateway Remote Operations component in this production. <br> 
Should be the name of a business host that performs actual communications with the flash gateway Web service(s), via SOAP messages. ]]></Description>
<Type>Ens.DataType.ConfigName</Type>
<InitialExpression>"FLASH"</InitialExpression>
</Property>

<Property name="Timeout">
<Description>
Timeout for gateway operations</Description>
<Type>%Integer</Type>
<InitialExpression>30</InitialExpression>
</Property>

<Property name="WaitPeriod">
<Description>
How long to wait for fetch operations to complete (in milliseconds)</Description>
<Type>%Integer</Type>
<InitialExpression>2500</InitialExpression>
</Property>

<Property name="WaitTimeoutError">
<Description>
If the wait period expires and some requests are still pending, do we abort them
and return an error status for those requests</Description>
<Type>%Boolean</Type>
<InitialExpression>0</InitialExpression>
</Property>

<Property name="FetchRegistryData">
<Description>
If this is true, the system will issue an additional fetch for each record,
sent to the Registry to retrieve patient cohorts, patient-clinician relationships, etc.
Set this to false if you don't need to retrieve this data, to avoid the overhead of the extra fetch.</Description>
<Type>%Boolean</Type>
<InitialExpression>0</InitialExpression>
</Property>

<Property name="AggregationPreProcessor">
<Description>
If you need to add custom processing immediately prior to aggregating a streamlet, enter the name of
your class that contains a classmethod OnPreAggregate(byRef pStop, pType, byRef pSDA) As %Status.
pType will be input as the full classname of the streamlet type.
pSDA will contain the instantiated SDA object for that streamlet, which your code can modify.  
You may set pStop=1 to prevent aggregation of the streamlet without logging an error.</Description>
<Type>%String</Type>
</Property>

<Parameter name="SETTINGS">
<Description>
Settings for this Business Process</Description>
<Type>%String</Type>
<Default>GatewayOperations,RegistryOperations,WaitPeriod,WaitTimeoutError, Timeout,-UpdatePostProcessor,-ConsentProcessor, -FetchPreProcessor, -MPIUpdateManager, InboundCodeSystemProfile, FetchRegistryData, NotificationOperations, AggregationPreProcessor</Default>
</Parameter>

<XData name="MessageMap">
<Data><![CDATA[
<MapItems>
	<MapItem MessageType="HS.Message.SessionPurgeRequest"> 
		<Method>SessionPurge</Method>
	</MapItem>
	<MapItem MessageType="HS.Message.PatientBatchFetchRequestAsync"> 
		<Method>BatchFetchRequestAsync</Method>
	</MapItem>
	<MapItem MessageType="HS.Message.EPRFetchNotification"> 
		<Method>EPRFetchNotification</Method>
	</MapItem>
</MapItems>
]]></Data>
</XData>

<Method name="constructPatientSDA">
<Description>
Issue multiple, concurrent async requests to the appropriate gateways
and wait until they have completed or the wait period has expired
This method is used for request from the viewer, or if the message is the extended 
HS.Message.PatientBatchQueryRequestAsync, for API based requests and for XDS-b dynamic content</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pRequest:HS.Message.PatientBatchFetchRequestAsync,&pPat:HS.SDA3.Patient,pInboundProfile:%String]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	#dim tSC As %Status
	
	Set tSC=$$$OK
	
	try {
		Set pPat=##Class(HS.SDA3.Patient).%New()
		Set pPat.MPIID=pRequest.MPIID
		Set pPat.Name.FamilyName=pRequest.LastName
		Set pPat.Name.GivenName=pRequest.FirstName
		Set pPat.Name.MiddleName=pRequest.MiddleName
		Set pPat.Name.NamePrefix=pRequest.Prefix
		Set pPat.Name.NameSuffix=pRequest.Suffix
		Set pPat.MothersMaidenName=pRequest.MothersMaidenSurname
		Set pPat.PrimaryLanguage.Code=pRequest.Language
		Set pPat.Religion.Code=pRequest.ReligiousAffiliation
		Set pPat.MaritalStatus.Code=pRequest.MaritalStatus
		Set pPat.Gender.Code=pRequest.Sex
		Set pPat.Extension=pRequest.Extension
		//load multiple races from registry, with optional code table
		Set tCodeTable=##class(HS.Registry.Config).GetKeyValue("\Registry\Patient\RaceCodeTable","")
		For tI=1:1:$L(pRequest.Race,",") {
			Set tRaceDetail=##class(HS.SDA3.CodeTableDetail.Race).%New()
			Set tRaceDetail.Code=$P(pRequest.Race,",",tI)
			If tCodeTable="" {
				Set tRaceDetail.Description=$Case(tRaceDetail.Code,"I":"American Indian","A":"Asian","B":"Black","H":"Hispanic","W":"White",:"")
			} Else {
				Set tCodeOb=##class(HS.Registry.Codes).IDKeyOpen($ZCVT(tCodeTable,"U"),$ZCVT(tRaceDetail.Code,"U"))
				If $IsObject(tCodeOb) {
					Set tRaceDetail.SDACodingStandard=tCodeTable
					Set tRaceDetail.Description=tCodeOb.Description
				}
			}
			Do pPat.Races.Insert(tRaceDetail)
			Set:tI=1 pPat.Race=tRaceDetail
		}
		if (pRequest.EthnicGroup'="") {
			Set tCodeTable=##class(HS.Registry.Config).GetKeyValue("\Registry\Patient\EthnicityCodeTable","")
			Set tEthDetail=##class(HS.SDA3.CodeTableDetail.EthnicGroup).%New()
			Set tEthDetail.Code=pRequest.EthnicGroup
			If tCodeTable="" {
				// mapping based on HS.UI.Registry.Patients:EthnicValueList and EthnicDisplayList
				Set tEthDetail.Description=$Case(tEthDetail.Code,"A":"African","S":"Asian","E":"European","I":"Indian","L":"Latin American","M":"Middle Eastern","P":"Pacific Islander","O":"Other",:"")
			} Else {
				Set tCodeOb=##class(HS.Registry.Codes).IDKeyOpen($ZCVT(tCodeTable,"U"),$ZCVT(tEthDetail.Code,"U"))
				If $IsObject(tCodeOb) {
					Set tEthDetail.SDACodingStandard=tCodeTable
					Set tEthDetail.Description=tCodeOb.Description
				}
			}
			Set pPat.EthnicGroup=tEthDetail
		}
		Set tDOB=pRequest.DOB Set:tDOB'=""&&(tDOB'[",") tDOB=tDOB_",0"
		Set:tDOB'="" pPat.BirthTime=$ZDT(tDOB,3)
		Set pPat.CommunicationPreference=pRequest.CommunicationPreference
		IF pRequest.SSN'="" {
			Set tNum=##Class(HS.SDA3.PatientNumber).%New()
			Set tNum.Number=pRequest.SSN
			Set tNum.NumberType="SSN"
			Do pPat.PatientNumbers.Insert(tNum)
		}
		For tI=1:1:pRequest.Identifiers.Count() {
			Set tIdent=pRequest.Identifiers.GetAt(tI)
			// Skip adding "SN" type Identifiers to the PatientNumbers list.  
			// These are HealthFund MemberNumbers, and not actual PatientNumbers.
			If tIdent.Use = "SN" Continue
			Set tNum=##Class(HS.SDA3.PatientNumber).%New()
			Set tNum.Number=tIdent.Extension
			Set tNum.NumberType=tIdent.Use
			If 'tNum.NumberTypeIsValid(tNum.NumberType) Set tNum.NumberType="OTH"
			Set tNum.Organization=..CodedOrganization(tIdent.AssigningAuthorityName,,pInboundProfile)
			Do pPat.PatientNumbers.Insert(tNum)
		}
		For tI=1:1:pRequest.Addresses.Count() {
			Set tAddr=pRequest.Addresses.GetAt(tI)
			Set tAd=##Class(HS.SDA3.Address).%New()
			Set tAd.Street=tAddr.StreetLine
			Set tAd.City.Code=tAddr.City, tAd.City.Description=tAddr.City
			Set tAd.State.Code=tAddr.State, tAd.State.Description=tAddr.State
			Set tAd.Zip.Code=tAddr.PostalCode, tAd.Zip.Description=tAddr.PostalCode
			Do pPat.Addresses.Insert(tAd)
		}
		For tI=1:1:pRequest.Telecoms.Count() {
			Set tTele=pRequest.Telecoms.GetAt(tI)
			Set tUse=tTele.Use
			IF tUse="H"||(tUse="HP"),pPat.ContactInfo.HomePhoneNumber="" {Set pPat.ContactInfo.HomePhoneNumber=tTele.PhoneNumberFull}
			IF tUse="WP",pPat.ContactInfo.WorkPhoneNumber="" {Set pPat.ContactInfo.WorkPhoneNumber=tTele.PhoneNumberFull}
			IF tTele.Email'="",pPat.ContactInfo.EmailAddress="" {Set pPat.ContactInfo.EmailAddress=tTele.Email}
		}
		} 
		Catch(tEx) {Set tSC=tEx.AsStatus()}
		
		return tSC
]]></Implementation>
</Method>

<Method name="BatchFetchRequestAsync">
<FormalSpec><![CDATA[pRequest:HS.Message.PatientBatchFetchRequestAsync,&pResponse:HS.Message.PatientBatchFetchResponseAsync]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	#dim tSC As %Status
	#dim tIdent As HS.Types.Identifier
	#dim tAddr As HS.Types.Address
	#dim tTele As HS.Types.Telecom
	$$$HSPerfStart("Sending Async Batch Fetch Requests")
	Set tSC=$$$OK,$ZT="Trap"
	Set tSequence=$I(^HS.FetchStatus)
	Set tAgKey=..GetAggregationKeyFromSequenceKey(tSequence)
	Set tToken=""
	Set tInitialNotified=0
	Do {
		
		If ^stConfig("LogBool")  { 
			Set tMetric = ##class(Synthea.StressMetrics).%New()
			Set tMetric.Type = "BatchFetch"
			Set tMetric.ClassName = "HS.Gateway.Access.Manager"
			Set tMetric.LineStart = 184
			Set tMetric.Start = $ZDATETIME($H,3,1,3)
			set tStartZH = $ZH
		}
		
		Kill %streamletDoDefaulting
		Set tAudName=pRequest.LastName_", "_pRequest.FirstName
		Set:pRequest.MiddleName'="" tAudName=tAudName_" "_pRequest.MiddleName
		Set pResponse=##Class(HS.Message.PatientBatchFetchResponseAsync).%New()
		If '$$$HSLicensed("Composite Health Record") Set tSC=$$Error^%apiOBJ(6083,$ZE) Quit
		//create SDA for inserting patient demographics
		//enable CodeTableDetail indexing if using the viewer
		If $$$IsViewerRunning,'pRequest.AggregateOnly { Kill %codetables3 Set %codetables3=0 } 
		//
		set tSC= ..constructPatientSDA(pRequest, .tPat, ..InboundCodeSystemProfile)
		if $$$ISERR(tSC) quit
		For tI=1:1:pRequest.Requests.Count() {
			Set tRequest=pRequest.Requests.GetAt(tI)
			If tI=1 { Set tPat.EnteredAt=..CodedOrganization(tRequest.Facility,,..InboundCodeSystemProfile) }
			Set tNum=##class(HS.SDA3.PatientNumber).%New()
			Set tNum.Number=tRequest.MRN
			Set tNum.Organization=..CodedOrganization(tRequest.AssigningAuthority,,..InboundCodeSystemProfile)
			Set tNum.NumberType="MRN"
			Do tPat.PatientNumbers.Insert(tNum)
		}

	
	
		Set tStrm=##class(HS.SDA3.Streamlet.Patient).%New(),tStrm.SDA=tPat,tStrm.AggregationKey=tAgKey
		set tStrm.SourceMRN=pRequest.Facility_"^"_pRequest.AssigningAuthority_"^"_pRequest.MRN
		Set tSC=tStrm.SaveStreamlet() Quit:$$$ISERR(tSC)
		If 'pRequest.AggregateOnly {
			If $$$IsViewerRunning {
				Set tSC=##class(web.SDA3.Loader).InitialLoad(tAgKey,tStrm,pRequest.SessionId,.tToken)  Kill %codetables3 Quit:$$$ISERR(tSC)
			} Else {Set tToken=$LB(tAgKey)}
		}

		// Queue up a purge for non-API based fetches
		// API based ones are queued for purge by the query process, after the data has been processed



		If '(pRequest.%IsA("HS.Message.PatientBatchQueryRequestAsync")) {
			Set ^HS.Viewer.AGPurgeQ("S","S-"_pRequest.SessionId,tAgKey,$H)=""
		}
		Set pResponse.Token=tToken
		Set pResponse.Sequence=tSequence,tStart=$ZU(188)
		Set tThisGW=##Class(HS.Util.Installer.ConfigItem).GetThisComponentName()
		Lock +^HS.FetchStatus(tSequence,"Pend") //need the lock because multiple jobs might be updating the status
		Set ^HS.FetchStatus(tSequence)=$LB(tToken,tStart,tStart,"","",pRequest.SessionId) //$LB(token,starttime,updatedtime,completetime,aborttime,sessionID)
		
		If 'pRequest.AggregateOnly {
			Set tSC=..SendNotify("Initialize",tAgKey,tToken) Quit:$$$ISERR(tSC)  Set tInitialNotified=1
			Do tStrm.AGNotify(tAgKey)
		}
		//Is there a flash gateway?  If so, and the request is only for a single MPIID,
		// use that instead of going out to the edges
		//***to do - allow for more than one flash gateway, for different uses - for future version


		Set tUseFlash=1,tGotFlash=0
		Set tAudMRNs="",tAudMPIs=$LB(pRequest.MPIID) //for audit
		For tI=1:1:pRequest.Requests.Count() {
			Set tRequest=pRequest.Requests.GetAt(tI)
			Set tMRN=tRequest.Facility_"^"_tRequest.MRN_"^"_tRequest.AssigningAuthority
			Set tAudMRNs=tAudMRNs_$LB(tMRN)
			If tRequest.MPIID'=pRequest.MPIID {
				Set tUseFlash=0
				Set:'$Listfind(tAudMPIs,tRequest.MPIID) tAudMPIs=tAudMPIs_$LB(tRequest.MPIID)
			}
		}
		If tUseFlash {
			&SQL(SELECT Name INTO :tFlashGW FROM HS_Gateway.Config WHERE Type='F' AND Status!='D')
			If SQLCODE'=0 {Set tUseFlash=0}
		}
		//Determine which requests can use flash
		If tUseFlash {
			Set tGotFlash=0
			For tI=1:1:pRequest.Requests.Count() {
				Set tRQ=pRequest.Requests.GetAt(tI),tGW=tRQ.Gateway
				&SQL(Select CacheType INTO :tCacheType FROM HS_Gateway.Config Where EndPoint=:tGW AND Status!='D')
				If SQLCODE=0,tCacheType'="PureQuery",tCacheType'="ExpireAndQuery" {Set tGotFlash=1,tUseFlash(tI)=1}
			}
		}
		If tUseFlash,tGotFlash {
			Set tFRequest=##class(HS.Message.PatientFlashFetchRequestAsync).%New()
			Set tFRequest.ConsentApplied=pRequest.ConsentApplied
			Set tFRequest.MPIID=pRequest.MPIID
			Set tFRequest.FlashGateway=tFlashGW
			Set tFRequest.AccessGateway=tThisGW
			Set tFRequest.Sequence=tSequence
			Set tFRequest.Token=$LG(tToken)
			Set tFRequest.Filters=pRequest.Requests.GetAt(1).Filters
			Set tFRequest.InstanceGUID=##Class(%SYS.System).InstanceGUID()
			Set tFRequest.RequestId=pRequest.RequestId
			Set tSC=##Class(HS.Util.CopyFrom).CopyFrom(pRequest,.tFRequest)
			Set tMRN="Flash^Flash^"
			Set ^HS.FetchStatus(tSequence,"Demographics",tMRN)=1
			Set ^HS.FetchStatus(tSequence,"Pend",tMRN)="",^HS.FetchStatus(tSequence,"Queue",tMRN)=""
			Set ^HS.FetchStatus(tSequence,"Stats",tMRN)=$LB($zu(188),"","",0,"",1)
			For tI=1:1:pRequest.Requests.Count() {
				Continue:'$D(tUseFlash(tI))
				Set tRequest=##Class(HS.Message.PatientFetchRequestAsync).%New()
				Set tSC=tRequest.CopyFrom(pRequest.Requests.GetAt(tI),.tRequest) Quit:$$$ISERR(tSC)
				Set tRequest.AdditionalInfo=pRequest.Requests.GetAt(tI).AdditionalInfo //we may need this for audit
				Set tRequest.SAMLData=pRequest.Requests.GetAt(tI).SAMLData //we may need this for audit
				For tJ=1:1:pRequest.Requests.GetAt(tI).Identifiers.Count() {
					Do tRequest.Identifiers.Insert(pRequest.Requests.GetAt(tI).Identifiers.GetAt(tJ))
				}
				Do tFRequest.Requests.Insert(tRequest)
			}
			Set tSC=..SendRequestAsync(..FlashOperations,tFRequest)
		}
		
		
		//For each request in the list, create an async request thinger, log it in the global, fire off remote operations
		Set tUseParallel=##class(Ens.Director).GetCurrProductionSettingValue("UseParallelFetch")
		For tI=1:1:pRequest.Requests.Count() {
			Continue:$D(tUseFlash(tI))
			Set tRequest=##Class(HS.Message.PatientFetchRequestAsync).%New()
			Set tSC=tRequest.CopyFrom(pRequest.Requests.GetAt(tI),.tRequest) Quit:$$$ISERR(tSC)
			Set tRequest.UseParallelFetch=tUseParallel
			Set:tUseParallel tRequest.InstanceGUID = ##Class(%SYS.System).InstanceGUID()
			Set tMRN=tRequest.Facility_"^"_tRequest.MRN_"^"_tRequest.AssigningAuthority
			
			Set tRequest.AdditionalInfo=pRequest.Requests.GetAt(tI).AdditionalInfo //copyfrom misses that
			Set tRequest.SAMLData=pRequest.Requests.GetAt(tI).SAMLData
			Set tRequest.Filters=pRequest.Requests.GetAt(tI).Filters //and that
			Set tRequest.Sequence=tSequence
			Set tRequest.ReturnGateway=tThisGW
			Set tRequest.Token=$LG(tToken)
			Set tMatch=pRequest.Requests.GetAt(tI)
			//copy identifiers
			For tJ=1:1:tMatch.Identifiers.Count() Do tRequest.Identifiers.Insert(tMatch.Identifiers.GetAt(tJ))
			#; Use the demographics from the first patient request.
			If tI=1,'tGotFlash Set ^HS.FetchStatus(tSequence,"Demographics",tMRN)=1
			Set ^HS.FetchStatus(tSequence,"Pend",tMRN)="",^HS.FetchStatus(tSequence,"Queue",tMRN)=""
			Set ^HS.FetchStatus(tSequence,"Stats",tMRN)=$LB($zu(188),"","",0,"",1) //$LB(startfetchtime,startloadtime,completetime,# of encs loaded,start date of last enc loaded,%status)
			Set tSC=..SendRequestAsync(..GatewayOperations,tRequest)
		}
		If ..FetchRegistryData {
			
			//Here it sends a request somewhere
			
			Set tRequest=##class(HS.Message.RegistrySDARequest).%New(),tRequest.MPIID=pRequest.MPIID
			Set tRequest.NotifyOperations=..%ConfigName, tRequest.Sequence=tSequence
			// Be careful with changing this MRN. Currently it is used by EPRFetchNotification()
			// as well as web.SDA3.Loader:OnAfterContainerLoad() (at least)
			Set tMRN="Registry^Registry^"
			Set ^HS.FetchStatus(tSequence,"Pend",tMRN)="",^HS.FetchStatus(tSequence,"Queue",tMRN)=""
			Set ^HS.FetchStatus(tSequence,"Stats",tMRN)=$LB($zu(188),"","",0,"",1) //$LB(startfetchtime,startloadtime,completetime,# of encs loaded,start date of last enc loaded,%status)
			Set tSC=..SendRequestSync(..RegistryOperations,tRequest,.tResponse)
			IF $$$ISERR(tSC) {
				Set tResponse=##Class(HS.Message.EPRFetchNotification).%New(),tResponse.Status=tSC
			} Else {
				Set tResponse.Facility="Registry",tResponse.MRN="Registry",tResponse.AssigningAuthority="",tResponse.Validated=1
				Set tResponse.Status=$$$OK
			}
			Set tSC=..EPRFetchNotification(tResponse,.tDummy)
		}
		
		Lock -^HS.FetchStatus(tSequence,"Pend")
		Quit:$$$ISERR(tSC)
		//Audit the request
		IF pRequest.%IsA("HS.Message.PatientBatchQueryRequestAsync") {
			Set tSC=$$$HSAuditExportRecords(.tLogID,pRequest.RequestId,pRequest.RequestingUser,pRequest.RequestingUserRoles,pRequest.RequestingGateway,tAudMRNs,..%SessionId,pRequest.RequestingForProxyUserID,tAudName,tAudMPIs)
		} Else {
			Set tSC=$$$HSAuditViewRecords(.tLogID,pRequest.RequestId,pRequest.RequestingUser,pRequest.RequestingUserRoles,pRequest.RequestingGateway,tAudMRNs,..%SessionId,pRequest.RequestingForProxyUserID,tAudName,tAudMPIs)
		}
		Quit:$$$ISERR(tSC)
		//Loop on .1 second boundary until wait time has passed or '$D(queue)
		Set tWaitPeriod=..WaitPeriod, tWaitTimeoutError=..WaitTimeoutError
		IF pRequest.%IsA("HS.Message.PatientBatchQueryRequestAsync") {
			Set tWaitPeriod=pRequest.WaitPeriod, tWaitTimeoutError=pRequest.WaitTimeoutError
		}
		For tI=0:100:tWaitPeriod-1 Hang .1 Quit:'$D(^HS.FetchStatus(tSequence,"Queue"))
		Set tMRN=""
		Set pResponse.Token=tToken
		For  {
			Set tMRN=$O(^HS.FetchStatus(tSequence,"Stats",tMRN),1,tStat) Quit:tMRN=""
			If tMRN="Flash^Flash^",$$$ISOK($LG(tStat,6)),'$D(^HS.FetchStatus(tSequence,"Pend",tMRN))!('tWaitTimeoutError) {
				For tFState="FlashOK","FlashErr" {
					Set tStatusList=$G(^HS.FetchStatus(tSequence,tFState,tMRN))
					For tI=1:1:$LL(tStatusList) {
						Set tFMRN=$LG(tStatusList,tI)
						Do pResponse.Facility.Insert($P(tFMRN,"^"))
						If tFState="FlashOK" {
							Do pResponse.RequestStatus.Insert($$$OK)
						} Else {
							Set tSC2=$$$ERROR($$$GeneralError,$$$FormatText("Error retrieving MRN %1",tFMRN))
							Do pResponse.RequestStatus.Insert(tSC2)
						}
					}
				}
				Continue
			}
			Do pResponse.Facility.Insert($P(tMRN,"^"))
			IF $$$ISERR($LG(tStat,6)) {
				Do pResponse.RequestStatus.Insert($LG(tStat,6))
				Kill ^HS.FetchStatus(tSequence,"Pend",tMRN),^HS.FetchStatus(tSequence,"Queue",tMRN)
			} ELSEIF '$D(^HS.FetchStatus(tSequence,"Pend",tMRN))!('tWaitTimeoutError) {
				DO pResponse.RequestStatus.Insert($$$OK)
			} Else {
				Set $List(^HS.FetchStatus(tSequence),5)=$ZU(188) //abort additional fetches
				Set tResult = $$$HSError($$$HSErrRequestTimeout,$P(tMRN,"^"),(tWaitPeriod/1000))
				Do pResponse.RequestStatus.Insert(tResult)
			}
		}
		
		If ^stConfig("LogBool") { 
 		   	set tMetric.Elapsed = $ZH - tStartZH
			Set tMetric.End = $ZDATETIME($H,3,1,3)
			Set tMetric.LineEnd = 381
			Set ltSC = tMetric.Save()
			Quit:$$$ISERR(ltSC)
		}
		
	} While (0)
Exit
	If tInitialNotified{
		If $$$ISERR(tSC) {Do ..SendNotify("Abort",tAgKey,tToken,tSC)}
		ElseIf $LG(^HS.FetchStatus(tSequence),5) {Do ..SendNotify("Abort",tAgKey,tToken,$$$ERROR($$$HSErrRequestTimeout))}
		ElseIf $D(^HS.FetchStatus(tSequence,"Queue")) {Do ..SendNotify("WaitTimeout",tAgKey,tToken)}
	}
	$$$HSPerfEnd
	Quit tSC
Trap
	Set $ZT="",tSC=$$$EnsSystemError
	IF $D(tSequence),$D(^HS.FetchStatus(tSequence)) {
		Set $List(^HS.FetchStatus(tSequence),5)=$ZU(188)
	}
	Set tMRN=""
	For  {
		Set tMRN=$O(^HS.FetchStatus(tSequence,"Pend",tMRN)) Quit:tMRN=""
		Do pResponse.Facility.Insert($P(tMRN,"^"))
		Do pResponse.RequestStatus.Insert(tSC)
	}

	Goto Exit
]]></Implementation>
</Method>

<Method name="EPRFetchNotification">
<FormalSpec><![CDATA[pRequest:HS.Message.EPRFetchNotification,&pResponse:Ens.Response]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	#dim tSC As %Status
	#dim tSDA As HS.SDA3.SuperClass
	Kill %HSTranslate //clear out any leftover translation profile
	Set tSC=$$$OK,tMRN="",tSequence="",tNonFatal=$$$OK, tStreamC=""
	If ..AggregationPreProcessor'="" {
		If '##class(%Dictionary.CompiledClass).%ExistsId(..AggregationPreProcessor){
			Quit $$$ERROR($$$GeneralError,$$$FormatText("Aggregation PreProcessor class %1 does not exist",..AggregationPreProcessor))
		}
		If '##class(%Dictionary.CompiledMethod).%ExistsId(..AggregationPreProcessor_"||OnPreAggregate") {
			Quit $$$ERROR($$$GeneralError,$$$FormatText("Aggregation PreProcessor class %1 does not have OnPreAggregate method",..AggregationPreProcessor))
		}
	}
	Set tEdgeSession=pRequest.EdgeSession
	Try {
		If tEdgeSession'="" {
			Set tEdgeSessionHdr=^CacheTemp.HS.EdgeSession(tEdgeSession)
			Set pRequest.AssigningAuthority=$LG(tEdgeSessionHdr,1)
			Set pRequest.MRN=$LG(tEdgeSessionHdr,2)
			Set pRequest.Facility=$LG(tEdgeSessionHdr,3)
			Set pRequest.MPIID=$LG(tEdgeSessionHdr,4)
			Set pRequest.Sequence=$LG(tEdgeSessionHdr,5)
			If $LG(tEdgeSessionHdr,6)'="" Do ##class(HS.SDA3.Streamlet.ContainerMethods).LoadTranslationProfile($LG(tEdgeSessionHdr,6))
			Set %SDAData=pRequest.Facility_"^"_pRequest.AssigningAuthority_"^"_pRequest.MRN
		}
		Set tSequence=pRequest.Sequence
		Set tStat=^HS.FetchStatus(tSequence)
		Quit:$LG(tStat,5)'=""  //If fetch was aborted
		Set tAgKey=..GetAggregationKeyFromSequenceKey(tSequence)
		Set tNumEnc=0
		//tToken will be null except when we are loading data into the viewer
		Set tToken=$LG(tStat),tMRN=pRequest.Facility_"^"_pRequest.MRN_"^"_pRequest.AssigningAuthority
		Set tSC=pRequest.Status Quit:$$$ISERR(tSC)
		Set tTime=$ZU(188),$List(^HS.FetchStatus(tSequence,"Stats",tMRN),2)=tTime
		Set $List(^HS.FetchStatus(tSequence),3)=tTime
		Quit:pRequest.Action="0"  //for Surescripts, this is how they indicate no data
		Do ..LoadCodeProfile(pRequest.InboundCodeSystemProfile)
		If tEdgeSession="" {
			Set tContainer=##class(HS.SDA3.Container).%New()
			Set tSC=tContainer.InitializeXMLParse(pRequest.ContentStream,pRequest.StreamContentType) Quit:$$$ISERR(tSC)
		}
		If tMRN="Registry^Registry^"||(tMRN="Flash^Flash") {
			Set tTier=0
		} Else {
			Set tTier=##class(HS.Facility.Config).%OpenId(pRequest.Facility),tTier=$S($IsObject(tTier):tTier.Tier,1:1)
		}
		Kill %codetables3 Set %codetables3=0 //reset and turn on code table processing
		Set tSendingFac=$P(%SDAData,"^") //this gets set during InitializeXMLParse, via isc:evaluate
		Set:tSendingFac="" tSendingFac=pRequest.Facility
		Set tAA=$P(%SDAData,"^",2) Set:tAA="" tAA=pRequest.AssigningAuthority
		Set tNum=$P($P(%SDAData,"^",3),"||") Set:tNum="" tNum=pRequest.MRN
		Set tSrcMRN=tSendingFac_"^"_tAA_"^"_tNum
		If tEdgeSession="" {
			For {
				Set %codetables3=0
				Set tGot=tContainer.GetNextSDA(.tType, .tSDA,.tSC,.tDate)
				Quit:$$$ISERR(tSC)  Quit:'tGot
				If tType="Encounter" Set tSC=..EncounterTweaks(tNum, tAA, tSendingFac, tSequence, tMRN, .tSDA) Quit:$$$ISERR(tSC)
				$$$HSTRACE("Save Streamlet","tType,tSDA",tType,tSDA)
				Set tSC=..SaveStreamlet(tType, tSrcMRN, tAgKey, tTier, tDate, tToken, pRequest.Validated, .tSDA, ..AggregationPreProcessor)
				If $$$ISERR(tSC),tType="Patient" Quit // error in processing patient streamlet is fatal
			}
		} Else {
			Set tMaxJobs=$$$ConfigValue("\AccessManager\MaxJobs",6)
			Set tTarget=$$$ConfigValue("\AccessManager\StreamletsPerJob",400)
			Set tJobs=^CacheTemp.HS.EdgeSession(tEdgeSession,"C")/tTarget+.9\1
			Set:tJobs>tMaxJobs tJobs=tMaxJobs
			Set tLaunched=$S(tJobs>1:0,1:1)
			Set tMaxRank=$G(^CacheTemp.HS.EdgeSession(tEdgeSession,"C"))
			For {
				Set %codetables3=0
				Set tRank=$I(^CacheTemp.HS.EdgeSession(tEdgeSession,"GetNext"))
				IF tRank>tMaxRank {
					Lock +^HS.Gateway.Access.Manager.Background(tEdgeSession) //make sure all background jobs are done
					Lock -^HS.Gateway.Access.Manager.Background(tEdgeSession)
					Kill:'$D(^HS.EdgeSession.Debug) ^CacheTemp.HS.EdgeSession(tEdgeSession)
					Quit
				}
				Set tStuff=^(tRank),tClass=$LG(tStuff),tDate=$LG(tStuff,5)
				If $LG(tStuff,10)'="" {
					Set tSrcMRN=$LG(tStuff,10),tSendingFac=$P(tSrcMRN,"^"), tAA=$P(tSrcMRN,"^",2), tNum=$P(tSrcMRN,"^",3)
				}
				If 'tLaunched,tClass'="HS.SDA3.Patient", tClass'="HS.SDA3.Encounter" {
					Set tLaunched=1
					For tI=2:1:tJobs {
						Set tDoTrace=##this.TraceOperations="*FULL*"
						Job ..Background(tEdgeSession, tSrcMRN, tAgKey, tTier, tToken, $LG(tEdgeSessionHdr,6), ..InboundCodeSystemProfile, pRequest.InboundCodeSystemProfile, ..AggregationPreProcessor, tDoTrace)
						$$$HSTRACEMIN("Started background job "_$ZCHILD)
					}
				}
				Set tStrmClass=$$$StreamletClass(tClass)
				Set tSDA=$ClassMethod(tClass,"%New")
				Set tSC=tSDA.XMLImportSDAString($LG(tStuff,3)) Quit:$$$ISERR(tSC)
				If tClass="HS.SDA3.Encounter" {
					Set tSC=..EncounterTweaks(tNum, tAA, tSendingFac, tSequence, tMRN, .tSDA) Quit:$$$ISERR(tSC)
				}
				$$$HSTRACE("Save Streamlet","tClass,tSDA",tClass,tSDA)
				Set tSC=..SaveStreamlet(tClass, tSrcMRN, tAgKey, tTier, tDate, tToken, pRequest.Validated, .tSDA, ..AggregationPreProcessor)
				If $$$ISERR(tSC),tClass="HS.SDA3.Patient" Quit // error in processing patient streamlet is fatal
			}
		}
		Quit:$$$ISERR(tSC)
		If tToken'="",$$$IsViewerRunning Set tSC=##class(web.SDA3.Loader).OnAfterContainerLoad(tAgKey,.tToken,tMRN) Quit:$$$ISERR(tSC)
	} Catch(tEx) {Set tSC=tEx.AsStatus()}

	Set tTime=$ZU(188), tStatus=$S($$$ISERR(tSC):tSC,1:tNonFatal)
	IF (tSequence'="")&&(tMRN'="") {
		If $$$ISOK(tStatus) {
			Kill ^HS.FetchStatus(tSequence,"Pend",tMRN)
			If pRequest.FlashStatus.Count() {
				Set tKey="",tFlashOK="",tFlashErr=""
				For {
					//each key is an MRN (tFacility_"^"_tAA_"^"_tMRN)
					Set tVal=pRequest.FlashStatus.GetNext(.tKey) Quit:tKey=""
					If tVal=$$$FlashStatusReady {Set tFlashOK=tFlashOK_$LB(tKey)}
					Else { Set tFlashErr=tFlashErr_$LB(tKey)}
				}
				Set:tFlashErr'="" ^HS.FetchStatus(tSequence,"FlashErr",tMRN)=tFlashErr
				Set ^HS.FetchStatus(tSequence,"FlashOK",tMRN)=tFlashOK
			}
		}
		Kill ^HS.FetchStatus(tSequence,"Queue",tMRN)
		Set $List(^HS.FetchStatus(tSequence,"Stats",tMRN),3)=tTime,$List(^HS.FetchStatus(tSequence,"Stats",tMRN),6)=tStatus
		Lock +^HS.FetchStatus(tSequence,"Pend")
		Set tDone='$D(^HS.FetchStatus(tSequence,"Pend"))
		IF 'tDone {Set $List(^HS.FetchStatus(tSequence),3)=tTime}
		Else {Set $List(^HS.FetchStatus(tSequence),3,4)=$LB(tTime,tTime)}
		Lock -^HS.FetchStatus(tSequence,"Pend")
		If tDone {Do ..SendNotify("FetchComplete",tAgKey,tToken)}
		ElseIf $$$ISOK(tSC) {Do ..SendNotify("FetchNotification",tAgKey,tToken)}
	}
	If $IsObject(tStreamC) Do tStreamC.Clear(1) //clean up quickstream
	Quit tSC
]]></Implementation>
</Method>

<Method name="Background">
<Description><![CDATA[
Jobbed in the background
This assumes patient & encounter streamlet processing has been done]]></Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>pEdgeSession,pSrcMRN,pAgKey,pTier,pToken,pTransProfile,pMyInboundProfile,pReqInboundProfile,pAggregationPreProcessor,pTracing</FormalSpec>
<Implementation><![CDATA[
	Try {
		Lock ^HS.Gateway.Access.Manager.Background(pEdgeSession,$J)
		Set %session=##class(HS.Util.SessionCache).%New()
		If pTransProfile'="" Do ##class(HS.SDA3.Streamlet.ContainerMethods).LoadTranslationProfile(pTransProfile)
		Do ..LoadInboundProfile(pMyInboundProfile)
		Do ..LoadCodeProfile(pReqInboundProfile)
		Set tMaxRank=$G(^CacheTemp.HS.EdgeSession(pEdgeSession,"C")) Quit:'tMaxRank
		For {
			Set %codetables3=0, tSC=$$$OK
			Set tRank=$I(^CacheTemp.HS.EdgeSession(pEdgeSession,"GetNext"))
			Quit:tRank>tMaxRank
			Set tStuff=^(tRank),tClass=$LG(tStuff),tDate=$LG(tStuff,5)
			Set tSrcMRN=pSrcMRN
			If $LG(tStuff,10)'="" {	Set tSrcMRN=$LG(tStuff,10) }
			Set tStrmClass=$$$StreamletClass(tClass)
			Set tSDA=$ClassMethod(tClass,"%New")
			Set tSC=tSDA.XMLImportSDAString($LG(tStuff,3)) Quit:$$$ISERR(tSC)
			If pTracing {
				Set tRequest=##Class(HS.Util.Trace.Request).%New()
				Set tRequest.CurrentClass=$ClassName()
				Set tRequest.CurrentMethod="Background"
				Set tRequest.Comment="SaveStreamlet"
				Set tItem=##Class(HS.Util.Trace.Item).%New()
				Set tItem.ItemName="tClass",tItem.ItemValue=tClass
				Do tRequest.Items.Insert(tItem)
				Set tItem=##Class(HS.Util.Trace.Item).%New()
				Set tItem.ItemName="tSDA",tItem.ItemValue=$LG(tStuff,3)
				Do tRequest.Items.Insert(tItem)
				Do ##Class(HS.Util.MaintenanceService).SendSync(tRequest)
			}
			Set tSC=..SaveStreamlet(tClass, tSrcMRN, pAgKey, pTier, tDate, pToken, 1, .tSDA, pAggregationPreProcessor)
		}
	} Catch ex {
		Set tSC = ex.AsStatus()
	}
	If $$$ISERR(tSC) { $$$LOGALERT($system.Status.GetErrorText(tSC)) }
	Lock  Quit
]]></Implementation>
</Method>

<Method name="EncounterTweaks">
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pNum,pAA,pSendingFac,pSequence,pMRN,&pSDA]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Try {
		Set tSC=$$$OK
		Set pSDA.EncounterMRN=pNum
		Set pSDA.EncounterMRNAA=pAA
		If '(pSDA.IsDefined("HealthCareFacility")) {
			Set tHCF=##Class(HS.SDA3.CodeTableDetail.HealthCareFacility).%New()
			Set tHCF.Code=pSendingFac
			Set tOrg=##class(HS.SDA3.CodeTableDetail.Organization).%New()
			Set tOrg.Code=pSendingFac
			Set tOrg.SDACodingStandard=$G(%HSCodeSystem("Organization"))
			If tOrg.SDACodingStandard'="",tOrg.Code'="",$D(^HS.Registry.CodesD(tOrg.SDACodingStandard,tOrg.Code),tList) {Set tOrg.Description=$LI(tList,4)}
			Set tHCF.Organization=tOrg
			Set pSDA.HealthCareFacility=tHCF
		}
		Set tNumEnc=$LG(^HS.FetchStatus(pSequence,"Stats",pMRN),4)+1
		Set $List(^HS.FetchStatus(pSequence,"Stats",pMRN),4)=tNumEnc
	} Catch ex {
		Set tSC = ex.AsStatus()
	}
    Quit tSC
]]></Implementation>
</Method>

<Method name="SaveStreamlet">
<ClassMethod>1</ClassMethod>
<FormalSpec>pClass,pSrcMRN,pAgKey,pTier,pDate,pToken,pValidated,pSDA,pPreProcessor=""</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Try {
		Set tSC=$$$OK
		Set tStrmClass=$$$StreamletClass(pClass)
		Set tStreamlet=$ClassMethod(tStrmClass,"%New")
		Set tStreamlet.SourceMRN=pSrcMRN
		Set tStop=0
		If pPreProcessor'="" {
			Set tSC=$ClassMethod(pPreProcessor,"OnPreAggregate",.tStop, tStrmClass, pSDA) Quit:$$$ISERR(tSC)
		}
		Quit:tStop
		Set tStreamlet.SDA=pSDA, tStreamlet.EncounterNumber=$system.Util.Collation(pSDA.EncounterNumber,6)
		Set tSC=tStreamlet.Aggregate(pAgKey,pTier,pDate,pToken,"", pValidated)
		Kill %codetables3
		IF $$$ISERR(tSC) {
			$$$LOGALERT($system.Status.GetErrorText(tSC))
		}
	} Catch ex {
		Set tSC = ex.AsStatus()
	}
    Quit tSC
]]></Implementation>
</Method>

<Method name="CodedOrganization">
<Description><![CDATA[
Plug in the values for an organization, including code system & description, where we only have a code]]></Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>pCode:%String,pIsEncounter=0,pInboundProfile</FormalSpec>
<ReturnType>HS.SDA3.CodeTableDetail.Organization</ReturnType>
<Implementation><![CDATA[
	Set tOrg=##class(HS.SDA3.CodeTableDetail.Organization).%New()
	Set tOrg.Code=pCode
	If pIsEncounter {
		//when we're loading encounters, %HSCodeSystem has the inbound profile from the edge
		Set tOrg.SDACodingStandard=$G(%HSCodeSystem("Organization"))
	} Else {
		//when we're loading the initial patient record, we have to use our inbound profile,
		//since we don't know the one from the edge
		Set:pInboundProfile'="" tOrg.SDACodingStandard=$G(%HSCodeInboundProfile("Organization"))
	}
	If tOrg.SDACodingStandard'="",tOrg.Code'="",$D(^HS.Registry.CodesD(tOrg.SDACodingStandard,tOrg.Code),tList) {Set tOrg.Description=$LI(tList,4)}
	Quit tOrg
]]></Implementation>
</Method>

<Method name="SessionPurge">
<Description>
Purge data associated with a session, or for API based fetches</Description>
<FormalSpec><![CDATA[pRequest:HS.Message.SessionPurgeRequest,&pResponse:HS.Message.SessionPurgeResponse]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	#dim tSC As %Status=$$$OK
	Try {
		Set pResponse=##class(HS.Message.SessionPurgeResponse).%New()
		// Process purge for all eligible SessionIds
		Set tSessionId=""
		For {
			Set tSessionId=$O(^HS.Viewer.AGPurgeQ("S",tSessionId)) Quit:tSessionId=""
			// tSessionId is either a CSP Session ID ("S-" prefix) or "API"  
			// For CSP Sessions, defer the purge while the session is still alive
			If ($e(tSessionId,1,2)="S-"),$D(^%cspSession($e(tSessionId,3,*))) Continue
			Set tSC = ##class(HS.SDA3.Streamlet.ContainerMethods).PurgeDataBySession(tSessionId)
			//in case of error, log it and continue purging
			If $$$ISERR(tSC) {$$$LOGERROR($system.Status.GetErrorText(tSC))}
			// Remove SessionId node if no AgKeys present.
			If $D(^HS.Viewer.AGPurgeQ("S",tSessionId))=1 Kill ^HS.Viewer.AGPurgeQ("S",tSessionId)
		}	
	}
	Catch (tEx) { Set tSC=tEx.AsStatus() }
	Quit tSC
]]></Implementation>
</Method>

<Method name="SendNotify">
<FormalSpec>pType,pAGKey,pToken,pErrStatus:%Status=""</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Quit:..NotificationOperations="" $$$OK
	Set tMessage=##class(HS.Message.AggregationNotification).%New()
	Set tMessage.Type=pType
	Set tMessage.AGKey=pAGKey
	Set tMessage.Token=pToken
	Set tMessage.ErrStatus=pErrStatus
	Set tMessage.ActionCount=+$G(^CacheTemp.HS.AGNotifyStreamlet($namespace,pAGKey,0))
	Set tSequence=..GetSequenceKeyFromAggregationKey(pAGKey)
	If pType="Initialize" {
		 Set $List(^HS.FetchStatus(tSequence),7)=1
	} Else {
		Quit:'$LG(^HS.FetchStatus(tSequence),7) $$$OK
	}
	Quit ..SendRequestAsync(..NotificationOperations,tMessage)
]]></Implementation>
</Method>

<Method name="LoadCodeProfile">
<Description>
Construct a union of the configured inbound profile with the profile from the edge.
Any code tables from the edge profile take precedence</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>pProfile</FormalSpec>
<Implementation><![CDATA[
	Kill %HSCodeSystem
	Merge %HSCodeSystem=%HSCodeInboundProfile
	Quit:pProfile=""
	Set tProf=##Class(HS.Registry.CodeSystemProfile).%OpenId($ZCVT(pProfile,"U"))
	If '$IsObject(tProf) {$$$LOGERROR("CodeSystemProfile not found: "_pProfile)}
	Else {
		For tI=1:1:tProf.CodeTables.Count() {
			Set tCT=tProf.CodeTables.GetAt(tI)
			Set %HSCodeSystem(tCT.CodeTable)=$ZCVT(tCT.CodeSystem,"U")
		}
	}
]]></Implementation>
</Method>

<Method name="OnInit">
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Do ..LoadInboundProfile(..InboundCodeSystemProfile)
	Set %ImgViewingSvc=##class(Ens.Director).GetCurrProductionSettingValue("ImageViewerIntegration",.tSC)
	Quit $$$OK
]]></Implementation>
</Method>

<Method name="LoadInboundProfile">
<ClassMethod>1</ClassMethod>
<FormalSpec>pProfile</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Kill %HSCodeInboundProfile
	if pProfile = "" {
		set tProfile=##class(HS.Registry.Config).GetKeyValue("\Terminology\InboundCodeSystemProfile","")
	}
	IF pProfile'="" {
		Set tProf=##Class(HS.Registry.CodeSystemProfile).%OpenId($ZCVT(pProfile,"U"))
		If '$IsObject(tProf) {$$$LOGERROR("InboundCodeSystemProfile not found: "_pProfile)}
		Else {
			For tI=1:1:tProf.CodeTables.Count() {
				Set tCT=tProf.CodeTables.GetAt(tI)
				Set %HSCodeInboundProfile(tCT.CodeTable)=$ZCVT(tCT.CodeSystem,"U")
			}
		}
	}
	
	Quit $$$OK
]]></Implementation>
</Method>

<Method name="GetAggregationKeyFromSequenceKey">
<Description><![CDATA[
API Method
Helper method to compute the Aggregation Key from the Sequence Key in <var>pSequenceKey</var>.]]></Description>
<Final>1</Final>
<ClassMethod>1</ClassMethod>
<CodeMode>expression</CodeMode>
<FormalSpec>pSequenceKey:%String</FormalSpec>
<ReturnType>%String</ReturnType>
<ServerOnly>1</ServerOnly>
<Implementation><![CDATA[..GetAggregationKeyPrefix()_pSequenceKey
]]></Implementation>
</Method>

<Method name="GetCSPSessionForAggregationKey">
<Description>
API Method 
Helper method to retrieve the CSP Session ID for an Aggregation Key</Description>
<Final>1</Final>
<ClassMethod>1</ClassMethod>
<FormalSpec>pAggregationKey:%String</FormalSpec>
<ReturnType>%String</ReturnType>
<ServerOnly>1</ServerOnly>
<Implementation><![CDATA[
	Set tSequenceKey = ..GetSequenceKeyFromAggregationKey(pAggregationKey)
	If (tSequenceKey = "") {
		Quit ""
	}
	ElseIf $data(^HS.FetchStatus(tSequenceKey),tFetchData)#2 {
		Quit $listget(tFetchData,6)
	}
	Else {
		Quit ""
	}
]]></Implementation>
</Method>

<Method name="GetSequenceKeyFromAggregationKey">
<Description><![CDATA[
Helper method to compute the Sequence Key from the Aggregation Key in <var>pAggregationKey</var>.]]></Description>
<Final>1</Final>
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec>pAggregationKey:%String</FormalSpec>
<ReturnType>%String</ReturnType>
<ServerOnly>1</ServerOnly>
<Implementation><![CDATA[
	Set tPrefix = ..GetAggregationKeyPrefix()
	Set tPrefixLen = $length(tPrefix)
	If ($extract(pAggregationKey,1,tPrefixLen) = tPrefix) {
		Quit $extract(pAggregationKey,tPrefixLen+1,*)
	}
	Else {
		Quit ""
	}
]]></Implementation>
</Method>

<Method name="GetAggregationKeyPrefix">
<Final>1</Final>
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<CodeMode>expression</CodeMode>
<Private>1</Private>
<ReturnType>%String</ReturnType>
<ServerOnly>1</ServerOnly>
<Implementation><![CDATA["T" _ $namespace _ "|"
]]></Implementation>
</Method>

<Storage name="Default">
<Type>%Library.CacheStorage</Type>
<DefaultData>ManagerDefaultData1</DefaultData>
<Data name="ManagerDefaultData1">
<Subscript>"Manager1"</Subscript>
<Value name="1">
<Value>GatewayOperations</Value>
</Value>
<Value name="2">
<Value>Timeout</Value>
</Value>
<Value name="3">
<Value>Wrapper</Value>
</Value>
</Data>
<Data name="Pending">
<Attribute>Pending</Attribute>
<Structure>subnode</Structure>
<Subscript>"Pending"</Subscript>
</Data>
</Storage>
</Class>


<Class name="Synthea.HS.Gateway.ECR.MPIUpdateManager1">
<Description><![CDATA[
Default class to update the MPI.<br>
Receives update requests from the ECR manager, determines how to handle them, and then communicates 
with the Hub remote operations.
The class may be overridden in order to use some callback notifications - see the On* methods]]></Description>
<IncludeCode>HS.Common,%callout,%ZHSLIB</IncludeCode>
<ProcedureBlock>1</ProcedureBlock>
<Super>HS.Util.Trace.Helper,Ens.BusinessOperation</Super>
<TimeChanged>65231,64682.561568</TimeChanged>
<TimeCreated>65190,59859.777315</TimeCreated>
<Inheritance>right</Inheritance>

<Parameter name="INVOCATION">
<Default>Queue</Default>
</Parameter>

<Property name="MPIOperations">
<Description>
Name of the business host that performs communications with the hub Web service, via SOAP messages.</Description>
<Type>Ens.DataType.ConfigName</Type>
<InitialExpression>"HUB"</InitialExpression>
</Property>

<Property name="PushRepMgr">
<Description>
No longer used</Description>
<Type>Ens.DataType.ConfigName</Type>
<InitialExpression>"HS.Gateway.ECR.Push.RepositoryManager"</InitialExpression>
</Property>

<Property name="SubscriptionHandler">
<Description>
Handler for push subscriptions</Description>
<Type>Ens.DataType.ConfigName</Type>
<InitialExpression>"SubscriptionHandler"</InitialExpression>
</Property>

<Property name="DoPush">
<Description>
Is push configured?</Description>
<Type>%Boolean</Type>
</Property>

<Property name="FailureTimeout">
<Description>
How long to keep retrying before giving up and returning an error code</Description>
<Type>%Numeric</Type>
<InitialExpression>-1</InitialExpression>
</Property>

<Parameter name="SETTINGS">
<Description>
Settings for this Business Process</Description>
<Type>%String</Type>
<Default>MPIOperations,DefaultMPIUpdateMode,-PushRepMgr,DoPush,SubscriptionHandler,LogReportingEvent</Default>
</Parameter>

<Property name="Transformer">
<Description>
XSLT Transformer instance</Description>
<Type>HS.Util.XSLTTransformer</Type>
<Private>1</Private>
</Property>

<Property name="Transformer3">
<Description>
XSLT Transformer instance - separate on for SDA3</Description>
<Type>HS.Util.XSLTTransformer</Type>
<Private>1</Private>
</Property>

<Property name="DefaultMPIUpdateMode">
<Description><![CDATA[
Flag to control when the MPI should be updated.  Values are:
<br/>   - Always: Always update the MPI regardless
<br/>   - IfNeeded: Only update the MPI if a change was detected
<br/>   - IfInsert: Only update the MPI if an insert was detected (or Merge or Delete)
<br/>   - NOTNEEDED: This can send an AddUpdateHub request to the registry, but the DoMPI
   		property will always be set to false.  Used when something else (ex: XDS Notify & Query)
    	is updating the patient registry (and MPI).  This is not used as a setting, but is
			only set programmatically internally
<br/>   - Never: Never update the Registry (Only use if HealthShare is not maintaining a Hub, a Registry and any MPI)
		This will not send an AddUpdateHub request  This is not available as a setting, but can only
			be set programatically in very unusual cases.
<br/>   - ADTOnly: Only update the MPI when processing an ADT message (or if Insert)
<br/> This flag may be overridden by the request's MPIUpdateFlag]]></Description>
<Type>%String</Type>
<InitialExpression>"IfNeeded"</InitialExpression>
<Required>1</Required>
<Parameter name="DISPLAYLIST" value=",Always,If Needed,If Insert,ADT Only"/>
<Parameter name="VALUELIST" value=",Always,IfNeeded,IfInsert,ADTOnly"/>
</Property>

<Property name="LogReportingEvent">
<Description>
If checked, an AddUpdateHubRequest will always be sent to the Hub unless
the MPI update flag (either from the request passed in or, if that is null,
the DefaultMPIUpdateMode setting) is "Never". On the Hub, a log of the
event type that initiated this transaction will be created that can be
used for reporting purposes. </Description>
<Type>%Boolean</Type>
<InitialExpression>1</InitialExpression>
</Property>

<Parameter name="SDA2PATIENTINFOXSLT">
<Type>%String</Type>
<Default>SDA3/MPI/SDA-to-PatientInfo.xsl</Default>
</Parameter>

<Parameter name="SDA2PATIENTINFOTAG">
<Type>%String</Type>
<Default>PatientInfo</Default>
</Parameter>

<Parameter name="SDA2MERGEXSLT">
<Type>%String</Type>
<Default>SDA3/MPI/SDA-to-Merge.xsl</Default>
</Parameter>

<Parameter name="SDA2MERGETAG">
<Type>%String</Type>
<Default>PatientInfo</Default>
</Parameter>

<Parameter name="SDA2ADDUPDATEHUB">
<Type>%String</Type>
<Default>SDA3/MPI/SDA-to-AddUpdateHub.xsl</Default>
</Parameter>

<Parameter name="SDA2ADDUPDATEHUBTAG">
<Type>%String</Type>
<Default>AddUpdateHubRequest</Default>
</Parameter>

<XData name="MessageMap">
<Data><![CDATA[
<MapItems>
	<!--MapItem MessageType="HS.Message.ECRUpdateRequest"> 
		<Method>UpdateMPI</Method>
	</MapItem-->
	<MapItem MessageType="HS.Message.MPIUpdateManagerRequest"> 
		<Method>UpdateMPI3</Method>
	</MapItem>
</MapItems>
]]></Data>
</XData>

<Method name="UpdateMPI3">
<Description>
Update based on SDA3 and Streamlets</Description>
<FormalSpec><![CDATA[pRequest:HS.Message.MPIUpdateManagerRequest,&pResponse:HS.Message.ECRUpdateResponse]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Do {
		
		 //87
		 If ^stConfig("LogBool")  { 
		 		Set tMetric = ##class(Synthea.StressMetrics).%New()
		 		Set tMetric.Type = "MPIUpdate" 
		 		Set tMetric.ClassName = "Synthea.HS.Gateway.ECR.MPIUpdateManager1"
		 		Set tMetric.LineStart = 87
		 		Set tMetric.Start = $ZDATETIME($H,3,1,3)
		 		set tStart = $ZH
		 	}
		 
		 #dim tPat as HS.SDA3.Patient
		 #dim tNum as HS.SDA3.PatientNumber
		 #dim tRequest As HS.Message.AddUpdateHubRequest
		 #dim tRemRequest As HS.Message.RemovePatientRequest
		 #dim tMergeRequest As HS.Message.MergePatientRequest
		 #dim tPushRequest As HS.Message.Push.BatchProcessRequest
		 #dim tParams
		 If '$$$HSLicensed("Clinical Message Delivery") Set ..DoPush=0
		 Set tSC=$$$OK, $ZT="Trap"
		 Set tMPIUpdateFlag=$ZConvert($Case(pRequest.MPIUpdateFlag,"":..DefaultMPIUpdateMode,:pRequest.MPIUpdateFlag),"U")
 		 Set tQuickStream=##Class(HS.SDA3.QuickStream).%OpenId(pRequest.QuickStreamId)
		 If tMPIUpdateFlag="NEVER" {Do tQuickStream.Clear(1) Quit}
 		 Do tQuickStream.Rewind()
		 Set tReader=##class(%XML.Reader).%New()
		 Do tReader.OpenStream(tQuickStream)
		 Do tReader.Correlate("Patient","HS.SDA3.Patient")
		 Set tPat=""
		 Do tReader.Next(.tPat,.tSC) Quit:$$$ISERR(tSC)
		 If tPat="" {Set tSC=$$$ERROR($$$GeneralError,"No Patient found.") Quit}
		 Set tFacility=pRequest.SendingFacility
		 Set tMRN=""
		 For tI = 1:1:tPat.PatientNumbers.Count() {
			 Set tNum=tPat.PatientNumbers.GetAt(tI)
			 IF tNum.NumberType="MRN" {
				 Set tMRN=tFacility_"^"_tNum.Organization.Code_"^"_tNum.Number QUIT}
		 }
		 Quit:tMRN="" //no MRN
		 
		 Do tQuickStream.Rewind()
		 //2012.1 - DeletePatient is now handled via an AddUpdateHubRequest
		 Set tDoDelete=0
		 Set:(pRequest.Action="DeletePatient")||(tPat.ActionCode="D") tDoDelete=1
		 
		 //If a Merge, send a MergePatientRequest
		 // Do not do this for A50 (change Vis#) as this causes a new record (with less data) to be created
		 If pRequest.Action="Merge"&&(pRequest.EventDescription'="ADT_A50") {
			 //Get the non-surviving MRN
			 Set tOldMRN=""
			 For tI = 1:1:tPat.PriorPatientNumbers.Count() {
				 Set tNum=tPat.PriorPatientNumbers.GetAt(tI)
				 IF tNum.NumberType="MRN" {
					 Set tOldMRN=tFacility_"^"_tNum.Organization.Code_"^"_tNum.Number Quit
			 }}
	 		 //Create request message
	 		 Set tSC=..Transformer3.TransformIntoObject(tQuickStream, ..#SDA2MERGEXSLT, .tMergeRequest, "" , "HS.Message.MergePatientRequest", ..#SDA2MERGETAG,,##class(%Stream.GlobalBinary).%New())
	 		 Quit:$$$ISERR(tSC)
	 		 Set tSC=..OnMerge(tMergeRequest,pRequest.QuickStreamId) Quit:$$$ISERR(tSC)
	 		 $$$HSTRACE("SendingMerge","tOldMRN,tMRN,tMergeRequest",tOldMRN,tMRN,tMergeRequest)
	 		 Kill ^HS.InfoTypesSendCache(tOldMRN)
	 		 Kill ^HS.MPIUpdateHash(tOldMRN)
	 		 
	 		 If ^stConfig("LogBool")  { 
				Set tMetric2 = ##class(Synthea.StressMetrics).%New()
				Set tMetric2.Type = "MergeRequest"
				Set tMetric2.ClassName = $THIS
				Set tMetric2.LineStart = 152
				Set tMetric2.Start = $ZDATETIME($H,3,1,3)
				set tStartZH2 = $ZH
			}

	 		 Set tSC = ..SendRequestSync(..MPIOperations,tMergeRequest,.tResponse)
	 		 
	 		 
	 		 If ^stConfig("LogBool") { 
				set tMetric2.Elapsed = tStartZH2-$ZH
				Set tMetric2.End = $ZDATETIME($H,3,1,3)
				Set tMetric2.LineEnd = 163 
				Set ltSC = tMetric2.Save()
				Quit:$$$ISERR(ltSC)
			}
	 		 
	 		 Quit:$$$ISERR(tSC) //Note - current hub production doesn't send these errors
	 		 //We'll also update with the current patient info
		 }

		 //Create MPI addupdate request message
		 Do tQuickStream.Rewind()
		 Kill tParams
		 Set tParams("legacyPatientIdentifiers")=##class(HS.Registry.Config).GetKeyValue("\General\LegacyPatientIdentifierTypeRestriction",0)
		 Set tSC=..Transformer3.TransformIntoObject(tQuickStream, ..#SDA2ADDUPDATEHUB, .tRequest, .tParams, "HS.Message.AddUpdateHubRequest", ..#SDA2ADDUPDATEHUBTAG,,##class(%Stream.GlobalBinary).%New())
		 Kill tParams
		 Quit:$$$ISERR(tSC)
		 $$$HSTRACE("Transformed SDA into AddUpdateHub","tSC,SDA,AddUpdateHub",tSC,tQuickStream,tRequest)
		 Set tRequest.GatewayName=##Class(HS.Util.Installer.ConfigItem).GetThisComponentName()
		 
		 //build hash of MPI update message
	 	 Set tSC = tPat.XMLExportToString(.tString) Quit:$$$ISERR(tSC)
		 // Compute the MD5 hash on this string
		 Set tHash = $system.Encryption.MD5Hash(tString)
		 Set tHash = $system.Encryption.Base64Encode(tHash)  // Make it base64

		 //Check if should bother with an add/updating
		 DO {
			 If tDoDelete {Set tNeedMPIUpdate=0 Quit}
			 IF tMPIUpdateFlag="NOTNEEDED" {Set tNeedMPIUpdate=0 Quit}
			 IF tMPIUpdateFlag="ALWAYS" {Set tNeedMPIUpdate=1 Quit}
			 //If hash isn't defined, we think it's an insert, so we must sent it
			 IF '$D(^HS.MPIUpdateHash(tMRN),tStoredHash) {Set tNeedMPIUpdate=1 Quit}
			 IF tMPIUpdateFlag="IFINSERT" {Set tNeedMPIUpdate=0 Quit}
			 IF tMPIUpdateFlag="ADTONLY" {Set tNeedMPIUpdate=$E(pRequest.EventDescription,1,3)="ADT" Quit}
			 IF tMPIUpdateFlag="IFNEEDED" {Set tNeedMPIUpdate=(tStoredHash'=tHash) Quit}
			 Set tSC=$$$HSError($$$HSErrInvalidMPIAction,tMPIUpdateFlag)		 
		 } While 0
		 Quit:$$$ISERR(tSC)
		 
		 Set tNeedTypesUpdate=pRequest.UpdatePriorInfoTypes'=""
		 If 'tNeedTypesUpdate Set tNeedTypesUpdate=$G(^HS.InfoTypesSendCache(tMRN))'=pRequest.InfoTypes
		 // If we need demographics update or infotypes update or we are using Push, or log reporting event, send it
		 // But, if we're doing a query cache update, don't do push or log a reporting event
		 Set tDoFlash=0
		 &SQL(SELECT Name INTO :tFlashGW FROM HS_Gateway.Config WHERE Type='F' AND Status!='D')
		 Set:SQLCODE=0 tDoFlash=1
		 IF tNeedMPIUpdate||tNeedTypesUpdate||(pRequest.AAUpdateQ.Count()>0)||('pRequest.QueryCacheUpdate&(..DoPush||..LogReportingEvent))||tDoDelete||tDoFlash {
			 
			 Set tRequest.DoMPIUpdate=tNeedMPIUpdate
			 Set tRequest.DoPush=('pRequest.QueryCacheUpdate&..DoPush)
			 Set tRequest.DoFlash=tDoFlash
			 Set tRequest.DoDelete=tDoDelete
			 Set tRequest.LogReportingEvent = ('pRequest.QueryCacheUpdate&..LogReportingEvent)
			 // if we are sending at all, we need the InfoTypes, since InfoTypes="" means 'delete'
			 Do tRequest.AdditionalInfo.SetAt(pRequest.InfoTypes,"InfoTypes")
			 // For move encounter we need to update the prior patient's infotypes
			 Do:pRequest.UpdatePriorInfoTypes'="" tRequest.AdditionalInfo.SetAt(pRequest.UpdatePriorInfoTypes,"UpdatePriorInfoTypes")
			 For tI=1:1:$L(pRequest.MessageInfoTypes,",") {Set tInfo=$P(pRequest.MessageInfoTypes,",",tI) Do:tInfo'="" tRequest.InfoTypes.Insert(tInfo)}
			 Set:'tDoDelete tRequest.AAUpdateQ=pRequest.AAUpdateQ //for analytics feed
			 Set:'tDoDelete tRequest.FeedAnalytics=##class(Ens.Director).GetCurrProductionSettingValue("FeedAnalytics")
			 
			 
			 //OnAddUpdateHub
			 Set tSC=..OnAddUpdateHub(.tRequest,pRequest.QuickStreamId) Quit:$$$ISERR(tSC)
			 Set tResponse=##Class(HS.Message.AddUpdateHubResponse).%New()
			 // Send the actual MPI Update
			 
			 
			 
			 
			 //This is where it sends the udpate finally
			 //Hash 210
			 //AddUpdateHubRequest
			 If ^stConfig("LogBool")  { 
				Set tMetric2 = ##class(Synthea.StressMetrics).%New()
				Set tMetric2.Type = "AddUpdateHubRequest"
				Set tMetric2.ClassName = $THIS
				Set tMetric2.LineStart = 216
				Set tMetric2.Start = $ZDATETIME($H,3,1,3)
				set tStartZH2 = $ZH
		     }

			 $$$HSTRACE("Sending Add/Update to MPI Operations","tNeedMPIUpdate,tNeedTypesUpdate,tRequest",tNeedMPIUpdate,tNeedTypesUpdate,tRequest)
			 Set tSC = ..SendRequestSync(..MPIOperations,tRequest,.tResponse)
			 Quit:$$$ISERR(tSC)
			   
			 If ^stConfig("LogBool") { 
			 	//Putting Negative Value Since Detracts from Time on Edge
    			set tMetric2.Elapsed = tStartZH2-$ZH
				Set tMetric2.End = $ZDATETIME($H,3,1,3)
				Set tMetric2.LineEnd = 228
				Set ltSC = tMetric2.Save()
				Quit:$$$ISERR(ltSC)
			}
			 
			 
			 Set tSC=tResponse.ErrStatus Quit:$$$ISERR(tSC)
			 // Success
			 //Should I track?
			 If tDoDelete {
				 Kill ^HS.InfoTypesSendCache(tMRN)
				 Kill ^HS.MPIUpdateHash(tMRN)
			 } Else {
				 Set ^HS.MPIUpdateHash(tMRN)=tHash
				 Set ^HS.InfoTypesSendCache(tMRN)=pRequest.InfoTypes
			 }
			 
			 // Push:
			 If tResponse.Subscriptions.Count()>0 {
				 Set tPushRequest=##Class(HS.Message.Push.BatchProcessRequest).%New()
				 Set tPushRequest.Subscriptions=tResponse.Subscriptions
				 Set tPushRequest.MPIID=tResponse.MPIID
				 Set tPushRequest.HSAAID=tResponse.HSAAID
				 Set tPushRequest.QuickStreamId=pRequest.QuickStreamId
				 Set tPushRequest.OriginalMessageId=pRequest.OriginalMessageId
				 Set tPushRequest.AssigningAuthority=tRequest.AssigningAuthority
				 Set tPushRequest.EventType=tRequest.EventType
				 Set tPushRequest.Facility=tRequest.Facility
				 Set tPushRequest.FirstName=tRequest.FirstName
				 Set tPushRequest.LastName=tRequest.LastName
				 Set tPushRequest.InfoTypes=tRequest.InfoTypes
				 Set tPushRequest.MRN=tRequest.MRN
				 Set tPushRequest.StreamContentType="SDA3"
				 Set tPushRequest.AAQueueUpdated = (tRequest.AAUpdateQ.Count()>0)
				 Set tSC = ..SendRequestAsync(..SubscriptionHandler,tPushRequest)
			 } Else {
				 Do tQuickStream.Clear(1) //clean CacheTemp
			 }
			 
			 
		 }
		 Else {Do tQuickStream.Clear(1)} //clean CacheTemp when the outer IF is false
		 
		 If ^stConfig("LogBool") { 
		    	set tMetric.Elapsed = $ZH - tStart
				Set tMetric.End = $ZDATETIME($H,3,1,3)
				Set tMetric.LineEnd = 258 
				Set ltSC = tMetric.Save()
				Quit:$$$ISERR(ltSC)
			 }
			 
			 
	} While (0)
Exit
	Quit tSC
Trap
	Set $ZT="",tSC=$$$EnsSystemError
	Goto Exit
]]></Implementation>
</Method>

<Method name="OnInit">
<Description>
This user callback method is called just after %OnNew()</Description>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	$$$GetTransformer(..Transformer)
	$$$GetTransformer(..Transformer3)
	Quit 1
]]></Implementation>
</Method>

<Method name="OnTearDown">
<Description>
This user callback method is called just before %OnClose()</Description>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[	Quit 1
]]></Implementation>
</Method>

<Method name="OnAddUpdateHub">
<Description>
Can override this to perform additional processing based on the AddUpdateHubRequest
This can modify the AddUpdateHubRequest - for instance, adding AdditionalInfo
The quickstream ID is passed in case this wants to peek into the full SDA</Description>
<FormalSpec><![CDATA[&pRequest:HS.Message.AddUpdateHubRequest,pQuickStreamId:%String]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[	Quit $$$OK
]]></Implementation>
</Method>

<Method name="OnRemovePatient">
<Description>
***As of 2012.1, this callback is no longer supported.  Removing a patient is now done using an AddUpdateHubRequest***</Description>
<FormalSpec><![CDATA[&pRequest:HS.Message.RemovePatientRequest,pQuickStreamId:%String]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[	Quit $$$ERROR($$$NotImplemented)
]]></Implementation>
</Method>

<Method name="OnMerge">
<Description>
Can override to perform additional processing for an MRN-type merge</Description>
<FormalSpec><![CDATA[&pRequest:HS.Message.MergePatientRequest,pQuickStreamId:%String]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[	Quit $$$OK
]]></Implementation>
</Method>

<Method name="OnMoveVisit">
<Description><![CDATA[
Can override to perform additional processing on a move visit request.
Here, the AddUpdateHubRequest is only being used to tweak the stored infotype list for the prior patient.
the old & new MRN are of format facility^assigningauthority^number
If you need access to the visit #, you'll need to dig that out of the SDA quickstream - you can
use HS.Util.XPathHelper method EvaluateExpression]]></Description>
<FormalSpec><![CDATA[&pRequest:HS.Message.AddUpdateHubRequest,pOldMRN:%String,pNewMRN:%String,pQuickStreamId:%String]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Quit 0  //***callback to this not implemented
	Quit $$$OK
]]></Implementation>
</Method>
</Class>


<Class name="Synthea.HS.Gateway.ECR.Manager1">
<Description><![CDATA[
The default ECR Manager component.<br> 
Receives messages from all inbound processes and updates the ECR correspondingly.<br>
Also receives and manages requests from the Edge Gateway Web service to fetch records. ]]></Description>
<IncludeCode>HS.Common,%ZHSLIB</IncludeCode>
<ProcedureBlock>1</ProcedureBlock>
<Super>HS.Util.Trace.Helper,Ens.BusinessOperation,HS.Util.Trace.Performance</Super>
<TimeChanged>65231,51574.118178</TimeChanged>
<TimeCreated>65190,59860.115783</TimeCreated>
<Inheritance>right</Inheritance>

<Parameter name="INVOCATION">
<Default>Queue</Default>
</Parameter>

<Parameter name="DOMAIN">
<Default>HS</Default>
</Parameter>

<Property name="MPIOperations">
<Description>
Name of the business host that performs communications with the hub Web service, via SOAP messages.</Description>
<Type>%String</Type>
</Property>

<Property name="MPIUpdateManager">
<Description>
Name of the business host that receives update requests from the ECR manager, determines how to handle them, 
and then communicates with the Hub remote operations as needed.</Description>
<Type>Ens.DataType.ConfigName</Type>
<InitialExpression>"MPIUpdateManager"</InitialExpression>
</Property>

<Property name="UpdatePostProcessor">
<Description>
Name of a custom business host that defines a step for the ECR Manager to perform after it saves data to the ECR. Typical use: public health reporting.</Description>
<Type>Ens.DataType.ConfigName</Type>
</Property>

<Property name="FetchPreProcessor">
<Description>
Name of a custom business host that defines a step for the ECR Manager to perform just before it fetches data from the ECR.</Description>
<Type>Ens.DataType.ConfigName</Type>
</Property>

<Property name="ConsentProcessor">
<Description>
Name of the business host that applies consent filtering.</Description>
<Type>Ens.DataType.ConfigName</Type>
</Property>

<Property name="Transformer3">
<Description>
XSLT Transformer instance - separate on for SDA3</Description>
<Type>HS.Util.XSLTTransformer</Type>
<Private>1</Private>
</Property>

<Property name="CacheType">
<Description>
copied in from the production setting on startup</Description>
<Type>%String</Type>
</Property>

<Property name="InboundCodeSystemProfile">
<Type>%String</Type>
</Property>

<Property name="InactiveMRNHandlingMode">
<Description><![CDATA[
How inactive (non-surviving from a merge) MRNs should be handled when an update for one is received.<BR>
- Always Error: HealthShare will always log to the Event Log an error when a message with an inactive MRN 
  is passed in and will not process the message.<BR>
- MRN Reuse: An update to a non-surviving MRN from a merge is treated as a new patient reusing that MRN.<BR>
- Late Update: An update to a non-surviving MRN from a merge is treated as an update to the surviving MRN of that merge.
  Note that the surviving MRN is what will be used in the MPI update, if one takes place.<BR><BR>
Be sure to consult with your MPI vendor to confirm their handling of non-surviving MRNs before changing this setting.]]></Description>
<Type>%String</Type>
<InitialExpression>"ALWAYSERROR"</InitialExpression>
<Required>1</Required>
<Parameter name="DISPLAYLIST" value=",Always Error,MRN Reuse,Late Update"/>
<Parameter name="VALUELIST" value=",ALWAYSERROR,MRNREUSE,LATEUPDATE"/>
</Property>

<Property name="AlertOnLateUpdate">
<Description>
If this is set to "TRUE" and the InactiveMRNHandlingMode setting is set to "Late Update", then whenever a
late update is applied to an MRN, an alert will be generated in the Event Log with details of the update.</Description>
<Type>%Boolean</Type>
<InitialExpression>1</InitialExpression>
</Property>

<Property name="FeedAnalytics">
<Description>
If this is "TRUE", then the system will send information about all updates to the hub, to be queued up for feeding
into HealthShare Analytics</Description>
<Type>%Boolean</Type>
<InitialExpression>0</InitialExpression>
</Property>

<Property name="QueryOperation">
<Description>
For gateways where the cache type is PureQuery, NotifyAndQuery, or ExpireAndQuery, enter the name of the
operation that will perform the query</Description>
<Type>Ens.DataType.ConfigName</Type>
</Property>

<Property name="CacheExpirationTimeout">
<Description>
For gateways where the cache type is ExpireAndQuery, enter the number of hours before the
results from a cached query expire (i.e. are considered out of date)</Description>
<Type>%Integer</Type>
</Property>

<Property name="ScheduleQueryRefresh">
<Description>
This applies to gateways where the cache type is ExpireAndQuery.  If true, then if a record is
actively being requested, it will be queued up to be refreshed when it expires.</Description>
<Type>%Boolean</Type>
</Property>

<Parameter name="MPIUPDATEFULLXSLT">
<Type>%String</Type>
<Default>SDA3/SDA-to-MPIUpdateFull.xsl</Default>
</Parameter>

<Property name="SDA2ToSDA3Transform">
<Type>%String</Type>
<InitialExpression>"SDA3/SDA2-to-SDA3.xsl"</InitialExpression>
</Property>

<Property name="SDA3StripContainerTransform">
<Type>%String</Type>
<InitialExpression>"SDA3/StripContainer.xsl"</InitialExpression>
</Property>

<Parameter name="SETTINGS">
<Description>
Settings for this Business Process</Description>
<Type>%String</Type>
<Default>-MPIOperations,MPIUpdateManager,FetchPreProcessor,UpdatePostProcessor,-ConsentProcessor,InboundCodeSystemProfile,InactiveMRNHandlingMode,AlertOnLateUpdate, QueryOperation, CacheExpirationTimeout, ScheduleQueryRefresh, SDA2ToSDA3Transform, SDA3StripContainerTransform</Default>
</Parameter>

<XData name="MessageMap">
<Data><![CDATA[
<MapItems>
	<MapItem MessageType="HS.Message.ECRUpdateRequest"> 
		<Method>UpdateStreamletECR</Method>
	</MapItem>
	<MapItem MessageType="HS.Message.ECRFetchRequest"> 
		<Method>FetchSDA3FromECR</Method>
	</MapItem>
	<MapItem MessageType="HS.Message.StreamletRequest"> 
		<Method>StreamletRequest</Method>
	</MapItem>
	<MapItem MessageType="HS.Message.ECRQueryRequest">
		<Method>ECRQueryCacheUpdate</Method>
	</MapItem>
	<MapItem MessageType="HS.Message.PrefetchRequest">
		<Method>PrefetchRequest</Method>
	</MapItem>
</MapItems>
]]></Data>
</XData>

<Method name="UpdateStreamletECR">
<FormalSpec><![CDATA[pRequest:HS.Message.ECRUpdateRequest,&pResponse:HS.Message.ECRUpdateResponse]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	#dim tSC As %Status
	#dim tPatient As HS.SDA3.Patient
	Set tSC=$$$OK,$ZT="Trap",  tStreamC=""
	$$$HSTRACE("Updating Streamlet","pRequest",pRequest)
	$$$HSPerfStart("UpdateStreamletECR")
	Kill %HSTranslate //no translation when updating streamlets
	Do {
		
		If ^stConfig("LogBool")  { 
			Set tMetric = ##class(Synthea.StressMetrics).%New()
			Set tMetric.Type = "UpdateECRStreamlet"
			Set tMetric.ClassName = "Synthea.HS.Gateway.ECR.Manager1"
			Set tMetric.LineStart = 108
			Set tMetric.Start = $ZDATETIME($H,3,1,3)
			set tStart = $ZH
		}
		
		Set tSC = pRequest.NewResponse(.pResponse)
		Quit:$$$ISERR(tSC)
		If ..CacheType'="ConsumeAndForward",'$$$HSLicensed("Composite Health Record") Set tSC=$$Error^%apiOBJ(6083,$ZE) Quit
		IF pRequest.Content'="" {
			//move to contentstream
			Do pRequest.ContentStream.Rewind()
			Do pRequest.ContentStream.Write(pRequest.Content)
			Set pRequest.Content=""
		}
		//If not SDA3 content type, transform it!
		IF pRequest.StreamContentType'="SDA3" {
			//Didnt we do Hl7 to SDA???
			//This log shouldnt fire..
			
			Set tStreamC=##class(HS.SDA3.QuickStream).%New()
			Set tSC=..Transformer3.Transform(pRequest.ContentStream, ..SDA2ToSDA3Transform /*"SDA3/SDA2-to-SDA3.xsl"*/,.tStreamC)
			Quit:$$$ISERR(tSC)
			Set pRequest.StreamContentType="SDA3",pRequest.ContentStream=tStreamC
		}
		// We will record all streamlet changes in %HSAnalyticsQ, used to identify what we
		// will need to send to the flash gateway and to Health Insight
		Kill %HSAnalyticsQ
		Set %HSAnalyticsQ=1
		Kill:'pRequest.SkipReplaceInitialize ^||HS.SDA3.Streamlet.Patient.Replace
		If pRequest.UpdateTXN {
			Set tUpdateTXN=pRequest.UpdateTXN
		} Else {
			//get the next transaction counter
			Set tUpdateTXN=$I(^HS.SDAStreamletTXN)
		}
		Do pRequest.ContentStream.Rewind()
		Set tContainer=##class(HS.SDA3.Container).%New()
		Set tSC=tContainer.InitializeXMLParse(pRequest.ContentStream,"SDA3") Quit:$$$ISERR(tSC)
		$$$HSTRACESTARTCALL
		Set tGot=tContainer.GetNextSDA(.tType, .tPatient,.tSC)
		$$$HSTRACEENDCALL
		Quit:$$$ISERR(tSC) 
		If 'tGot Set tSC=$$$ERROR($$$GeneralError,"No Patient found.") Quit
		Set tPatInfo=$G(%SDAData)
		$$$HSTRACE("GotStreamletInfo","tPatInfo",tPatInfo)
		If tPatInfo="" Set tSC=$$$ERROR($$$GeneralError,"No Patient found.") Quit
		//tMRN=facility^AA^mredrecnum
		Set tMRN=$P(tPatInfo,"||"),tAction=$P(tPatInfo,"||",2),tEventDesc=$P(tPatInfo,"||",3)
		// Check for medrecnum in tMRN, if not present, fail the message.
		If $p(tMRN,"^",3)="" Set tSC=$$$ERROR($$$GeneralError,"No Patient MRN Found.") Quit
		//For Consume & forward, we're done here
		Kill tMessageInfoArray, tMessageInfos
		IF ..CacheType="ConsumeAndForward"||((..CacheType="PureQuery")&'pRequest.QueryCacheUpdate) {
			//Need to gather the message infotypes
			//ConsumeAndForward Log

			For {
				$$$HSTRACESTARTCALL
				Set tGot=tContainer.GetNextSDA(.tType, .tSDA,.tSC)
				$$$HSTRACEENDCALL
				IF $$$ISERR(tSC) {Do LogError Quit} //can't recover from bad tag
				Quit:'tGot
				Set tStrmClass=$$$StreamletClass(tType)
				Set tSDAClass=$ClassMethod(tStrmClass,"GetSDAClass")
				Set tInfo=$ClassMethod(tStrmClass,"GetInfoType")
				If tInfo="MED"||(tInfo="LAB")||(tInfo="RAD")||(tInfo="OTH")||(tInfo="VXU") {
					If tSDA.OrderCategory'="" {Set tSub=tSDA.OrderCategory.Code Set:tSub'="" tInfo=tInfo_"."_$ZCVT(tSub,"U")}
				}
				If tInfo="DOC",tSDA.DocumentType'="" {Set tSub= $ZCVT(tSDA.DocumentType.Code,"U") Set:tSub'="" tInfo=tInfo_"."_tSub}
				Set tMessageInfoArray(tInfo)=""
				
			}
			Set tMessageInfos="", tI=""
			For {Set tI=$O(tMessageInfoArray(tI)) Quit:tI=""  Set tMessageInfos=tMessageInfos_$S(tMessageInfos="":"",1:",")_tI}
			Set tSC=..ForwardSDA3(tPatInfo,pRequest,,,tMessageInfos) 
			
			Quit
		}
		
		//tAction: AddOrUpdate,Merge,Move,DeletePatient,DeleteEncounter,CancelAdmit,CancelDischarge
		//tEventDesc: HL7 message type
		Set tPatAction=$S(tAction="DeletePatient":"Delete",tEventDesc="ADT_A47":"ChangeNum",tEventDesc="ADT_A50":"",tAction="Merge":"Merge",1:"")
		Set tEncAction=$S(tAction="DeleteEncounter":"Delete",tEventDesc="ADT_A50":"ChangeNum",tEventDesc="ADT_A45":"Move",tEventDesc="ADT_A13":"CD",1:"")
		
		//Process the patient streamlet
		
		Set tStreamletClass = $parameter("HS.Local.SDA3.PatientExtension", "STREAMLETCLASS")
		Set tPatStreamlet=$classmethod(tStreamletClass, "%New")
		Set tStreamlet=tPatStreamlet
		$$$HSTRACE("Got Patient","tPatient",tPatient)
		Set tPatAction=$S(tPatient.ActionCode="R":"Replace",tPatient.ActionCode="D":"Delete",1:tPatAction)
		Set tPriorMRN=""
		For tI=1:1:tPatient.PriorPatientNumbers.Count() {
			Set tNum=tPatient.PriorPatientNumbers.GetAt(tI)
			If tNum.NumberType'="MRN" Continue
			Set tPriorMRN=$P(tMRN,"^")_"^"_tNum.Organization.Code_"^"_tNum.Number
			Quit
		}
		Do tPatient.PriorPatientNumbers.Clear()
		Set tPatStreamlet.SDA=tPatient
		Set tAggregationKey=pRequest.TempAggregationKey // only set to non null for pure query
		Set tSC=tPatStreamlet.PatientActions(tPatAction,tPriorMRN,.tMRN,tUpdateTXN,..InactiveMRNHandlingMode,..AlertOnLateUpdate,.tAggregationKey,pRequest.UpdateECRDemographics,.tLateUpdate) Quit:$$$ISERR(tSC)
		//Output the extension to XML
		Set tWriter = ##class(%XML.Writer).%New()
		
		//Next, process everything else
		If tPatAction'="Delete" {
			
			For {
				$$$HSTRACESTARTCALL
				Set tGot=tContainer.GetNextSDA(.tType, .tSDA,.tSC)
				$$$HSTRACEENDCALL
				IF $$$ISERR(tSC) {Do LogError Quit} //can't recover from bad tag
				Quit:'tGot
				Set tStrmClass=$$$StreamletClass(tType)
				Set tSDAClass=$ClassMethod(tStrmClass,"GetSDAClass")
				Set tStreamlet=$ClassMethod(tStrmClass,"%New")
				$$$HSTRACE("Got Streamlet","tType,tSDA",tType,tSDA)
				Set tStreamlet.SDA=tSDA, tStreamlet.EncounterNumber=$system.Util.Collation(tSDA.EncounterNumber,6)
				Set tStreamlet.AggregationKey=tAggregationKey
				If tType="Encounter" {
					Set tSC=tStreamlet.EncounterActions(tEncAction,tMRN,tPriorMRN,tUpdateTXN,pRequest.UpdateECRDemographics)
					If $$$ISERR(tSC) { 
						// An error for ChangeNum or Move is fatal
						If (tEncAction="ChangeNum")||(tEncAction="Move") { Quit }
						Do LogStatus
					}
					Set:$$$ISOK(tSC) tMessageInfoArray("ENC")=""	
					CONTINUE
				}
				IF tSDA.ActionCode="C"||(tSDA.ActionCode="I") {
					Set tSC=tStreamlet.InactiveClear(tUpdateTXN) Do:$$$ISERR(tSC) LogStatus
					Continue  //this streamlet is just an instruction to inactivate or delete other streamlets
				}
				Set tSC=tStreamlet.OnBeforeMatch() IF $$$ISERR(tSC) {Do LogStatus Continue}
				Set tSC=tStreamlet.ComputeMatches() IF $$$ISERR(tSC) {Do LogStatus Continue}
				Set tSC=tStreamlet.Match(tAggregationKey,tUpdateTXN,.tMatch) IF $$$ISERR(tSC) {Do LogStatus Continue}
				Set:tStreamlet.SDA.ActionCode="D" tStreamlet.Deleted=tUpdateTXN
				If tMatch {
					Set tSC=tStreamlet.UpdateSDA(tMatch,.tInfo)
					If $$$ISOK(tSC),tInfo'="" Set tMessageInfoArray(tInfo)=""
				} Else {
					If tStreamlet.Deleted Continue //if we are getting in a new one, but it's a delete, we can ignore it
					Set tSC=tStreamlet.SaveStreamlet()
					If $$$ISOK(tSC) {Set tInfo=tStreamlet.InfoType Set:tStreamlet.InfoSubType'="" tInfo=tInfo_"."_tStreamlet.InfoSubType Set tMessageInfoArray(tInfo)=""}
				}
				Do:$$$ISERR(tSC) LogStatus
			}
			// An error here must be fatal, since a non-fatal error would have been logged and reset.
			If ($$$ISERR(tSC)) { Quit }
			If 'pRequest.SkipReplaceUpdate {
				//do Replace cleanup
				//We skip replace cleanup if this is from ECRQueryCacheUpdate with a series of
				//updates, and we're not at the last one.
				For {
					Set tID=$O(^||HS.SDA3.Streamlet.Patient.Replace(""),1,tVal) Quit:tID=""
					Set tType=$P(tVal,"^"),tHasEnc=$P(tVal,"^",2),tIsDeleted=1
					If tType="ObservationGroup" {
						Set tSC=##class(HS.SDA3.Streamlet.ObservationGroup).DeferredDelete(tID,tUpdateTXN,.tIsDeleted)
						Quit:$$$ISERR(tSC)
					} Else {
						&SQL(Update HS_SDA3_Streamlet.Abstract SET Deleted=:tUpdateTXN WHERE ID=:tID)
					}
					Kill ^||HS.SDA3.Streamlet.Patient.Replace(tID)
					If $D(%HSAnalyticsQ) {
						Do:tIsDeleted ##class(HS.SDA3.Streamlet.Abstract).AAQueueIUD("D",tID,tType,tHasEnc)
					}
				}
				Quit:$$$ISERR(tSC)
			}
			
		}
		Set tSC=..GetInfoList(tAggregationKey,.tInfos),tPriorInfos="" Quit:$$$ISERR(tSC)
		IF tEncAction="Move" {
			Set tPriorAgKey=$G(^HS.SDAStreamletMRN("MRN",tPriorMRN))
			If tPriorAgKey Set tSC=..GetInfoList(tPriorAgKey,.tPriorInfos) Quit:$$$ISERR(tSC)
			Set tPriorInfos=tPriorMRN_"^"_tPriorInfos
		}
		Set tMessageInfos="", tI=""
		For {Set tI=$O(tMessageInfoArray(tI)) Quit:tI=""  Set tMessageInfos=tMessageInfos_$S(tMessageInfos="":"",1:",")_tI}
		Kill tParams
		If tLateUpdate'="" {
			Set tParams("OldMRN")="'"_$P(tLateUpdate,"^")_"'",tParams("NewMRN")="'"_$P(tLateUpdate,"^",2)_"'"
		}
		If ..CacheType="PureQuery",pRequest.QueryCacheUpdate Quit
		If ..CacheType="NotifyAndQuery",'pRequest.QueryCacheUpdate {
			
			Set $LI(^HS.ECRQueryQ("MRN",tMRN))=1 //flag as expired
			Lock +^HS.ECRQueryQ("lock","MRN",tMRN,"Notifications")
			If pRequest.Notification'="" Set tI=$I(^HS.ECRQueryQ("MRN",tMRN,"Notifications",0)),^(tI)=pRequest.Notification
			Lock -^HS.ECRQueryQ("lock","MRN",tMRN,"Notifications")
			//Create a special prefetch request, to be used only when feeding analytics.
			//The prefetch request will be processed by the ECR Query task, in order to populate ^HS.AADBQ
			Set tPreRequest=##Class(HS.Message.PrefetchRequest).%New()
			Set tPreRequest.Facility=$P(tMRN,"^")
			Set tPreRequest.AssigningAuthority=$P(tMRN,"^",2)
			Set tPreRequest.MRN=$P(tMRN,"^",3)
			Set tPreRequest.Priority=999999
			Set tSC=..PrefetchRequest(tPreRequest) 
			
			Quit:$$$ISERR(tSC)
		}
		
		//Goes to Forward SDA3 which sends the info
		
		//287 right from ForwardSDA3
		Set tSC=..ForwardSDA3(tPatInfo,pRequest,tInfos,tPriorInfos,tMessageInfos,.tParams)
		If $IsObject(tStreamC) Do tStreamC.Clear(1) //clean up quickstream
		
		If ^stConfig("LogBool") { 
 			  	set tMetric.Elapsed = $ZH - tStart
				Set tMetric.End = $ZDATETIME($H,3,1,3)
				Set tMetric.LineEnd = 380
				Set ltSC = tMetric.Save()
				Quit:$$$ISERR(ltSC)
		}
		
	} While (0)
Exit
	$$$HSPerfEnd
	Quit tSC
Trap
	Set $ZT="",tSC=$$$EnsSystemError
	Goto Exit
	
LogStatus
	$$$LOGALERT($system.Status.GetErrorText(tSC))
	Set tSC=$$$OK Quit  //to log & continue - for all non-patient streamlets

LogError
	//Used for failures in GetNextSDA, which will prevent further XML parsing and getting any more SDA,
	//but are not fatal for the whole transaction.
	$$$LOGERROR($system.Status.GetErrorText(tSC))
	Set tSC=$$$OK Quit  //to log & continue - for all non-patient streamlets
]]></Implementation>
</Method>

<Method name="GetInfoList">
<ClassMethod>1</ClassMethod>
<FormalSpec>pAggregationKey,*pList</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set pList="", tSC=$$$OK
	Set tStatement=##class(%SQL.Statement).%New()
	Set tSC=tStatement.%Prepare("Select Distinct InfoType,InfoSubType From HS_SDA3_Streamlet.Abstract WHERE AggregationKey=? AND Deleted=0") Quit:$$$ISERR(tSC) tSC
	Set tRS=tStatement.%Execute(pAggregationKey)
	While tRS.%Next() {
		Set tItem=tRS.%GetData(1) Set:tRS.%GetData(2)'="" tItem=tItem_"."_tRS.%GetData(2)
		Set:tItem'="" pList=pList_$S(pList="":"",1:",")_tItem
	}
	Quit tSC
]]></Implementation>
</Method>

<Method name="ForwardSDA3">
<Description>
Forward request to MPI Update Manager for updating the patient registry (and MPI), and for Push
Also forward to any post processor
pPatInfo is the info string (i.e. metadata) extracted from the original message by InitializeXMLParse</Description>
<FormalSpec>pPatInfo,pRequest:HS.Message.ECRUpdateRequest,pInfoTypes="",pUpdatePriorInfoTypes="",pMessageInfoTypes="",pParams=""</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	#dim tSC As %Status
	Set tSC=$$$OK,$ZT="Trap"
	Do {
		
		Set tMPISend=##Class(HS.Message.MPIUpdateManagerRequest).%New()
		//use a hybrid quickstream which keeps its data in a real, not temp, global
		Set tQuickStream=##Class(HS.SDA3.QuickStream).%New(,0)
		$$$HSTRACESTARTCALL
		Set tSC=..Transformer3.Transform(pRequest.ContentStream, ..#MPIUPDATEFULLXSLT,.tQuickStream,.pParams)
		$$$HSTRACEENDCALL
		Quit:$$$ISERR(tSC)
		Do tQuickStream.GSave()
		Set tMPISend.QuickStreamId=tQuickStream.%Id()
		Set tMPISend.MPIUpdateFlag=pRequest.MPIUpdateFlag
		Set tMPISend.OriginalMessageId=pRequest.OriginalMessageId //for push, to be used if needed
		Set tMPISend.QueryCacheUpdate=pRequest.QueryCacheUpdate
		Set tMPISend.InfoTypes=pInfoTypes, tMPISend.UpdatePriorInfoTypes=pUpdatePriorInfoTypes
		Set tMPISend.MessageInfoTypes=pMessageInfoTypes
		Set tMPISend.SendingFacility=$P($P(pPatInfo,"||"),"^")
		Set tMPISend.Action=$P(pPatInfo,"||",2)
		Set tMPISend.EventDescription=$P(pPatInfo,"||",3)
		Set tAAQ="" For {
			Set tAAQ=$O(%HSAnalyticsQ(tAAQ),1,tItems) Quit:tAAQ=""
			Do tMPISend.AAUpdateQ.SetAt(tItems,tAAQ)
		}

		//350
		//AddUpdateHubRequest
		Set tSC = ..SendRequestAsync(..MPIUpdateManager,tMPISend)
		Quit:$$$ISERR(tSC)
		
		//Updates Post Processor
		//I assume this ECRUpdateResponts
		
		If ..UpdatePostProcessor'="" {
			Set tSC = ..SendRequestAsync(..UpdatePostProcessor,pRequest)
		}
	} While 0
Exit
	Quit tSC
Trap
	Set $ZT="",tSC=$$$EnsSystemError
	Goto Exit
]]></Implementation>
</Method>

<Method name="FetchSDA3FromECR">
<Description>
Fetch SDA from the ECR</Description>
<FormalSpec><![CDATA[pRequest:HS.Message.PatientFetchRequestAsync,&pResponse:HS.Message.EPRFetchNotification]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	#dim tSC As %Status
	Set tSC=$$$OK,$ZT="Trap"
	Do {
		Set tQueueForDelete=0
		If ..FetchPreProcessor'="" {
			// Call the fetch pre-processor ...
			Set tSC = ..SendRequestSync(..FetchPreProcessor,pRequest,.pRequest)
			Quit:$$$ISERR(tSC)
		}
		Set pResponse=##class(HS.Message.EPRFetchNotification).%New()
		If '$$$HSLicensed("Composite Health Record") Set tSC=$$Error^%apiOBJ(6083,$ZE) Quit
		Set pResponse.InboundCodeSystemProfile=..InboundCodeSystemProfile
		Set pResponse.Token=pRequest.Token
		Set pResponse.Validated=1
		Set pResponse.StreamContentType="SDA3"
		Set tStreamC=##Class(HS.SDA3.QuickStream).%New()

 		Set tMRN=pRequest.Facility_"^"_pRequest.AssigningAuthority_"^"_pRequest.MRN
		Set tProfile=##class(HS.Registry.Config).GetKeyValue("\Terminology\EdgeTranslationProfile","")
		If ..CacheType="PureQuery" {
			Set tSequence=$I(^HS.FetchStatus), tAgKey="T"_tSequence
		} Else {
			//for expire & query, have to do this first, because might not yet have a streamletmrn
			If ..CacheType="ExpireAndQuery" {Do QueryIfNeeded Quit:$$$ISERR(tSC)  Quit:pResponse.Action=0}
	 		Set tAgKey=$G(^HS.SDAStreamletMRN("MRN",tMRN))
 			If tAgKey=""&&'(pRequest.%IsA("HS.Message.ECRFetchRequestFlash")) {Set tSC=$$$ERROR($$$GeneralError,$$$Text("Patient not found.")) Quit}
		}
		If ..CacheType="NotifyAndQuery"||(..CacheType="PureQuery") {Do QueryIfNeeded Quit:$$$ISERR(tSC)  Quit:pResponse.Action=0}


 		If pRequest.%IsA("HS.Message.ECRFetchRequestFlash") {
	 		$$$HSTRACESTARTCALL
	 		Set tSC=##class(HS.SDA3.Streamlet.ContainerMethods).AddUpdateFlash(tAgKey,pRequest)
	 		$$$HSTRACEENDCALL
	 		Quit
 		} Else {
			$$$HSPerfStart("MakeSDAStream")
	 		Set tSC=##Class(HS.SDA3.Streamlet.ContainerMethods).MakeSDAStream(tAgKey,.tStreamC,pRequest.Filters,pRequest.UseFilters,tProfile,0,pRequest.Consent,pRequest.EdgeSession,.tConsentApplied,pRequest) Quit:$$$ISERR(tSC)
 			&SQL(SELECT ID INTO :tID FROM HS_SDA3_Streamlet.Abstract WHERE AggregationKey=:tAgKey AND StreamletType='PATIENT' And Deleted=0)
			Set tPatString=$LG(^HS.SDA3.Streamlet.AbstractD(tID),7),tPat=##class(HS.SDA3.Patient).%New(),tSC=tPat.XMLImportSDAString(tPatString) Quit:$$$ISERR(tSC)
			$$$HSPerfEnd
			Set pResponse.ConsentApplied = tConsentApplied
		}


		Quit:$$$ISERR(tSC)


		Do tStreamC.GSave()
		Set pResponse.AuditName=$E(tPat.Name.FamilyName_", "_tPat.Name.GivenName_$S(tPat.Name.MiddleName="":"",1:", "_tPat.Name.MiddleName),1,220)
		Set pResponse.QuickStreamId=tStreamC.%Id()
		Do tStreamC.GSave()
		If ..CacheType="PureQuery" {
			Set tSC=##class(HS.SDA3.Streamlet.ContainerMethods).PurgeAggregationCache(tAgKey)
			Quit:$$$ISERR(tSC)
		}
		If ..CacheType="ExpireAndQuery",tQueueForDelete {
			//Query operation has determined that the patient no longer exists in the external facility
			//so we need to queue up a delete
			Set tSC=..QueueForDelete(pRequest)
		}
	} While (0)
Exit
	Quit tSC
Trap
	Set $ZT="",tSC=$$$EnsSystemError
	Goto Exit
	
QueryIfNeeded
	If ..CacheType="PureQuery" {
		Set tDoQuery=1
	} Else {
		Set tDoQuery=0
		If '$D(^HS.ECRQueryQ("MRN",tMRN),tQueryInfo) {
			Set tDoQuery=1,tQueryInfo=""
		} ElseIf $LG(tQueryInfo) {
			//expired or going to expire
			If ..CacheType="NotifyAndQuery" {
				Set tDoQuery=1
			} Else {
				//ExpireAndQuery
				Set tNow=$H,tNow=tNow*86400+$P(tNow,",",2),tExp=$LG(tQueryInfo)
				Set tDoQuery=$S(tExp[",":tExp*86400+$P(tExp,",",2)<tNow,1:1)
			}
		}
	}
	If tDoQuery {
		
		Set tRequest=##class(HS.Message.ECRQueryRequest).%New()
		If ..CacheType="PureQuery" {Set tRequest.TempAggregationKey=tAgKey}
		Set tRequest.AssigningAuthority=pRequest.AssigningAuthority
		Set tRequest.Facility=pRequest.Facility
		Set tRequest.MRN=pRequest.MRN
		Set tRequest.MPIID=pRequest.MPIID
		Set tRequest.AdditionalInfo=pRequest.AdditionalInfo
		//copy requesting user, roles, etc
		Do ##class(HS.Types.RequestInfo).CopyFrom(pRequest,.tRequest)
		Set tRequest.SAMLData=pRequest.SAMLData
		//copy identifiers
		For tJ=1:1:pRequest.Identifiers.Count() Do tRequest.Identifiers.Insert(pRequest.Identifiers.GetAt(tJ))
		Set:..CacheType'="PureQuery" tRequest.LastResponseString=$LG(tQueryInfo,3)
		Set tRequest.Activity=1
		Lock +^HS.ECRQueryQ("lock","MRN",tMRN,"Notifications")
		If ..CacheType="NotifyAndQuery" {
			For tI=1:1:$G(^HS.ECRQueryQ("MRN",tMRN,"Notifications",0)) Do tRequest.Notifications.Insert(^(tI))
		}
		Set tSC=..ECRQueryCacheUpdate(tRequest,.txResponse)
		Lock -^HS.ECRQueryQ("lock","MRN",tMRN,"Notifications")
		If $$$ISOK(tSC),txResponse.Action=0 Set pResponse.Action=0
		If $$$ISOK(tSC),txResponse.Action="ExpireAndQueryDelete" Set tQueueForDelete=1
		
		
	}
	Quit
]]></Implementation>
</Method>

<Method name="QueueForDelete">
<Description>
used for expire and query edges, where the query returned no data because we no longer have a patient.</Description>
<FormalSpec>pRequest:HS.Message.PatientFetchRequestAsync</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tRequest=##class(HS.Message.ECRUpdateRequest).%New()
	Set tContainer=##class(HS.SDA3.Container).%New()
	Set tContainer.SendingFacility=pRequest.Facility
	Set tContainer.Action="DeletePatient"
	Set tContainer.StreamContentType="SDA3"
	Set tContainer.EventDescription="Delete"
	Set tPatient=##class(HS.SDA3.Patient).%New()
	Set tPNum=##class(HS.SDA3.PatientNumber).%New()
	Set tPNum.Number=pRequest.MRN
	Set tPNum.Organization.Code=pRequest.AssigningAuthority
	Set tPNum.NumberType="MRN"
	Do tPatient.PatientNumbers.Insert(tPNum)
	Set tContainer.Patient=tPatient
	Set tSC=tContainer.ToQuickXMLStream(.tCStream) Quit:$$$ISERR(tSC)
	Set tRequest.ContentStream=##class(%Stream.GlobalCharacter).%New()
	Do tRequest.ContentStream.CopyFrom(tCStream)
	Quit ..SendRequestAsync(..%ConfigName,tRequest)
]]></Implementation>
</Method>

<Method name="StreamletRequest">
<Description>
Used for analytics aggregation</Description>
<FormalSpec><![CDATA[pRequest:HS.Message.StreamletRequest,&pResponse:HS.Message.ECRFetchResponse]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tMRN=pRequest.MRN
	Set pResponse=##class(HS.Message.ECRFetchResponse).%New()
	Set pResponse.StreamContentType="Streamlets"
	If ..CacheType="NotifyAndQuery",pRequest.Flavor="Resend",'$D(^HS.ECRQueryQ("MRN",tMRN)) {
		//Handle the case of hybrid notify & query repositories that have been converted
		Set tRequest=##class(HS.Message.ECRQueryRequest).%New()
		Set tRequest.AssigningAuthority=$P(tMRN,"^",2)
		Set tRequest.Facility=$P(tMRN,"^")
		Set tRequest.MRN=$P(tMRN,"^",3)
		Set tRequest.MPIID=pRequest.MPIID
		Set tRequest.Activity=0
		// Since we're already doing a resend, suppress the code that will cause it to queue updates
		Set tFeedAnalytics=..FeedAnalytics,..FeedAnalytics=0
		Set tSC=..ECRQueryCacheUpdate(tRequest,.txResponse)
		Set ..FeedAnalytics=tFeedAnalytics
		If txResponse.Action=0 {
			//for cases where all documents are deprecated, for instance
			Set tQuickStream=##Class(HS.SDA3.QuickStream).%New()
			Do tQuickStream.Write("<StreamletContainer></StreamletContainer>")
			Set pResponse.QuickStreamId=tQuickStream.%Id()
			Quit $$$OK
		}
		Quit:$$$ISERR(tSC) tSC
	}
	Set tProfile=##class(HS.Registry.Config).GetKeyValue("\Terminology\EdgeTranslationProfile","")
	Set tQuickStream=##Class(HS.SDA3.QuickStream).%New()
	Set tSC=##class(HS.SDA3.Container).GetStreamlets(pRequest,.tQuickStream,tProfile)
	Quit:$$$ISERR(tSC) tSC
	Set pResponse.QuickStreamId=tQuickStream.%Id()
	Quit $$$OK
]]></Implementation>
</Method>

<Method name="ECRQueryCacheUpdate">
<FormalSpec>pRequest:HS.Message.ECRQueryRequest,pResponse:HS.Message.ECRQueryResponse</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	#dim tResponse as HS.Message.ECRQueryResponse
	Set tSC=$$$OK,$ZT="Trap", pResponse=##class(HS.Message.ECRQueryResponse).%New()
	Do {
		Set tSC = ..SendRequestSync(..QueryOperation,pRequest,.tResponse) Quit:$$$ISERR(tSC)
		If tResponse.Action=0 {Set pResponse.Action=0 Quit}
		If tResponse.Action="ExpireAndQueryDelete" {Set pResponse.Action=tResponse.Action}
		Quit:tResponse.NoChange
		//Having done the query, we now need to update the ECR cache, which can also do an AddUpdateHub
		If tResponse.ContentStreamList.Count() {
			For tI=1:1:tResponse.ContentStreamList.Count() {
				Set tRequest=##Class(HS.Message.ECRUpdateRequest).%New()
				Set tRequest.QueryCacheUpdate=1 //we have to suppress push in this case only
				Set tRequest.StreamContentType="SDA3"
				Set tRequest.MPIUpdateFlag=tResponse.MPIUpdateFlag
				Do tRequest.ContentStream.CopyFrom(tResponse.ContentStreamList.GetAt(tI))
				If ..CacheType="PureQuery" {Set tRequest.TempAggregationKey=pRequest.TempAggregationKey}
				IF tResponse.ContentStreamList.Count()>1 {
					Set:tI=1 tUpdateTXN=$I(^HS.SDAStreamletTXN)
					Set tRequest.UpdateTXN=tUpdateTXN
					Set:tI'=1 tRequest.SkipReplaceInitialize=1
					Set:tI'=tResponse.ContentStreamList.Count() tRequest.SkipReplaceUpdate=1
				}
				Set tSC=..UpdateStreamletECR(tRequest) Quit:$$$ISERR(tSC)
			}
		} Else {
			Set tRequest=##Class(HS.Message.ECRUpdateRequest).%New()
			Set tRequest.QueryCacheUpdate=1 //we have to suppress push in this case only
			Set tRequest.StreamContentType="SDA3"
			Set tRequest.MPIUpdateFlag=tResponse.MPIUpdateFlag
			Do tRequest.ContentStream.CopyFrom(tResponse.ContentStream)
			If ..CacheType="PureQuery" {Set tRequest.TempAggregationKey=pRequest.TempAggregationKey}
			Set tSC=..UpdateStreamletECR(tRequest) Quit:$$$ISERR(tSC)
		}
		Quit:..CacheType="PureQuery"
		Set tMRN=pRequest.Facility_"^"_pRequest.AssigningAuthority_"^"_pRequest.MRN
		IF $D(^HS.ECRQueryQ("MRN",tMRN),tQueryInfo),$LG(tQueryInfo,2) Kill ^HS.ECRQueryQ("Time",$LG(tQueryInfo,2),tMRN)
		Set tExpires=0,tQTime=""
		If ..CacheType="ExpireAndQuery" {
			Set tNow=$H,tExpireTime=$P(tNow,",",2)+(..CacheExpirationTimeout*3600)
			Set tExpires=tNow+(tExpireTime\86400)_","_(tExpireTime#86400)
			Set:..ScheduleQueryRefresh&&pRequest.Activity tQTime=tExpires
		} Else {
			Set tQTime=""
		}
		Set ^HS.ECRQueryQ("MRN",tMRN)=$LB(tExpires,tQTime,tResponse.ResponseString)
		Set:tQTime ^HS.ECRQueryQ("Time",tQTime,tMRN)=""
		Kill ^HS.ECRQueryQ("MRN",tMRN,"Notifications")
	} While (0)
Exit
	Quit tSC
Trap
	Set $ZT="",tSC=$$$EnsSystemError
	Goto Exit
]]></Implementation>
</Method>

<Method name="PrefetchRequest">
<FormalSpec>pRequest:HS.Message.PrefetchRequest,pResponse:Ens.Response</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tMRN=pRequest.Facility_"^"_pRequest.AssigningAuthority_"^"_pRequest.MRN
	If $D(^HS.ECRQueryQ("MRN",tMRN),tQueryInfo) {
		Set tQTime=$LG(tQueryInfo,2)
		If tQTime {
			Quit:tQTime'>pRequest.Priority $$$OK //if already queued up for this priority or better, don't bother
			Kill ^HS.ECRQueryQ("Time",tQTime,tMRN) //if queued up for later, clear from queue
		}
	} Else {
		Set tQueryInfo=""
	}
	Set $LI(tQueryInfo,2)=pRequest.Priority
	Set ^HS.ECRQueryQ("MRN",tMRN)=tQueryInfo
	Set ^HS.ECRQueryQ("Time",pRequest.Priority,tMRN)=""
	Quit $$$OK
]]></Implementation>
</Method>

<Method name="OnInit">
<Description>
This user callback method is called just after %OnNew()</Description>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Kill %HSCodeSystem
	IF ..InboundCodeSystemProfile'="" {
		Set tProf=##Class(HS.Registry.CodeSystemProfile).%OpenId($ZCVT(..InboundCodeSystemProfile,"U"))
		If '$IsObject(tProf) {$$$LOGERROR("InboundCodeSystemProfile not found: "_..InboundCodeSystemProfile)}
		Else {
			For tI=1:1:tProf.CodeTables.Count() {
				Set tCT=tProf.CodeTables.GetAt(tI)
				Set %HSCodeSystem(tCT.CodeTable)=$ZCVT(tCT.CodeSystem,"U")
			}
		}
	}
	Set ..CacheType=##class(Ens.Director).GetCurrProductionSettingValue("CacheType",.tSC)
	Set ..FeedAnalytics=##class(Ens.Director).GetCurrProductionSettingValue("FeedAnalytics",.tSC)
	Set %ImgViewingSvc=##class(Ens.Director).GetCurrProductionSettingValue("ImageViewerIntegration",.tSC)
	$$$GetTransformer(..Transformer3)
	Set tSC = ..GetAllInfoTypes(.tList) Quit:$$$ISERR(tSC) tSC
	Merge %InfoTypesList = tList
	Quit 1
]]></Implementation>
</Method>

<Method name="GetAllInfoTypes">
<ClassMethod>1</ClassMethod>
<FormalSpec>*pList</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tSC=$$$OK
	Set tStatement=##class(%SQL.Statement).%New()
	//go through all the class definitions again, get the infotype, get the actual classname NOT the display name
	//for the classname - make sure to check that it's not overwritten with a custom class
	Set tQuery = "Select Name From %Dictionary.CompiledClass WHERE PrimarySuper Like '%~HS.SDA3.Streamlet.Abstract~%'"
	Set tSC = tStatement.%Prepare(tQuery)
	Quit:$$$ISERR(tSC) tSC
	Set tRS = tStatement.%Execute()
	If (tRS.%SQLCODE<0){
		Set tSC = $$$ERROR($$$SQLError,tRS.%SQLCODE,tRS.%Message)
		Quit tSC
	}
	While tRS.%Next() {
		Set tClass = tRS.Name
		Set tMatches = $Parameter(tClass,"MATCHINGS")
		Set tInfoType = $parameter(tClass,"INFOTYPE")
		If ((tInfoType="")||(tInfoType="HIS")||(($parameter(tClass,"MATCHINGS")=""))&&(tInfoType'="ENC")){//HIS, ENC are special
			Continue
		}
		//Also skip if the class has been overridden with a site specific extension - from HS.SDA3.Streamlet.Abstract::%StreamletDetermineClass
		If $piece(tClass,".",1,2)="HS.SDA3",tClass'="HS.SDA3.Streamlet.ClinicalRelationship",tClass'="HS.SDA3.Streamlet.ProgramMembership",tClass'="HS.SDA3.Streamlet.CustomObject" {
			Set class=$Parameter("HS.Local.SDA3."_$P(tClass,".",*)_"Extension","STREAMLETCLASS")
			If class'=tClass Continue
		}
		Set tSDAClass = $Parameter(tClass,"SDACLASS")
		If $P(tSDAClass,".",1,2)="HS.SDA3"{	//Whether or not a streamlet class is custom, if it maps to a built-in SDA3 class it's indexed with the short name
			Set pList(tInfoType)=$P(tClass,".",*)
		}
		Else{ //Streamlets for custom SDA3 classes need the full classname
			Set pList(tInfoType)=tClass
		}
	}

	//For historic reasons, three classes of streamlet share the infotype "HIS", but here we need an entry for each one
	Set tFamClass = ##class(HS.Local.SDA3.FamilyHistoryExtension).#STREAMLETCLASS
	Set pList("FAM")=$p(tFamClass,".",*) //"FamilyHistory"
	Set tIllClass = ##class(HS.Local.SDA3.IllnessHistoryExtension).#STREAMLETCLASS
	Set pList("HIS")=$p(tIllClass,".",*) //"IllnessHistory"
	Set tSocClass = ##class(HS.Local.SDA3.SocialHistoryExtension).#STREAMLETCLASS
	Set pList("SOC")=$p(tSocClass,".",*)  //"SocialHistory"
	Quit tSC
]]></Implementation>
</Method>

<Method name="OnTearDown">
<Description>
This user callback method is called just before %OnClose()</Description>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[	Quit 1
]]></Implementation>
</Method>
</Class>


<Class name="Synthea.HS.Gateway.ECR.Process">
<Description>
Process for handling asynchronous fetch requests</Description>
<ClassType>persistent</ClassType>
<IncludeCode>HS.Common,%ZHSLIB</IncludeCode>
<ProcedureBlock>1</ProcedureBlock>
<Super>Ens.BusinessProcess,HS.Util.Trace.Helper</Super>
<TimeChanged>65231,51536.6555</TimeChanged>
<TimeCreated>61312,61269.281877</TimeCreated>

<Parameter name="HSDEPLOY">
<Default>1</Default>
</Parameter>

<Parameter name="SETTINGS">
<Default>ECRTarget,GatewayOperations</Default>
</Parameter>

<Property name="ECRTarget">
<Description>
Destination for any ECR requests we service</Description>
<Type>Ens.DataType.ConfigName</Type>
<InitialExpression>"HS.Gateway.ECR.Manager"</InitialExpression>
</Property>

<Property name="GatewayOperations">
<Description><![CDATA[
Name of the Gateway Remote Operations component in this production.<br> 
Should be the name of a business host that performs actual communications with the Access Gateway Web service, via SOAP messages.]]></Description>
<Type>Ens.DataType.ConfigName</Type>
<InitialExpression>"GATEWAY"</InitialExpression>
</Property>

<Property name="CacheType">
<Description>
copied in from the production setting on startup</Description>
<Type>%String</Type>
</Property>

<Method name="OnRequest">
<FormalSpec>pRequest:Ens.Request,*pResponse:Ens.Response</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	If pRequest.%IsA("HS.Message.PatientFetchRequestAsync") Quit ..FetchRequest(pRequest)
	If pRequest.%IsA("HS.Message.AddUpdateFlashRequest") Quit ..FlashRequest(pRequest,.pResponse)
	Quit $$$ERROR($$$GeneralError, "Unknown Message Type:  " _pRequest.%ClassName(1))
]]></Implementation>
</Method>

<Method name="FetchRequest">
<Description>
The only type of request that's currently handled is an asynchronous fetch request</Description>
<FormalSpec>pRequest:HS.Message.PatientFetchRequestAsync</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tSC=$$$OK,$ZT="Trap"
	Do {
		
		If ^stConfig("LogBool")  { 
			Set tMetric = ##class(Synthea.StressMetrics).%New()
			Set tMetric.Type = "FetchRequest"
			Set tMetric.ClassName = "Synthea.HS.Gateway.ECR.Process"
			Set tMetric.LineStart = 38
			Set tMetric.Start = $ZDATETIME($H,3,1,3)
			set tStart = $ZH
		}
		
		#dim tResponse As HS.Message.PatientFetchResponse
		#dim tRequest As HS.Message.PatientFetchRequestAsync
		Set tQuickStream=""
		Set tSC=##Class(HS.Message.PatientFetchRequestAsync).CopyFrom(pRequest,.tRequest) Quit:$$$ISERR(tSC)
		Set tRequest.SAMLData=pRequest.SAMLData
		Set tRequest.Filters=pRequest.Filters //missed by copyfrom
		Set tRequest.AdditionalInfo=pRequest.AdditionalInfo //missed by copyfrom
		//copy identifiers
		For tJ=1:1:pRequest.Identifiers.Count() Do tRequest.Identifiers.Insert(pRequest.Identifiers.GetAt(tJ))
		If tRequest.UseParallelFetch {
			Set tEdgeSession=$I(^CacheTemp.HS.EdgeSession("C"))
			Set tRequest.EdgeSession=tEdgeSession
			Set tProfile=##class(HS.Registry.Config).GetKeyValue("\Terminology\EdgeTranslationProfile","")
			Set ^CacheTemp.HS.EdgeSession(tEdgeSession)=$LB(pRequest.AssigningAuthority,pRequest.MRN,pRequest.Facility,pRequest.MPIID,pRequest.Sequence,tProfile,0)
		}
		
		// Invoke the ECR Target to perform the actual fetch
	
		Set tSC=..SendRequestSync(..ECRTarget,tRequest,.tResponse) Quit:$$$ISERR(tSC)
		Set:tResponse.QuickStreamId'="" tQuickStream=##Class(HS.SDA3.QuickStream).%OpenId(tResponse.QuickStreamId)
		Set tSDA=$S(tQuickStream'="":tQuickStream,1:tResponse.ContentStream)
		Set tSC=##Class(HS.Audit.Criteria).CopyFrom(pRequest,.tCriteria) Quit:$$$ISERR(tSC)  //to get only the criteria
		Set tSC=tCriteria.XMLExportToString(.tCriteriaString,"Criteria","literal") Quit:$$$ISERR(tSC)
		
		//Here we go
		//Look into response, make requests
		
		//Find the patient name to add to the audit record.  Look first in the new response property, otherwise dig it out of the stream
		
		
		Set tName=tResponse.AuditName
		If tName="" {
			Set tReader = ##class(%XML.Reader).%New()
			Do tReader.OpenStream(tSDA)
			Do tReader.Correlate("Name","HS.SDA3.Name")
			#dim tSDAName As HS.SDA3.Name
			Set tName="",tGot= tReader.Next(.tSDAName,.tSC) Quit:$$$ISERR(tSC)
			If tGot {
				Set tName=tSDAName.FamilyName_", "_tSDAName.GivenName
				Set:tSDAName.MiddleName'="" tName=tName_", "_tSDAName.MiddleName
			}
		}
		
		
		If tRequest.UseParallelFetch {
			Set $List(^CacheTemp.HS.EdgeSession(tEdgeSession),7)=tSDA.Size
			Set tUseEdgeSession=tEdgeSession
			
			//can set ^HS.Gateway.ECR.Process.ForceRemote for debugging/testing within a single instance
			If pRequest.InstanceGUID'=##Class(%SYS.System).InstanceGUID()||$D(^HS.Gateway.ECR.Process.ForceRemote) {
				Set tSC=##class(HS.Flash.Sender).Transmit(pRequest.ReturnGateway,tEdgeSession,.tUseEdgeSession)
				Quit:$$$ISERR(tSC)
				Kill ^CacheTemp.HS.EdgeSession(tEdgeSession)
			}
		}
		
		If ^stConfig("LogBool") { 
    		set tMetric.Elapsed = $ZH - tStart
			Set tMetric.End = $ZDATETIME($H,3,1,3)
			Set tMetric.LineEnd = 103
			Set ltSC = tMetric.Save()
			Quit:$$$ISERR(ltSC)
		}

	
	} While 0
Exit
	
	If ^stConfig("LogBool")  { 
			Set tMetric = ##class(Synthea.StressMetrics).%New()
			Set tMetric.Type = "SendNullResponse"
			Set tMetric.ClassName = "Synthea.HS.Gateway.ECR.Process"
			Set tMetric.LineStart = 115
			Set tMetric.Start = $ZDATETIME($H,3,1,3)
			set tStart = $ZH
		}
	
	//Here it sends gets a 'NULL' reponse
	Set tResponseN=##Class(HS.Message.EPRFetchNotification).%New()
	Set tResponseN.Status=tSC
	If $$$ISOK(tSC),'tRequest.UseParallelFetch {
		DO tResponseN.CopyFrom(tResponse,.tResponseN)
		Set tResponseN.Status=tSC
		If tQuickStream'="" {
			Do tResponseN.ContentStream.CopyFrom(tQuickStream)
			$$$HSTRACE("Copied quickstream","tQuickStream",tQuickStream)
		}
	}
	Set tResponseN.Sequence=pRequest.Sequence
	If pRequest.UseParallelFetch&&$$$ISOK(tSC) {
		Set tResponseN.EdgeSession=tUseEdgeSession
	} Else {
		Set tResponseN.AssigningAuthority=pRequest.AssigningAuthority
		Set tResponseN.MRN=pRequest.MRN
		Set tResponseN.Facility=pRequest.Facility
		Set tResponseN.MPIID=pRequest.MPIID
	}
	Set tResponseN.Gateway=##Class(HS.Gateway.Config).NameIndexOpen(pRequest.ReturnGateway).EndPoint
	DO ..SendRequestSync(..GatewayOperations,tResponseN,.tDummy) //using sync to avoid extra call to OnResponse
	If $$$ISOK(tResponseN.Status) {
			Set tSC2 = $$$HSAuditRecordRequest(pRequest.RequestId,pRequest.RequestingUser,pRequest.RequestingUserRoles,pRequest.RequestingGateway,pRequest.Facility_"^"_pRequest.MRN_"^"_pRequest.AssigningAuthority,.tSDA,tCriteriaString,pRequest.BreakTheGlass,..%SessionId,pRequest.RequestingForProxyUserID,tName,pRequest.MPIID)
	}
	If tQuickStream'="" Do tQuickStream.Clear(1)
	
	If ^stConfig("LogBool") { 
    	set tMetric.Elapsed = $ZH - tStart
		Set tMetric.End = $ZDATETIME($H,3,1,3)
		Set tMetric.LineEnd = 150
		Set ltSC = tMetric.Save()
		Quit:$$$ISERR(ltSC)
	}
	
	Quit tSC
Trap
	Set $ZT="",tSC=$$$EnsSystemError
	Goto Exit
]]></Implementation>
</Method>

<Method name="FlashRequest">
<FormalSpec>pRequest:HS.Message.AddUpdateFlashRequest,*pResponse:HS.Message.AddUpdateFlashResponse</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tSC=$$$OK
	Try {
		Set tRequest=##class(HS.Message.ECRFetchRequestFlash).%New()
		//Set tRequest.Filters=pRequest.Filters //***TBD for later, if we do filtered requests
		Set tRequest.MPIID=pRequest.MPIID
		Set tRequest.MRN=pRequest.MRN,tRequest.AssigningAuthority=pRequest.AssigningAuthority,tRequest.Facility=pRequest.Facility
		Set tRequest.UseParallelFetch=1
		Set tEdgeSession=$I(^CacheTemp.HS.EdgeSession("C"))
		Set tRequest.EdgeSession=tEdgeSession
		Set tRequest.SendWholeMRN=pRequest.SendWholeMRN
		Set tRequest.AAUpdateQ=pRequest.AAUpdateQ
		Set tProfile=##class(HS.Registry.Config).GetKeyValue("\Terminology\EdgeTranslationProfile","")
		Set ^CacheTemp.HS.EdgeSession(tEdgeSession)=$LB(pRequest.AssigningAuthority,pRequest.MRN,pRequest.Facility,pRequest.MPIID,"",tProfile,0)
		Set ^CacheTemp.HS.EdgeSession(tEdgeSession,"C")=0
		Set pResponse=##class(HS.Message.AddUpdateFlashResponse).%New()
		Set pResponse.FetchTime=$ZDT($ZTS,3)
		Set tMRN=pRequest.Facility_"^"_pRequest.AssigningAuthority_"^"_pRequest.MRN
		If $D(^HS.SDAStreamletMRN("MRN",tMRN))||(..CacheType="ExpireAndQuery") {
			// Invoke the ECR Target to perform the actual fetch
			Set tSC=..SendRequestSync(..ECRTarget,tRequest,.tResponse) Quit:$$$ISERR(tSC)
			Set $List(^CacheTemp.HS.EdgeSession(tEdgeSession),8)=tResponse.InboundCodeSystemProfile
		}
		If '$D(^HS.SDAStreamletMRN("MRN",tMRN)) {
			Set pResponse.MRNDeleted=1
		}
		If ..CacheType="ExpireAndQuery" {
			If $D(^HS.ECRQueryQ("MRN",tMRN),tQueryInfo),$LG(tQueryInfo)["," {
				Set pResponse.ExpirationH=$LG(tQueryInfo) //$H type expiration
			}
		} ElseIf ..CacheType="NotifyAndQuery" {
			If $G(^HS.ECRQueryQ("MRN",tMRN,"Notifications",0)) {
				Set pResponse.ExpirationH=$H
			}
		}
		Set tUseEdgeSession=tEdgeSession
		//can set ^HS.Gateway.ECR.Process.ForceRemote for debugging/testing within a single instance
		If pRequest.InstanceGUID'=##Class(%SYS.System).InstanceGUID()||$D(^HS.Gateway.ECR.Process.ForceRemote) {
			Set tSC=##class(HS.Flash.Sender).Transmit(pRequest.FlashGatewayName,tEdgeSession,.tUseEdgeSession)
			Quit:$$$ISERR(tSC)
			Kill ^CacheTemp.HS.EdgeSession(tEdgeSession)
		}
		Set pResponse.EdgeSession=tUseEdgeSession

	} Catch eException {
		Set tSC = eException.AsStatus()
	}
	Quit tSC
]]></Implementation>
</Method>

<Method name="OnInit">
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set ..CacheType=##class(Ens.Director).GetCurrProductionSettingValue("CacheType",.tSC)
	Quit $$$OK
]]></Implementation>
</Method>

<Storage name="Default">
<Type>%Library.CacheStorage</Type>
<DefaultData>ProcessDefaultData</DefaultData>
<Data name="ProcessDefaultData">
<Subscript>"Process"</Subscript>
<Value name="1">
<Value>ECRTarget</Value>
</Value>
<Value name="2">
<Value>GatewayOperations</Value>
</Value>
<Value name="3">
<Value>TraceOperations</Value>
</Value>
<Value name="4">
<Value>CacheType</Value>
</Value>
</Data>
</Storage>
</Class>


<Class name="Synthea.HS.Gateway.HL7.InboundProcess">
<Description>
A sample Inbound Process component that receives HL7 input from one or more Input Service components 
such as an HL7 file service and transforms it into the format required by HealthShare.</Description>
<IncludeCode>HS.Common</IncludeCode>
<ProcedureBlock>1</ProcedureBlock>
<Super>HS.Util.Trace.Helper,Ens.BusinessOperation</Super>
<TimeChanged>65231,52123.821109</TimeChanged>
<TimeCreated>65190,59859.508308</TimeCreated>

<Property name="Pipeline">
<Description><![CDATA[
Specifies how to transform the inbound messages. One of the following: <br> 
If PipelineMode is "DTL", specify a DTL class.<br> 
If PipelineMode is "Business Host", specify a business host.]]></Description>
<Type>Ens.DataType.ConfigName</Type>
</Property>

<Property name="PipelineMode">
<Description>
Pipeline invocation mode:
  - DTL: Invoke pipeline as a DTL transformation
  - HOST: Invoke pipeline as a business host, (e.g. a BP/BPL or BO)
If not specified, a guess is undertaken.</Description>
<Type>%String</Type>
<Parameter name="DISPLAYLIST" value=",DTL,Business Host"/>
<Parameter name="VALUELIST" value=",DTL,HOST"/>
</Property>

<Property name="KeepDuplicateOBXIdentifiers">
<Description><![CDATA[
Keep Duplicate OBX Identifiers (LabResultItem code) handling:<br>
  - 0/false/unchecked: Append suffix to subsequent codes to ensure uniqueness (legacy behavior)<br>
  - 1/true/checked: Keep the original code. This may result in LabResultItems with the same code but different SubId (v16 and later)<br>
For new edge productions this is typically set to 1 by HS.Sample.Production.EdgeGateway.FileProduction.]]></Description>
<Type>%Boolean</Type>
<InitialExpression>0</InitialExpression>
</Property>

<Property name="ECRTarget">
<Description>
Name of the ECR Manager component, a business host that reads from and writes to the ECR.</Description>
<Type>Ens.DataType.ConfigName</Type>
<InitialExpression>"HS.Gateway.ECR.Manager"</InitialExpression>
</Property>

<Property name="PostProcessor">
<Description>
Name of a custom business host that performs additional processing after saving to the ECR (e.g. for PHR reporting)</Description>
<Type>Ens.DataType.ConfigName</Type>
</Property>

<Property name="ErrorHandler">
<Description>
Name of a custom business host that performs additional custom error handling to after calling the custom post processor (if any),
after saving to the ECR.</Description>
<Type>Ens.DataType.ConfigName</Type>
</Property>

<Property name="EnableAcking">
<Description>
Ack/Nack control (note: in HL7 service, AckMode of Application *must* be specified)</Description>
<Type>%Boolean</Type>
<InitialExpression>0</InitialExpression>
</Property>

<Property name="MPIUpdateMode">
<Description><![CDATA[
Flag to control when the MPI should be updated.  If not set, the DefaultMPIUpdateMode
on the MPIUpdateManager will be used.  Values are:
<br/>   - Always: Always update the MPI regardless
<br/>   - IfNeeded: Only update the MPI if a change was detected
<br/>   - IfInsert: Only update the MPI if an insert was detected (or Merge or Delete)
<br/>   - ADTOnly: Only update the MPI when processing an ADT message (or if Insert)]]></Description>
<Type>%String</Type>
<Parameter name="DISPLAYLIST" value=",Always,If Needed,If Insert,ADT Only"/>
<Parameter name="VALUELIST" value=",Always,IfNeeded,IfInsert,ADTOnly"/>
</Property>

<Property name="UpdateECRDemographics">
<Description>
If this is false, then the ECR will insert new demographic rows for patients and encounters, but if the rows
already exist, it will not update them.  See HS.Message.ECRUpdateRequest:UpdateECRDemographics for a full description.</Description>
<Type>%Boolean</Type>
<InitialExpression>1</InitialExpression>
</Property>

<Property name="LogHL7Alerts">
<Description>
If set to true, then extra or out-of-sequence segments will log an Ensemble alert.</Description>
<Type>%Boolean</Type>
<InitialExpression>1</InitialExpression>
</Property>

<Property name="HL7ToSDA3Class">
<Description>
Class to transform incoming HL7 into SDA3 XML</Description>
<Type>%String</Type>
<InitialExpression>"HS.Gateway.HL7.HL7ToSDA3"</InitialExpression>
</Property>

<Property name="ObservationCompatibilityMode">
<Description>
Toggle to change how OBX-5 values are processed
If true OBX-5 will be processed in historical fashion
All iterations of OBX-5.1 are placed in a comma seperated string
while all other values of the OBX-5 are ignored.
If false, the first iteration of OBX-5 will be captured in structured
observation instances retaining all parts of the OBX-5 value based on the 
value provided in OBX-2</Description>
<Type>%Boolean</Type>
<InitialExpression>0</InitialExpression>
</Property>

<Property name="MultiLineOBXCompatibilityMode">
<Description><![CDATA[
Toggle to change how text OBX segments (OBX-2 is "FT" or "TX") are processed.
If true, OBX segments will be processed in historical fashion - if every OBX-2 value in an ORU_R01 message is "FT" or "TX",
the result is parsed as a text result with each OBX segment contributing one line, otherwise
it is parsed as an atomic result.<br>
If false, multiple OBX segments will only be parsed as text if every OBX-3 value is the same, otherwise
they will be parsed as atomic.]]></Description>
<Type>%Boolean</Type>
<InitialExpression>0</InitialExpression>
</Property>

<Parameter name="SETTINGS">
<Description>
Settings for this Business Process</Description>
<Type>%String</Type>
<Default>ObservationCompatibilityMode,MultiLineOBXCompatibilityMode,Pipeline,PipelineMode,ECRTarget,PostProcessor,MPIUpdateMode,UpdateECRDemographics,EnableAcking,ErrorHandler, LogHL7Alerts,HL7ToSDA3Class,KeepDuplicateOBXIdentifiers</Default>
</Parameter>

<XData name="MessageMap">
<Data><![CDATA[
<MapItems>
	<MapItem MessageType="EnsLib.HL7.Message"> 
		<Method>ProcessHL7Message</Method>
	</MapItem>
</MapItems>
]]></Data>
</XData>

<Method name="ProcessHL7Message">
<Description>
API Method: Process an inbound HL7 v2.5 message into the gateway</Description>
<FormalSpec>pRequest:EnsLib.HL7.Message,*pResponse:EnsLib.HL7.Message</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	#dim tSC As %Status
	Set tSC=$$$OK,$ZT="Trap"

	#if $$$HSDebug
		do ##class(HS.Util.HSDebug).Debug("ProcessHL7Message","HS.Gateway.HL7.InboundProcess","txt","***"_pRequest.Identifier,pRequest)
	#endif
	set file=pRequest.Source if $l(file) write:$zjob\1#2 !,"Processing file ",file
	
	Do {
		If ^stConfig("LogBool")  { 
			//Log Item Initialize
			Set tMetric = ##class(Synthea.StressMetrics).%New()
			Set tMetric.Type = "ProcessHL7Message"
			Set tMetric.ClassName = "Synthea.HS.Gateway.HL7.InboundProcess"
			Set tMetric.LineStart = 115
			Set tMetric.Start = $ZDATETIME($H,3,1,3)
			set tStart = $ZH
		}
		
		// Invoke the pipeline, if specified
		#if $$$HSDebug
			do ##class(HS.Util.HSDebug).Debug("ProcessHL7Message","HS.Gateway.HL7.InboundProcess","txt","Pipeline="_..Pipeline)
		#endif
		If ..Pipeline'="" {
			#dim pCleanMsg As EnsLib.HL7.Message
			Set tSC = ..InvokePipeline(pRequest,.pCleanMsg,..Pipeline,$CASE(..PipelineMode,"DTL":1,"HOST":0,:""))
			Quit:$$$ISERR(tSC)
			
			If $IsObject($GET(pCleanMsg)) {
				// Use the response from the pipeline
				Set pRequest = pCleanMsg
			} Else {
				// By returning a NULL message, the pipeline indicates that they want to not process this message
				Quit
			}
		}
	
		// Convert the HL7 message to SDAXML
		Set tSC=$ClassMethod(..HL7ToSDA3Class,"GetSDA",pRequest,.tSDAXML ,..LogHL7Alerts,..ObservationCompatibilityMode,..MultiLineOBXCompatibilityMode, ..KeepDuplicateOBXIdentifiers)
		$$$HSTRACE("SDA3","tSDAXML",tSDAXML)
		Quit:$$$ISERR(tSC)
		
		
		
		// Construct an ECRUpdateRequest with the SDAXML attached.
		#dim tRequest As HS.Message.ECRUpdateRequest
		Set tRequest = ##class(HS.Message.ECRUpdateRequest).%New()
		Do tRequest.ContentStream.CopyFrom(tSDAXML)
		//Set tRequest.ContentStream=tSDAXML
		Set tRequest.OriginalMessageId=pRequest.%Id() //for push
		Set tRequest.StreamContentType="SDA3"
			
		// Check to see when an MPI update will be allowed
		Set tRequest.MPIUpdateFlag = ..MPIUpdateMode
		// and similarly, what sort of ECR updating will happen
		Set tRequest.UpdateECRDemographics=..UpdateECRDemographics
		
		#if $$$HSDebug
			do ##class(HS.Util.HSDebug).Debug("ProcessHL7Message","HS.Gateway.HL7.InboundProcess","txt","ECRUpdateRequest",tRequest)
		#endif

		
		If ^stConfig("LogBool") { 
    		set tMetric.Elapsed = $ZH - tStart
			Set tMetric.End = $ZDATETIME($H,3,1,3)
			Set tMetric.LineEnd = 150
			Set tSC = tMetric.Save()
			Quit:$$$ISERR(tSC)
		}

		//Hash 161
		// Now update the ECR.
		//No need to do sync/negate since this is at end
		Set tSC = ..SendRequestSync(..ECRTarget,tRequest)
		Quit:$$$ISERR(tSC)
	
		// Invoke the post processor (if specified)
		If ..PostProcessor'="" {
			Set tSC = ..SendRequestAsync(..PostProcessor,pRequest)
		}
		
	} While (0)
	
	write:$zjob\1#2 !,"done"
	
Exit
	Do:$$$ISERR(tSC) ..ReportError(tSC, pRequest, .pResponse)	
	Do:..EnableAcking ..OnConstructReply(tSC, pRequest, .pResponse)
	
	Quit tSC
Trap
	Set $ZT="",tSC=$$$EnsSystemError
	Goto Exit
]]></Implementation>
</Method>

<Method name="InvokePipeline">
<Description>
API Method: Pass the Request to the specified Pipeline for transformation</Description>
<FormalSpec><![CDATA[pRequest:EnsLib.HL7.Message,&pResponse:EnsLib.HL7.Message,pPipeline:%String,pDTLPipeline:%Boolean=0]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	#dim tSC As %Status
	Set tSC=$$$OK,$ZT="Trap"
	Do {

		// Invoke the pipeline in the mode specified
		
		If 'pDTLPipeline {
			// Invoke the pipeline as a business process (or operation)
			Set tSC = ..SendRequestSync(pPipeline, pRequest, .pResponse)
		} Else {
			// Invoke the pipeline as a DTL transformation
			Set tSC = $ZOBJCLASSMETHOD(pPipeline, "Transform", pRequest, .pResponse)
			
			// Ensure the response object has been saved
			If $$$ISOK(tSC),$IsObject(pResponse),pResponse.%IsModified() Set tSC = pResponse.%Save()
		}
		
	} While (0)
Exit	
	Quit tSC
Trap
	Set $ZT="",tSC=$$$EnsSystemError
	Goto Exit
]]></Implementation>
</Method>

<Method name="ReportError">
<Description>
API Method: Report an error to the error handler</Description>
<FormalSpec><![CDATA[pSC:%Status,pRequest:EnsLib.HL7.Message,&pResponse:Ens.Response]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	#dim tSC As %Status
	Set tSC=$$$OK,$ZT="Trap"
	Do {
		If $$$ISERR(pSC) {
			
			// Process this through the error handler (if defined)
			If ..ErrorHandler'="" {
				#dim tMsg As HS.Message.ErrorHandlerRequest
				
				// If we have a ErrorHandler defined, invoke it
				Set tMsg = ##class(HS.Message.ErrorHandlerRequest).%New()
				Set tMsg.ErrorSource = ..%ConfigName
				Set tMsg.Error = pSC
				Set tMsg.Message = pRequest
				
				// Dispatch this ...
				Set tSC = ..SendRequestSync(..ErrorHandler,tMsg,.pResponse)
			}
		}
		
	} While (0)
Exit	
	Quit tSC
Trap
	Set $ZT="",tSC=$$$EnsSystemError
	Goto Exit
]]></Implementation>
</Method>

<Method name="OnConstructReply">
<Description>
API Method: Construct a reply (if Acks/Nacks are enabled)</Description>
<FormalSpec><![CDATA[pSC:%Status,pRequest:EnsLib.HL7.Message,&pResponse:EnsLib.HL7.Message]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	#dim tSC As %Status
	Set tSC=$$$OK,$ZT="Trap"
	Do {
		#dim tAckSeg As EnsLib.HL7.Segment
		
		Set pResponse = pRequest.NewReplyDocument(,pRequest.GetValueAt("1:6")_":"_..%ConfigName)
		Set pResponse.Source=pRequest.%Id()
		Do pResponse.SetValueAt(pRequest.GetValueAt("1:10"),"1:10") ; copy the control id to the ack control id
	
		Set tAckSeg=##class(EnsLib.HL7.Segment).%New($LB("",1))
		Set tAckSeg.Separators=pResponse.Separators
		Do tAckSeg.SetValueAt("MSA",0)
		Do tAckSeg.SetValueAt("A"_$S($$$ISOK(pSC):"A",1:"E"),1)
		Do tAckSeg.SetValueAt(pRequest.GetValueAt("1:10"),2)
		Do tAckSeg.SetValueAt($$$StatusDisplayString(pSC),3)
		Do pResponse.AppendSegment(tAckSeg)
		
		If $$$ISERR(pSC) {
			
			// Now build an ERR segment in case of error
			Set tAckSeg=##class(EnsLib.HL7.Segment).%New($LB("",1))
			Set tAckSeg.Separators=pResponse.Separators
			Do tAckSeg.SetValueAt("ERR",0)
			
			// Unfortunately, we don't know what part of the original message caused the error ...
			
			Do tAckSeg.SetValueAt("E",4)  // It's an error
			Do tAckSeg.SetValueAt($P($system.Status.GetErrorCodes(pSC),","),5)
			Do tAckSeg.SetValueAt($$$StatusDisplayString(pSC),8)
			Do pResponse.AppendSegment(tAckSeg)
		}
		
		Set pResponse.IsMutable=0
	
	} While (0)
Exit	
	Quit tSC
Trap
	Set $ZT="",tSC=$$$EnsSystemError
	Goto Exit
]]></Implementation>
</Method>

<Method name="OnInit">
<Description>
API Method: This user callback method is called just after %OnNew()</Description>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	#dim tSC As %Status
	Set tSC=$$$OK,$ZT="Trap"
	Do {
		// Determine the pipeline type if not specified (and a pipeline *was* specified)
		If ..Pipeline'="",..PipelineMode="" {		
			// Let's determine exactly *what* the pipeline is, DTL or BPL.  If it's a DTL, then:
			//     1) pPipeline needs to be a valid classname
			//     2) The class referred to by pPipeline must be a subclass of Ens.DataTransform
			
			Set ..PipelineMode = $S($$IsDerivedFrom^%occLibrary(..Pipeline,"Ens.DataTransformation"):"DTL",1:"HOST")
		}
		
	} While (0)
Exit
	Quit tSC
Trap
	Set $ZT="",tSC=$$$EnsSystemError
	Goto Exit
]]></Implementation>
</Method>

<Storage name="Default">
<Type>%Library.CacheStorage</Type>
<DataLocation>^HS.Gateway.HL7.InboundProcessD</DataLocation>
<DefaultData>InboundProcessDefaultData</DefaultData>
<IdLocation>^HS.Gateway.HL7.InboundProcessD</IdLocation>
<IndexLocation>^HS.Gateway.HL7.InboundProcessI</IndexLocation>
<StreamLocation>^HS.Gateway.HL7.InboundProcessS</StreamLocation>
<Data name="CompiledStyleSheets">
<Attribute>CompiledStyleSheets</Attribute>
<Structure>subnode</Structure>
<Subscript>"CompiledStyleSheets"</Subscript>
</Data>
<Data name="CompiledStyleSheetsInfo">
<Attribute>CompiledStyleSheetsInfo</Attribute>
<Structure>subnode</Structure>
<Subscript>"CompiledStyleSheetsInfo"</Subscript>
</Data>
<Data name="InboundProcessDefaultData">
<Subscript>"InboundProcess"</Subscript>
<Value name="1">
<Value>Pipeline</Value>
</Value>
<Value name="2">
<Value>PostProcessor</Value>
</Value>
<Value name="3">
<Value>ECRManager</Value>
</Value>
<Value name="4">
<Value>CallbackHandlerClass</Value>
</Value>
<Value name="5">
<Value>RuntimeMode</Value>
</Value>
<Value name="6">
<Value>CallbackHandler</Value>
</Value>
<Value name="7">
<Value>ErrorHandler</Value>
</Value>
<Value name="8">
<Value>Stylesheet</Value>
</Value>
<Value name="9">
<Value>StylesheetDir</Value>
</Value>
<Value name="10">
<Value>StylesheetDirFileSpec</Value>
</Value>
<Value name="11">
<Value>DocType</Value>
</Value>
<Value name="12">
<Value>UseSchemaCache</Value>
</Value>
<Value name="13">
<Value>GoFaster</Value>
</Value>
<Value name="14">
<Value>XDEV</Value>
</Value>
<Value name="15">
<Value>Target</Value>
</Value>
<Value name="16">
<Value>GoFasterAndDontTrace</Value>
</Value>
<Value name="17">
<Value>Transformer</Value>
</Value>
<Value name="18">
<Value>PipelineMode</Value>
</Value>
<Value name="19">
<Value>ECRTarget</Value>
</Value>
<Value name="20">
<Value>MPIUpdateMode</Value>
</Value>
<Value name="21">
<Value>EnableAcking</Value>
</Value>
<Value name="22">
<Value>%%CLASSNAME</Value>
</Value>
<Value name="23">
<Value>%RequestHeader</Value>
</Value>
<Value name="24">
<Value>AlertOnError</Value>
</Value>
<Value name="25">
<Value>AlertRetryGracePeriod</Value>
</Value>
<Value name="26">
<Value>%QuitTask</Value>
</Value>
<Value name="27">
<Value>%SessionId</Value>
</Value>
<Value name="28">
<Value>NoFailWhileDisconnected</Value>
</Value>
<Value name="29">
<Value>Retry</Value>
</Value>
<Value name="30">
<Value>SuspendMessage</Value>
</Value>
<Value name="31">
<Value>DeferResponse</Value>
</Value>
<Value name="32">
<Value>%AlertStartTime</Value>
</Value>
<Value name="33">
<Value>RetryCount</Value>
</Value>
<Value name="34">
<Value>Adapter</Value>
</Value>
<Value name="35">
<Value>%ConfigQueueName</Value>
</Value>
<Value name="36">
<Value>%ConfigName</Value>
</Value>
<Value name="37">
<Value>ArchiveIO</Value>
</Value>
<Value name="38">
<Value>FailureTimeout</Value>
</Value>
<Value name="39">
<Value>IOLogEntry</Value>
</Value>
<Value name="40">
<Value>RetryInterval</Value>
</Value>
</Data>
<Data name="Parameters">
<Attribute>Parameters</Attribute>
<Structure>subnode</Structure>
<Subscript>"Parameters"</Subscript>
</Data>
</Storage>
</Class>


<Class name="Synthea.HS.Hub.MPI.Manager">
<Description><![CDATA[
The default MPI Manager component.<br> 
Determines how to handle MPI requests; sends messages to the MPI Operations component 
(which is different for different MPIs).]]></Description>
<IncludeCode>HS.Common,%callout,%ZHSLIB</IncludeCode>
<ProcedureBlock>1</ProcedureBlock>
<Super>HS.Util.Trace.Helper,Ens.BusinessOperation,HS.Util.Trace.Performance</Super>
<TimeChanged>65232,40877.926601</TimeChanged>
<TimeCreated>60802,52039.279</TimeCreated>
<Inheritance>right</Inheritance>

<Parameter name="INVOCATION">
<Description>
Invoke InProc</Description>
<Default>InProc</Default>
</Parameter>

<Parameter name="DOMAIN">
<Default>HS</Default>
</Parameter>

<Property name="MPIOperations">
<Description>
If there's an external patient matching engine, this should be the name of the business operation
that sends messages to the external patient matching engine</Description>
<Type>Ens.DataType.ConfigName</Type>
</Property>

<Property name="DemographicLinkMode">
<Description>
This is only applicable if there's no external patient matching engine
Flag to control how/if the MPI should link record based on demographic match.  Values are:
  - Probable: Will match based on lastname+firstname+address+phone+fuzzy birthdate, OR
              lastname+firstname+zip+birthdate, OR lastname+SSN, OR firstname+SSN+birthdate
  - Strict: Will match based on lastname+firstname+address+phone+birthdate, OR
              lastname+SSN+zip+birthdate, OR firstname+SSN+zip+birthdate

  - Never: No linking of MRNs is done on demographics</Description>
<Type>%String</Type>
<InitialExpression>"Probable"</InitialExpression>
<Parameter name="DISPLAYLIST" value=",Probable,Strict,Never"/>
<Parameter name="VALUELIST" value=",Probable,Strict,Never"/>
</Property>

<Property name="MPITimeout">
<Description>
Timeout in seconds for MPI operations.  -1 means no timeout</Description>
<Type>%Integer</Type>
<InitialExpression>-1</InitialExpression>
</Property>

<Property name="MPISecondaryOperations">
<Description>
For secondary MPIs, which need to be queried only after getting the primary response</Description>
<Type>Ens.DataType.ConfigName</Type>
</Property>

<Property name="PreProcessor">
<Description>
Name of a custom business host that defines a step for the MPI Manager to perform just before it communicates with the MPI Operations component.</Description>
<Type>Ens.DataType.ConfigName</Type>
</Property>

<Property name="PostProcessor">
<Description>
Name of a custom business host that defines a step for the MPI Manager to perform after it processes the search results, update, etc.</Description>
<Type>Ens.DataType.ConfigName</Type>
</Property>

<Property name="ConsentProcessor">
<Description>
Name of the Consent Manager component in this production that applies consent filtering</Description>
<Type>Ens.DataType.ConfigName</Type>
</Property>

<Property name="MatchMode">
<Description>
Exact match mode, value is one of:
  Exact: The search results must match only one patient. This means only one MPIID should be returned
    by the search (perhaps with several records), else it will be aborted (returning no results).
    The abort will occur even if later conditions (consent, infotype filters, etc) would reduce the
    number of patients to just 1.
  Any: The search can match any results (more than one patient)</Description>
<Type>%String</Type>
<InitialExpression>"Any"</InitialExpression>
<Parameter name="VALUELIST" value=",Exact,Any"/>
</Property>

<Property name="DynamicFacilityRegistration">
<Description>
Set this to true if you want to permit inbound update requests to cause new facilities
to be added to the facility table.</Description>
<Type>%Boolean</Type>
<InitialExpression>0</InitialExpression>
</Property>

<Property name="DynamicAssignAuthorityRegistration">
<Description>
Set this to false if you do not want to permit inbound update requests to cause new assign authorities
to be added to the assigning authority table for medical record numbers
And note that an assigning authority may also get created for a facility as part of dynamic facility registration</Description>
<Type>%Boolean</Type>
<InitialExpression>1</InitialExpression>
</Property>

<Property name="PushEvaluator">
<Description>
Name of the Push Evaluation Operation component that performs ***</Description>
<Type>Ens.DataType.ConfigName</Type>
<InitialExpression>"HS.Hub.Push.Evaluator"</InitialExpression>
</Property>

<Property name="FilterByFacilities">
<Description>
Deprecated - we use SearchMode instead</Description>
<Type>%Boolean</Type>
<InitialExpression>1</InitialExpression>
</Property>

<Property name="MaxMatches">
<Description>
Only applicable if there is no external patient matching engine, or
if we're doing a search that bypasses the external engine (by cohort, by relationship, etc.)
Maximum number of MPIID matches to return during a patient search</Description>
<Type>%Integer</Type>
<InitialExpression>50</InitialExpression>
</Property>

<Property name="PIXv3Manager">
<Description>
Deprecated - use PIXManager instead</Description>
<Type>Ens.DataType.ConfigName</Type>
</Property>

<Property name="PIXManager">
<Description>
Which Host to send IDUpdateNotificationRequests</Description>
<Type>Ens.DataType.ConfigName</Type>
</Property>

<Property name="IdentifierCompatibilityMode">
<Description><![CDATA[
If IdentifierCompatibilityMode is true, then an incoming patient update with at least one identifier
will clear <b>all</b> existing identifiers (except use "SN", insurance IDs), regardless of whether any of the incoming identifiers has
the same type.  Identifiers with use "SN" will only be replaced if one of the incoming identifiers also has use "SN".<br>
If IdentifierCompatibilityMode is false, then any existing identifiers will only be removed if the incoming patient update
has at least one identifier <b>with the same use</b>.]]></Description>
<Type>%Boolean</Type>
<InitialExpression>1</InitialExpression>
</Property>

<Parameter name="SETTINGS">
<Description>
Settings for this Business Process</Description>
<Type>%String</Type>
<Default><![CDATA[MPIOperations,MPITimeout,DemographicLinkMode,MatchMode,PreProcessor,PostProcessor,ConsentProcessor,MPISecondaryOperations::selector?multiSelect=1&context={Ens.ContextSearch/ProductionItems?targets=1&productionName=@productionId},DynamicFacilityRegistration, DynamicAssignAuthorityRegistration, PushEvaluator, FilterByFacilities, MaxMatches,-PIXv3Manager,PIXManager,IdentifierCompatibilityMode]]></Default>
</Parameter>

<XData name="MessageMap">
<Data><![CDATA[
<MapItems>
	<MapItem MessageType="HS.Message.MergePatientRequest"> 
		<Method>MergePatient</Method>
	</MapItem>
	<MapItem MessageType="HS.Message.RemovePatientRequest"> 
		<Method>RemovePatient</Method>
	</MapItem>
	<MapItem MessageType="HS.Message.PatientSearchRequest"> 
		<Method>SearchMPI</Method>
	</MapItem>
	<MapItem MessageType="HS.Message.AddUpdateHubRequest">
		<Method>AddUpdateHub</Method>
	</MapItem>
	<MapItem MessageType="HS.Message.FindAutoLinkMatchRequest">
		<Method>DelegateToMPI</Method>
	</MapItem>
	<MapItem MessageType="HS.Message.RecentPatientUpdateRequest">
		<Method>RecentPatientUpdateRequest</Method>
	</MapItem>
	<MapItem MessageType="HS.Message.IDUpdateNotificationRequest">
		<Method>ExternalUpdateMPIIDRequest</Method>
	</MapItem>

</MapItems>
]]></Data>
</XData>

<Method name="DelegateToMPI">
<Description>
Delegate this message to the MPI</Description>
<FormalSpec><![CDATA[pRequest:Ens.Request,&pResponse:Ens.Response]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	#dim tSC As %Status
	Set tSC = $$$OK
	Do {
		Set tSC=..InvokePreProcessor(.pRequest)
		Quit:$$$ISERR(tSC)		
		Set tSC = ..SendRequestSync(..MPIOperations,pRequest,.pResponse,..MPITimeout)
		$$$HSTRACE("Delegated to MPI","tSC,pRequest,pResponse",tSC,pRequest,pResponse)
		Quit:$$$ISERR(tSC)
		Set tSC=..InvokePostProcessor(pRequest,.pResponse)
	} While (0)
Exit
	Quit tSC
]]></Implementation>
</Method>

<Method name="InvokePreProcessor">
<FormalSpec><![CDATA[&pRequest:Ens.Request]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Quit:..PreProcessor="" $$$OK
	Set tRequest=pRequest
	Set tSC= ..SendRequestSync(..PreProcessor,tRequest,.pRequest)
	$$$HSTRACE("Sent Pre Processor","tSC,tRequest,pRequest",tSC,tRequest,pRequest)
	Quit tSC
]]></Implementation>
</Method>

<Method name="InvokePostProcessor">
<FormalSpec><![CDATA[pRequest:Ens.Request,&pResponse:Ens.Response]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Quit:..PostProcessor="" $$$OK
	Set tRequest=##Class(HS.Message.PostProcessorRequest).%New()
	Set tRequest.OriginalRequest=pRequest
	Set tRequest.OriginalResponse=pResponse
	Set tSC= ..SendRequestSync(..PostProcessor,tRequest,.pResponse)
	$$$HSTRACE("Sent Post Processor","tSC,tRequest,pResponse",tSC,tRequest,pResponse)
	Quit tSC
]]></Implementation>
</Method>

<Method name="MRNtoMPIID">
<Description>
Utility method - pass in pAA, pMRN, and it will return either the corresponding MPIID if found, or "" if not</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>pAA,pMRN</FormalSpec>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
	&SQL(Select MPIID into :tMPIID FROM HS_Registry.Patient WHERE MRN=:pMRN AND AssigningAuthority=:pAA)
	Quit:SQLCODE'=0 ""
	Quit tMPIID
]]></Implementation>
</Method>

<Method name="GetMPIID">
<Description>
Utility method
Used to fetch a patient search response, based on an MPIID, or MRN+AA.  For compatibility, this uses the more
generic search request, but ignores everything except for the MPIID, MRN, AA
Used to get the patient name or to get a list of MRN, for audit reports, etc.
pFull - if true, load the full patient.  Otherwise, just return MRN, Facility, AA</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pRequest:HS.Message.PatientSearchRequest,&pResponse:HS.Message.PatientSearchResponse,pFull:%Boolean=1]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set pResponse=##Class(HS.Message.PatientSearchResponse).%New()
	Set tMPIID=pRequest.MPIID
	IF pRequest.MPIID="" {
		Set tMRN=pRequest.MRN,tAA=pRequest.AssigningAuthority
		&SQL(Select MPIID into :tMPIID FROM HS_Registry.Patient WHERE MRN=:tMRN AND AssigningAuthority=:tAA)
		Quit:SQLCODE'=0 $$$OK
	}
	Quit ..ReturnMPIID(tMPIID,.pResponse,pFull)
]]></Implementation>
</Method>

<Method name="ReturnMPIID">
<Description>
Utility method, a bit simpler than GetMPIID, for those who will be fetching only by MPIID
pFromFlash is used for two simpler requests from flash, allowing it to exclude PureQuery
and to also return the edge type</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pMPIID,&pResponse,pFull:%Boolean=0,pFromFlash:%Boolean=0]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set pResponse=##Class(HS.Message.PatientSearchResponse).%New()
	Set tRes=##class(%SQL.Statement).%ExecDirect(,"Select %ID,AssigningAuthority,Facility,MRN, Facility->Gateway->CacheType As EdgeType from HS_Registry.Patient WHERE MPIID=? ORDER By IsNull(Facility->Tier,99999),LastEnteredOnC DESC",pMPIID)
	If tRes.SQLCODE Quit $$$ERROR(tRes.SQLCODE,tRes.%Message)
	While tRes.%Next() {
		If pFromFlash,tRes.EdgeType="PureQuery" Continue
		Set tMatch=##Class(HS.Message.PatientSearchMatch).%New()
		Set tMatch.MPIID=pMPIID, tMatch.AssigningAuthority=tRes.AssigningAuthority
		Set tMatch.Facility=tRes.Facility,tMatch.MRN=tRes.MRN
		Set tMatch.CanFilterInfoTypes=1  //this distinguished primary from secondary results
		If pFromFlash {
			Do tMatch.AdditionalInfo.SetAt(tRes.EdgeType,"EdgeType")
		}
		If pFull {
			Set tId=tRes.%GetData(1)
			Set tPatient=##Class(HS.Registry.Patient).%OpenId(tId)
			Set tSC=..LoadPatient(tPatient,.tMatch)
		}
		//We insert the results based on the tiered/updated ordering, so the best is first
		Do pResponse.Results.Insert(tMatch)
	}
	Quit $$$OK
]]></Implementation>
</Method>

<Method name="ODSSearch">
<FormalSpec>pRequest:HS.Message.PatientSearchRequest,pResponse:HS.Message.PatientSearchResponse</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set pResponse=##Class(HS.Message.PatientSearchResponse).%New()
	Set tRes=##class(%SQL.Statement).%ExecDirect(,"Select %ID,AssigningAuthority,Facility,MRN, Facility->Gateway->CacheType As EdgeType from HS_Registry.Patient WHERE MPIID=? ORDER By IsNull(Facility->Tier,99999),LastEnteredOnC DESC",pRequest.MPIID)
	If tRes.SQLCODE Quit $$$ERROR(tRes.SQLCODE,tRes.%Message)
	While tRes.%Next() {
		If tRes.EdgeType="PureQuery" Continue
		Set tMatch=##Class(HS.Message.PatientSearchMatch).%New()
		Set tMatch.MPIID=pRequest.MPIID, tMatch.AssigningAuthority=tRes.AssigningAuthority
		Set tMatch.Facility=tRes.Facility,tMatch.MRN=tRes.MRN
		Set tMatch.CanFilterInfoTypes=1  //this distinguished primary from secondary results
		Do tMatch.AdditionalInfo.SetAt(tRes.EdgeType,"EdgeType")
		//We insert the results based on the tiered/updated ordering, so the best is first
		Do pResponse.Results.Insert(tMatch)
	}
	If ..MPISecondaryOperations'="" {
		Set tRequest=##Class(HS.Message.PatientSecondarySearchRequest).%New()
		Set tRequest.PrimaryRequest=pRequest
		Set tRequest.PrimaryResponse=pResponse
		Set tSC = ..ProcessSecondaryMPISearch(tRequest, .pResponse,..MPISecondaryOperations)
	}
	Quit $$$OK
]]></Implementation>
</Method>

<Method name="SearchMPI">
<Description><![CDATA[
Search the MPI.  pRequest.SearchMode: user - regular view-type search.  Does consent & infotype filter, drops results whose facility has no gateway (i.e. mini-reg only)
Admin: administrative: no consent filter, no return of facility/MRN.
participation: special for RI participation gateway.  Suppress Audit
clinician: special consent filter - also passes if there's a relationship
PIXPDQ: for PIX or PDQ
PIXPDQ_c: for PIX or PDQ, consent applied
AuditReport: deprecated
ODS - for internal message from ODS to get a list of patients to load]]></Description>
<FormalSpec>pRequest:HS.Message.PatientSearchRequest,pResponse:HS.Message.PatientSearchResponse</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	If ^stConfig("LogBool")  { 
			Set tMetric = ##class(Synthea.StressMetrics).%New()
			Set tMetric.Type = "SearchMPI"
			Set tMetric.ClassName = "Synthea.HS.Hub.MPI.Manager"
			Set tMetric.LineStart = 239
			Set tMetric.Start = $ZDATETIME($H,3,1,3)
			set tStartZH = $ZH
	}	
	
	#dim tSC As %Status
	#dim tIndex As %String
	#dim tResponse As HS.Message.PatientSearchResponse
	#dim tMatch As HS.Message.PatientSearchMatch
	#dim tHit As HS.Message.PatientSearchMatch
	If pRequest.SearchMode="ODS" Quit ..ODSSearch(pRequest,.pResponse)
	Set tSC=$$$OK,$ZT="Trap"
	$$$HSPerfStart("Search MPI")
	Do {
		#dim tDupeHash
		#dim tResult As HS.Message.PatientSearchMatch
		set tNewRequest=pRequest.%ConstructClone(1)
		Set pResponse=##class(HS.Message.PatientSearchResponse).%New()
		// Invoke the pre-processor (if specified)
		Set tSC=..InvokePreProcessor(.tNewRequest)
		Quit:$$$ISERR(tSC)		
		$$$HSPerfStart("Primary MPI Search")
		//suppress facility filter for primary search of an external MPI - we will use this later after any secondary MPI
		Set:..MPIOperations'="" tFac=tNewRequest.Facility,tNewRequest.Facility=""
		Set tSC = ..PrimarySearch(tNewRequest,.tResponse)
		Set:$G(tFac)]"" tNewRequest.Facility=tFac
		$$$HSPerfEnd
		Quit:$$$ISERR(tSC)

		Set tUseComposite = ##class(HS.Registry.Config).GetKeyValue("\MPI\CompositeHSPISearchResults",0)
		Set tHaveComposite = tUseComposite && ($IsObject(tResponse.MPIIDList) && tResponse.MPIIDList.Count() && $L(tResponse.MPIIDList.GetAt(1).LastName))
		Set tMatches  = $S(tHaveComposite:tResponse.MPIIDList, 1:tResponse.Results)
		Set tRankProp = $S(tHaveComposite:"Rank", 1:"RankOrScore")

		//Use results to get a ranked list of MPIIDs. 2010.2 - we no longer care about the result detail
		Kill tMPIArray
		Set tMPICount = tMatches.Count()
		For tI=1:1:tMPICount { Set tMPIMatch=tMatches.GetAt(tI)
			Set tMPIID=tMPIMatch.MPIID, tRank=$property(tMPIMatch,tRankProp)
			IF '$D(tMPIArray(tMPIID)) {
				//Check for exact match mode - if >1 MPIID, assume no match
				IF ..MatchMode="Exact",'tNewRequest.Recent,$D(tMPIArray) {Kill tMPIArray  Set tMPICount=0  Quit}
				Set tMPIArray(tMPIID)=tI
				Set tMPIArray(tMPIID,"Rank")=tRank
			} Else {
				Set:tRank>tMPIArray(tMPIID,"Rank") tMPIArray(tMPIID,"Rank")=tRank
			}
		}
		//for each MPIID found, collect all of the individual records, sorted by facility tier and last update
		Set tStatement=##Class(%SQL.Statement).%New()
		Set tSC=tStatement.%Prepare("Select %ID from HS_Registry.Patient WHERE MPIID=? ORDER By IsNull(Facility->Tier,99999),LastEnteredOnC DESC")
		Quit:$$$ISERR(tSC)
		Set tNQErr=0
		Set tMPIID="" For { Set tMPIID=$O(tMPIArray(tMPIID),1,tI)  Quit:tMPIID=""
			Set tRes=tStatement.%Execute(tMPIID), tFirst=0
			While tRes.%Next() {
				Set tId=tRes.%GetData(1)
				Set:$I(tFirst)=1 tMPIArray(tMPIID,"Best")=tId
				Set tPatient=##Class(HS.Registry.Patient).%OpenId(tId)
				Continue:'$IsObject(tPatient) //to prevent obscure timing problem when flash is processing a merge/delete
				Set tMatch=##Class(HS.Message.PatientSearchMatch).%New()
				Set tMatch.MPIID=tPatient.MPIID, tMatch.AssigningAuthority=tPatient.AssigningAuthority
				Set tMatch.MPIIDListItem = tI
				Set tMatch.Facility=tPatient.Facility.FacilityCode,tMatch.MRN=tPatient.MRN
				Set tMatch.RankOrScore = tMPIArray(tMPIID,"Rank")
				Set tMatch.CanFilterInfoTypes=1  //this distinguished primary from secondary results
				Set tSC=..LoadPatient(tPatient,.tMatch)
				//We insert the results based on the tiered/updated ordering
				Do pResponse.Results.Insert(tMatch)
			}
			IF '$D(tMPIArray(tMPIID,"Best")) Kill tMPIArray(tMPIID) //no records exist in the registry
			IF 'tNQErr,tNewRequest.SearchMode="user",'tNewRequest.IgnoreSecondaryMPI,$D(^HS.XDSNQErrors(tMPIID)) Set tNQErr=1
		}
		If tNewRequest.SearchMode="user" {
			// Set up infotype filter, if present
			Kill tInfoTypeFilter
			For tI=1:1:tNewRequest.InfoTypes.Count() {
				Set tInfoType=tNewRequest.InfoTypes.GetAt(tI)
				If $L(tInfoType) {
					if $d(tInfoTypeFilter) {set tInfoTypeFilter=tInfoTypeFilter_","} else {set tInfoTypeFilter=""}
					Set tInfoTypeFilter(tInfoType)=1,tInfoTypeFilter=tInfoTypeFilter_tInfoType
				}
			}
		}
		Set pResponse.ResultsCount=tMPICount
		Set tSecondaryOps=..MPISecondaryOperations
		If tNQErr,tSecondaryOps'["HS.MPI.IHE.XDSb.Registry.SecondaryOperations" {
			Set tSecondaryOps="HS.MPI.IHE.XDSb.Registry.SecondaryOperations"_$S(tSecondaryOps="":"",1:",")_tSecondaryOps
		}
		If tSecondaryOps'="",tNewRequest.SearchMode="user",pResponse.Results.Count(),'tNewRequest.IgnoreSecondaryMPI {
			Set tRequest=##Class(HS.Message.PatientSecondarySearchRequest).%New()
			Set tRequest.PrimaryRequest=tNewRequest
			Set tRequest.PrimaryResponse=pResponse
			Set tSC = ..ProcessSecondaryMPISearch(tRequest, .pResponse,tSecondaryOps)
		}
		Quit:$$$ISERR(tSC)
		
		if (tNewRequest.SearchMode = "AuditReport") {
			/// This is for internal use by the audit report
			/// It needs to fetch a list of MRNs for that MPIID before starting the search
			$$$HSTRACE("Returning early for SearchMode=AuditReport","HS.Message.PatientSearchRequest",tNewRequest)
			Quit
		}
		
		// Audit, unless it's a Participation Gateway request
		If tNewRequest.SearchMode'="participation" {
			// For the audit trail
			Set tMPIlist="",tMRNlist=""
			For tI=1:1:pResponse.Results.Count() {
				Set tRes=pResponse.Results.GetAt(tI)
				If tRes.MPIID'="" {Set tMPIlist=tMPIlist_$LB(tRes.MPIID)}
				If tRes.MRN'="" {Set tMRNlist=tMRNlist_$LB(tRes.Facility_"^"_tRes.MRN_"^"_tRes.AssigningAuthority)}
			}
			#dim tReq AS HS.Message.PatientSearchRequest
			Set tReq=tNewRequest, tInitLog=tReq.RequestId
			Set tSC=##Class(HS.Audit.Criteria).CopyFrom(tReq,.tCriteria) Quit:$$$ISERR(tSC)  //to get only the criteria
			Set tSC=tCriteria.XMLExportToString(.tCriteriaString,"Criteria","literal")  Quit:$$$ISERR(tSC)
			Set tSC=$$$HSAuditSearchPatient(.tInitLog,tReq.RequestingUser,tReq.RequestingUserRoles,tReq.RequestingGateway,tMPIlist,tMRNlist,tCriteriaString,tReq.BreakTheGlass,..%SessionId,tReq.RequestingForProxyUserID)  Quit:$$$ISERR(tSC)
			Quit:$$$ISERR(tSC)
			Set:tNewRequest.RequestId="" tNewRequest.RequestId=tInitLog
			Set:pResponse.RequestId="" pResponse.RequestId=tInitLog
		}

		// Invoke the post-processor (if specified)
		Set tSC=..InvokePostProcessor(tNewRequest,.pResponse)  Quit:$$$ISERR(tSC)
	
		if (pResponse.Results.Count() = 0) {			
			$$$HSTRACE("No results found","HS.Message.PatientSearchResponse",pResponse)
		} elseif tNewRequest.SearchMode="clinician"||(tNewRequest.SearchMode="PIXPDQ")||(tNewRequest.SearchMode="PIXPDQ_c") {
			$$$HSTRACE("Skipping filtering due to search mode","HS.Message.PatientSearchRequest",tNewRequest)
		} elseif tNewRequest.SearchMode'="user" { //for Admin & participation
			$$$HSTRACE("Skipping filtering due to non-user search mode","HS.Message.PatientSearchRequest",tNewRequest)
		} else {
			$$$HSTRACE("Filtering " _ pResponse.Results.Count() _ " Results","HS.Message.PatientSearchResponse",pResponse)
		}

		//Now look at each result, deal with additional info, facility filter, and infotypes filter
		For tIndex=pResponse.Results.Count():-1:1 {
			Set tResult=pResponse.Results.GetAt(tIndex)
			
			//Copy additional Info into Result, for potential use by external consent engine
			Set tElement="" For  { Set tItem = tNewRequest.AdditionalInfo.GetNext(.tElement) Quit:tElement=""  Do tResult.AdditionalInfo.SetAt(tItem,tElement)}

			IF tNewRequest.SearchMode="clinician"||(tNewRequest.SearchMode="PIXPDQ")||(tNewRequest.SearchMode="PIXPDQ_c") {
				Continue
			}
			IF tNewRequest.SearchMode'="user" { //for Admin & participation
				Set tResult.MRN="", tResult.Facility=""
				Set tSC=pResponse.Results.SetAt(tResult,tIndex) Quit:$$$ISERR(tSC)
				Continue
			}
			// Continue processing result for user mode search
			// Don't show patients that have no facility
			If (tResult.Facility = "") {
				$$$HSTRACE("Removing PatientSearchMatch with no facility","HS.Message.PatientSearchMatch",tResult)
				Do pResponse.Results.RemoveAt(tIndex)
				Continue
			}
			//check facility filter, if present
			IF tNewRequest.Facility'="", tNewRequest.Facility'=tResult.Facility {
				$$$HSTRACE("Removing PatientSearchMatch which failed facility filter","HS.Message.PatientSearchMatch",tResult)
				Do pResponse.Results.RemoveAt(tIndex)
				Continue
			}	
			// Next, let's lookup the facility/gateway for this match
			Set tSC = ##class(HS.Facility.Config).FindByFacilityCode(tResult.Facility, .tIdprop, .tGatewayId, .tFacilityId)
			Quit:$$$ISERR(tSC)
			Set tResult.GatewayStatus=$$$OK, tEndPoint=""
			IF tGatewayId'="" {
				Set tGW = ##class(HS.Gateway.Config).%OpenId(tGatewayId,,.tSC) Quit:$$$ISERR(tSC)
				Set tEndPoint=tGW.EndPoint
			}
			//Set tResult.GatewayStatus = ##class(HS.Facility.Config).FindGatewayEndpointByCode(tResult.Facility,.tEndPoint)
			// Don't show patients that have no gateway for results
			If (tEndPoint = "")||(tGW.CacheType="ConsumeAndForward") {
				if (tGatewayId = "") {
					$$$HSTRACE("Removing PatientSearchMatch with no gateway","HS.Message.PatientSearchMatch",tResult)
				} elseif (tEndPoint = "") {
					$$$HSTRACE("Removing PatientSearchMatch because gateway has no endpoint","HS.Message.PatientSearchMatch",tResult)
				} elseif (tGW.CacheType="ConsumeAndForward") {
					$$$HSTRACE("Removing PatientSearchMatch because gateway is of type ConsumeAndForward","HS.Message.PatientSearchMatch",tResult)
				}
				Do pResponse.Results.RemoveAt(tIndex)
				Continue
			}
			Set tResult.Gateway = tEndPoint
			Set tResult.RequestingUser=tNewRequest.RequestingUser
			Set tResult.RequestingUserRoles=tNewRequest.RequestingUserRoles
			
			//get list of information (document) types for the result and check if any match the filter (if any)
			Set tMRN = tResult.Facility_"^"_tResult.AssigningAuthority_"^"_tResult.MRN
			Set tTypes="",tType="",tInfoTypeMatch=0
			If tResult.InfoTypes'="" {
				//for secondary MPIs which supply InfoTypes
				For tI=1:1:$L(tResult.InfoTypes,",") {
					Set tType=$P(tResult.InfoTypes,",",tI)
					If $P(tType,".")'=""&&($D(tInfoTypeFilter(tType))||($D(tInfoTypeFilter($P(tType,"."))))) {Set tInfoTypeMatch=1 Quit}
				}
			} Else {
				FOR {
					Set tType=$O(^HS.InfoTypes(tMRN,tType)) Quit:tType=""
					Set tTypes=tTypes_$S(tTypes="":"",1:",")_tType
					Set tResult.InfoTypes=tTypes
					If $P(tType,".")'=""&&($D(tInfoTypeFilter(tType))||($D(tInfoTypeFilter($P(tType,"."))))) Set tInfoTypeMatch=1
				}
			}
			// If the user provided a filter, and this record does not match (and not secondary result) then reject
			IF $D(tInfoTypeFilter) { // user filter
				IF 'tInfoTypeMatch&&tResult.CanFilterInfoTypes {
					//This one fails the InfoType filter, so remove it
					$$$HSTRACE("Removing PatientSearchMatch which failed infotype filter","HS.Message.PatientSearchMatch",tResult)
					Do pResponse.Results.RemoveAt(tIndex)
					Set pResponse.InfoTypesFiltered=pResponse.InfoTypesFiltered+1
					Continue
				}
			}
		}  //end of for loop processing results
		
		Quit:$$$ISERR(tSC)

		//count results by MPIID before consent
		For tI=1:1:pResponse.Results.Count() IF $I(tMPIArray(pResponse.Results.GetAt(tI).MPIID,"Count"))

		// Consent Processing (if supplied and this is a "user" or "clinician" search)
		// or if we're searching on or maintaining a patient program that requires consent
		Set tProgramConsent=0
		If tNewRequest.Program'="",##Class(HS.Registry.Program).%OpenId(tNewRequest.Program).ConsentRequired Set tProgramConsent=1
		If 'tProgramConsent,tNewRequest.Membership'="",##Class(HS.Registry.Program).%OpenId(tNewRequest.Membership).ConsentRequired Set tProgramConsent=1
		If ..ConsentProcessor'="",$$$HSLicensed("Consent Management"), (tNewRequest.SearchMode="user")||(tNewRequest.SearchMode="clinician")||(tNewRequest.SearchMode="PIXPDQ_c")||tProgramConsent {
			// We pass the search response to the ConsentProcessor and take whatever we get back from that.
			If tNewRequest.SearchMode="clinician",'tProgramConsent {
				//if there's no program consent, then clinician mode consent is OK if there's a relationship
				Set tSC=##Class(HS.Registry.Person.User).ResolveUserClinician(.tClinicianId,tNewRequest.RequestingUser)
				Set:$$$ISOK(tSC) pResponse.ClinicianId=tClinicianId
			}
			Set pResponse.RequestId=tNewRequest.RequestId
			Set pResponse.RequestingUser=tNewRequest.RequestingUser
			Set pResponse.RequestingUserRoles=tNewRequest.RequestingUserRoles
			Set pResponse.RequestingForProxyUserID=tNewRequest.RequestingForProxyUserID
			Set pResponse.BreakTheGlass=tNewRequest.BreakTheGlass
			Set pResponse.ProgramConsent=tProgramConsent
			Set tSC = ..SendRequestSync(..ConsentProcessor,pResponse,.pResponse)
			Quit:$$$ISERR(tSC)
		} //end of consent processing
		
		//figure out which MPIIDs have had results filtered out
		//this will leave a results count in FCount for any MPIID remaining in the result set after filtering
		For tI=1:1:pResponse.Results.Count() IF $I(tMPIArray(pResponse.Results.GetAt(tI).MPIID,"FCount"))
		//check for MPIIDs that have been completely or partially filtered
		Set tMPIID="" For { Set tMPIID=$O(tMPIArray(tMPIID))  Quit:tMPIID=""
			IF '$D(tMPIArray(tMPIID,"FCount")) {Kill tMPIArray(tMPIID) Continue} //completely out
			IF tMPIArray(tMPIID,"Count")'=tMPIArray(tMPIID,"FCount") Set tMPIArray(tMPIID,"Filt")=1 //partially out
		}
		//Now sort the remaining MPIIDs by rank
		Set tMPIID="" For {Set tMPIID=$O(tMPIArray(tMPIID))  Quit:tMPIID=""  Set tMPISort(-tMPIArray(tMPIID,"Rank"),tMPIID)=""}
		//and correlate the remaining results by MPIID
		For tI=1:1:pResponse.Results.Count() {Set tMPIArray(pResponse.Results.GetAt(tI).MPIID,"Results",tI)=""}
		//prepare for grabbing relationships
		Set tRS=##class(%ResultSet).%New()
		Set tRS.ClassName="HS.Push.PatientClinicianRelationship"
		Set tRS.QueryName="ByPatientClinician"
		IF tNewRequest.RequestingForProxyID="" {
			//If there's no proxy, use the requestor's relationships
			Set tClinicianId=##Class(HS.Registry.Person.User).GetUserClinicianFromRequest(tNewRequest.RequestingUser)
		} Else {
			//otherwise, use the proxied user's relationships
			Set tClinicianId=tNewRequest.RequestingForProxyID
		}
		//Now, create the MPIID Matches in the response
		Set tMPICount=0
		Set tRank="" For { Set tRank=$O(tMPISort(tRank))  Quit:tRank=""
			Set tMPIID="" For { Set tMPIID=$O(tMPISort(tRank,tMPIID))  Quit:tMPIID=""
				Set tMPICount=tMPICount+1
				Set tMMatch=$$$NULLOREF
				If tHaveComposite {
					// PrimarySearch() already got a composite record from HSPI
					Set tMMatch=tResponse.MPIIDList.GetAt(pResponse.Results.GetAt($O(tMPIArray(tMPIID,"Results",""))).MPIIDListItem).%ConstructClone(1)
					Do tMMatch.SearchMatches.Clear()
				} ElseIf tUseComposite && (..MPIOperations'="") {
					// PrimarySearch() didn't go to HSPI yet; ask HSPI for a composite record
					Set tGCRRequest = ##class(HS.Message.GetCompositeRecordRequest).%New()
					Set tGCRRequest.MPIID = tMPIID
					Set tSC = ..SendRequestSync(..MPIOperations,tGCRRequest,.tComposite,..MPITimeout)
					If $$$ISOK(tSC) {
						Do ##class(HS.Message.PatientMPIMatch).CopyFrom(tComposite,.tMMatch)
						Set tMMatch.MPIID=tMPIID
						Set tMMatch.MRN=tMPIID
						Set tMMatch.AssigningAuthority="$HSPI"
						Set tMMatch.Facility="$HSPI"
						Set tMMatch.Addresses = tComposite.Addresses
						Set tMMatch.Telecoms = tComposite.Telecoms
					}
				}
				If '$IsObject(tMMatch) {
					Set tMMatch=##Class(HS.Message.PatientMPIMatch).%New()
					Set tMMatch.MPIID=tMPIID
					Set tPatient=##Class(HS.Registry.Patient).%OpenId(tMPIArray(tMPIID,"Best"))
					Set tMMatch.AssigningAuthority=tPatient.AssigningAuthority
					Set tMMatch.Facility=tPatient.FacilityGetObjectId()
					Set tMMatch.MRN=tPatient.MRN
					Set tSC=..LoadPatient(tPatient,.tMMatch) Quit:$$$ISERR(tSC)
				}
				Do ##class(HS.Types.RequestInfo).CopyFrom(tNewRequest,.tMMatch)
				Set tMMatch.Rank=-tRank
				IF $D(tMPIArray(tMPIID,"Filt")) Set tMMatch.ConsentFiltered=1
				Set:tNewRequest.Membership'=""&&##Class(HS.Registry.Program.Member).IsCurrentMember(tNewRequest.Membership,tMPIID) tMMatch.IsMember=1
				//add the relationships
				Set tSC=tRS.Execute(tMPIID,tClinicianId)
				While tRS.Next() {
					Do tMMatch.Relationships.Insert(tRS.Data("RelName"))
				}
				Do pResponse.MPIIDList.Insert(tMMatch)

				Set tI="" For { Set tI=$O(tMPIArray(tMPIID,"Results",tI))  Quit:tI=""
					Do tMMatch.SearchMatches.Insert(tI)
					Set:'tHaveComposite pResponse.Results.GetAt(tI).MPIID = tMPIID
					Set pResponse.Results.GetAt(tI).MPIIDListItem = pResponse.MPIIDList.Count()
				}
			}
			Quit:$$$ISERR(tSC)
		}
		Do ##class(HS.Types.RequestInfo).CopyFrom(tNewRequest,.pResponse)
		Set pResponse.ResultsCount=tMPICount
		Set:pResponse.RequestId="" pResponse.RequestId=tNewRequest.RequestId //return the initiating log ID
		Quit:$$$ISERR(tSC)
	} While (0)
	
	If ^stConfig("LogBool") { 
		set tMetric.Elapsed = $ZH - tStartZH
		Set tMetric.End = $ZDATETIME($H,3,1,3)
		Set tMetric.LineEnd = 570
		Set ltSC = tMetric.Save()
		Quit:$$$ISERR(ltSC)
	}
	
Exit
	Set:$IsObject($g(pResponse)) pResponse.ErrStatus=tSC
	$$$HSPerfEnd
	Quit tSC
Trap
	Set $ZT="",tSC=$$$EnsSystemError
	Goto Exit
]]></Implementation>
</Method>

<Method name="LoadPatient">
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pPatient:HS.Registry.Patient,&pPatientInfo:HS.Types.PatientInfo]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tSC=$$$OK
	Do {
		Set tI=""
		For{
			Set tAddr=pPatient.Addresses.GetNext(.tI)
			Quit:((tI="")||(tAddr=""))
			Kill tCopy Set tSC=##Class(HS.Types.Address).CopyFrom(tAddr,.tCopy) Quit:$$$ISERR(tSC)
			Do pPatientInfo.Addresses.Insert(tCopy)
			If tI=1 {
				Set pPatientInfo.Street=tAddr.StreetLine,pPatientInfo.City=tAddr.City,pPatientInfo.State=tAddr.State,pPatientInfo.Zip=tAddr.PostalCode
			}
		}
		Quit:$$$ISERR(tSC)
		Set tI=""
		For{
			Set tTel=pPatient.Telecoms.GetNext(.tI)
			Quit:((tI="")||(tTel=""))
			Set tUse=tTel.Use
			IF tUse="H"||(tUse="HP") {Set pPatientInfo.Telephone=tTel.PhoneNumberFull}
			ElseIF tUse="WP" {Set pPatientInfo.BusinessPhone=tTel.PhoneNumberFull}
			Kill tCopy Set tSC=##Class(HS.Types.Telecom).CopyFrom(tTel,.tCopy) Quit:$$$ISERR(tSC)
			Do pPatientInfo.Telecoms.Insert(tCopy)
		}
		Quit:$$$ISERR(tSC)
		Set tI=""
		For{
			Set tIdentifier=pPatient.Identifiers.GetNext(.tI)
			Quit:((tI="")||(tIdentifier=""))
			Kill tCopy Set tSC=##Class(HS.Types.Identifier).CopyFrom(tIdentifier,.tCopy) Quit:$$$ISERR(tSC)
			Do pPatientInfo.Identifiers.Insert(tCopy)
		}
		Quit:$$$ISERR(tSC)
		Set tI=""
		For{
			Set tName=pPatient.Names.GetNext(.tI)
			Quit:((tI="")||(tName=""))
			Kill tCopy Set tSC=##class(HS.Types.PersonName).CopyFrom(tName,.tCopy) Quit:$$$ISERR(tSC)
			Do pPatientInfo.Names.Insert(tCopy)
		}
		Quit:$$$ISERR(tSC)
		Set:pPatient.BirthDateTime'="" pPatientInfo.DOB=$ZDH(pPatient.BirthDateTime,3)
		Set pPatientInfo.BirthPlace= pPatient.BirthPlace
		Set pPatientInfo.BirthOrder= pPatient.BirthOrder
		Set pPatientInfo.EthnicGroup= pPatient.EthnicGroup
		Set pPatientInfo.CommunicationPreference= pPatient.CommunicationPreference
		Set pPatientInfo.Sex= pPatient.Gender
		Set pPatientInfo.Language= pPatient.Language
		Set pPatientInfo.MaritalStatus= pPatient.MaritalStatus
		Set pPatientInfo.MothersMaidenSurname= pPatient.MothersMaidenSurname
		Set pPatientInfo.LastName=pPatient.Name.Family
		Set pPatientInfo.FirstName=pPatient.Name.Given
		Set pPatientInfo.MiddleName=pPatient.Name.Middle
		Set pPatientInfo.Prefix=pPatient.Name.Prefix
		Set pPatientInfo.Suffix=pPatient.Name.Suffix
		Set pPatientInfo.Race= pPatient.Race
		Set pPatientInfo.ReligiousAffiliation= pPatient.ReligiousAffiliation
		Set pPatientInfo.SSN= pPatient.SSN
		Set pPatientInfo.VIP= pPatient.VIP
		Set pPatientInfo.CustomClassName= pPatient.CustomClassName
		Set pPatientInfo.CustomXMLString= pPatient.CustomXMLString
		Set pPatientInfo.CreatedOn = pPatient.CreatedOn
		Set pPatientInfo.Extension = pPatient.Extension
		Set pPatientInfo.MothersName = pPatient.MothersName
		Set pPatientInfo.FathersName = pPatient.FathersName
		Set pPatientInfo.SpousesName = pPatient.SpousesName
	} While 0
	Quit tSC
]]></Implementation>
</Method>

<Method name="PrimarySearch">
<FormalSpec><![CDATA[pRequest:HS.Message.PatientSearchRequest,&pResponse:HS.Message.PatientSearchResponse]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	#dim tSC As %Status
	Set tSC=$$$OK,$ZT="Trap"
	Do {
		set tNewRequest=pRequest.%ConstructClone(1)
		Set pResponse=##Class(HS.Message.PatientSearchResponse).%New()
		//if requesting a single MPIID
		IF tNewRequest.MPIID'="" {
			Set tMatch=##Class(HS.Message.PatientSearchMatch).%New()
			Set tMatch.MPIID=tNewRequest.MPIID, tMatch.RankOrScore=1000
			Do pResponse.Results.Insert(tMatch)
			Quit
		}
		If tNewRequest.Recent{
			Set tRecent=$G(^HS.RecentPatients(tNewRequest.RequestingUser))
			For tI=1:1:$LL(tRecent) {
				Set tMatch=##Class(HS.Message.PatientSearchMatch).%New()
				Set tMatch.MPIID=$LI(tRecent,tI), tMatch.RankOrScore=1001-tI
				Do pResponse.Results.Insert(tMatch)
			}
			Quit
		}
		//For request by MRN+AA
		Set tMRN=tNewRequest.MRN,tAA=tNewRequest.AssigningAuthority
		IF tMRN'="",tAA'="" {
			&SQL(Select MPIID into :tMPIID FROM HS_Registry.Patient WHERE MRN=:tMRN AND AssigningAuthority=:tAA)
			Quit:SQLCODE'=0
			Set tMatch=##Class(HS.Message.PatientSearchMatch).%New()
			Set tMatch.MPIID=tMPIID, tMatch.RankOrScore=1000
			Do pResponse.Results.Insert(tMatch)
			Quit
		}
		//search by analytics ID - only available in User search mode, with consent
		If tNewRequest.AnalyticsID'="", tNewRequest.SearchMode="user" {
			Quit:'$D(^HS.AnalyticsID("Out",tNewRequest.AnalyticsID),tMPIID)
			Set tMatch=##Class(HS.Message.PatientSearchMatch).%New()
			Set tMatch.MPIID=tMPIID, tMatch.RankOrScore=1000
			Do pResponse.Results.Insert(tMatch)
			Quit
		}
				
		//Check for search by deterministic identifier - in this case, we expect only one of these, and
		//will ignore everything else
		Set tDoExact=0
		#dim tIdent As HS.Types.Identifier
		For tI=1:1:tNewRequest.Identifiers.Count() {
			Set tIdent=tNewRequest.Identifiers.GetAt(tI)
			IF tIdent.AssigningAuthorityName'="",tIdent.Extension'="",tIdent.Use'="" {
				Set tType=##Class(HS.AssignAuth.IdentifierType).TypeIndexOpen(tIdent.Use)
				IF tType'="",tType.ExactMatch {Set tDoExact=1 Quit}
			}
		}
		If tDoExact {
			Set tUse=tIdent.Use,tAA=tIdent.AssigningAuthorityName,tEx=tIdent.Extension
			&SQL(Select Patient->MPIID into :tMPIID FROM HS_Registry_Patient.Identifier WHERE Use=:tUse AND Extension=:tEx AND AssigningAuthorityName=:tAA)
			Quit:SQLCODE'=0
			Set tMatch=##Class(HS.Message.PatientSearchMatch).%New()
			Set tMatch.MPIID=tMPIID, tMatch.RankOrScore=1000
			Do pResponse.Results.Insert(tMatch)
			Quit
		}
		
		IF ..MPIOperations'=""&&(tNewRequest.Relationship="")&&(tNewRequest.Program="") {Set tSC = ..SendRequestSync(..MPIOperations,tNewRequest,.pResponse,..MPITimeout) Quit}
		//do local registry search
		Set tMaxMatches = tNewRequest.MaxMatches
		Set:tMaxMatches<1||(tMaxMatches>..MaxMatches) tMaxMatches = ..MaxMatches
		Set tCond="", p=0
		Set tMaxMatches=+tMaxMatches	//prevent SQL injection
		Set tSQL="SELECT DISTINCT TOP "_tMaxMatches_" %EXACT(Pat.MPIID) FROM HS_Registry.Patient Pat"
		IF tNewRequest.Relationship'="" {
			//search by relationship
			Set tSQL=tSQL_",HS_Push.PatientClinicianRelationship R"
			Set tCond="Pat.MPIID=R.MPIID AND (IsNull(R.ExpirationDate,CURRENT_DATE)>=CURRENT_DATE) AND IsNull(R.StartDate,1)<=CURRENT_DATE"
			Do addCondition(.tCond,tNewRequest.RelationshipClinician,"(R.Clinician","=",.p)
			Set tCond=tCond_" OR (EXISTS (SELECT * FROM HS_Registry_ClinicianGroup.Member Mem WHERE R.ClinicianGroup = Mem.ClinicianGroupId"
			Do addCondition(.tCond,tNewRequest.RelationshipClinician,"Mem.ClinicianId","=",.p)
			Set tCond=tCond_")))"
			IF tNewRequest.Relationship'="Any" {
				Do addCondition(.tCond,tNewRequest.Relationship,"R.Relationship","=",.p)
			}
		}
		IF tNewRequest.Program'="" {
			//search by program
			Set tSQL=tSQL_",HS_Registry_Program.Member M"
			Set:tCond'="" tCond=tCond_" AND "
			Set tCond=tCond_" Pat.MPIID=M.MPIID AND (IsNull(M.ToTime,CURRENT_TIMESTAMP)>=CURRENT_TIMESTAMP)"
			Do addCondition(.tCond,tNewRequest.Program,"M.Program","=",.p)
		}
		Do addCondition(.tCond,tNewRequest.FirstName,"Pat.Name_Given","%STARTSWITH",.p)
		Do addCondition(.tCond,tNewRequest.LastName,"Pat.Name_Family","%STARTSWITH",.p)
		Do addCondition(.tCond,tNewRequest.DOB,"convert(DATE,Pat.birthdatetime)","=",.p)
		Do addCondition(.tCond,tNewRequest.Sex,"Pat.Gender","=",.p)
		Do addCondition(.tCond,tNewRequest.MRN,"Pat.MRN","=",.p)
		Do addCondition(.tCond,$TR(tNewRequest.SSN," _-"),"Pat.StrippedSSN","=",.p)
		Do addCondition(.tCond,tNewRequest.Facility,"Pat.Facility","=",.p)
		Set tWhere=tCond
		IF tNewRequest.Identifiers.Count() {
			Set tCond=""
			Set tIdentifier=tNewRequest.Identifiers.GetAt(1)
			Do addCondition(.tCond,tIdentifier.Use,"Use","=",.p)
			Do addCondition(.tCond,tIdentifier.Extension,"Extension","=",.p)
			Do addCondition(.tCond,tIdentifier.AssigningAuthorityName,"AssigningAuthorityName","=",.p)
			Do:tCond'="" addExists(.tWhere,tCond,"Identifier")
		}
		Set tPhone=$TR(tNewRequest.Telephone," _-().,/\")
		IF tPhone'="" {
			Set tCond=""
			Do addCondition(.tCond,"%"_tPhone_"%","HS_Registry.Patient_StripPhone(PhoneNumberFull)","LIKE",.p)
			Do addExists(.tWhere,tCond,"Telecom")
		}
		IF tNewRequest.Street_tNewRequest.City_tNewRequest.State_tNewRequest.Zip'="" {
			Set tCond=""
			Do addCondition(.tCond,tNewRequest.Street,"StreetLine","=",.p)
			Do addCondition(.tCond,tNewRequest.City,"City","=",.p)
			Do addCondition(.tCond,tNewRequest.State,"State","=",.p)
			Do addCondition(.tCond,tNewRequest.Zip,"PostalCode","=",.p)
			Do addExists(.tWhere,tCond,"Address")
		}
		Set:tWhere'="" tSQL=tSQL_" WHERE "_tWhere
		Set tRank=$S(p=0:500,tNewRequest.MRN'="":900,p>2:800,p=2:700,p=1:600,1:500)
		Set tStatement=##Class(%SQL.Statement).%New()
		Set tSC=tStatement.%Prepare(tSQL) Quit:$$$ISERR(tSC)
		Set tRes=tStatement.%Execute(p...)
		While tRes.%Next() {
			Set tMatch=##Class(HS.Message.PatientSearchMatch).%New()
			Set tMatch.MPIID=tRes.%GetData(1), tMatch.RankOrScore=tRank
			Do pResponse.Results.Insert(tMatch)
		}
		
	} While 0
Exit
	Quit tSC
Trap
	Set $ZT="",tSC=$$$EnsSystemError
	Goto Exit
	
	// Add conditions to our SQL where clause
addCondition(tCond,tValue,pField,pOp,pParams)
	Quit:tValue=""
	Set:tCond'="" tCond=tCond_" AND "
	Set tCond=tCond_"("_pField_" "_pOp_" ?)"
	Set pParams($I(pParams)) = tValue
	Quit

addExists(tWhere,tCond,tTable)
	Set:tWhere'="" tWhere=tWhere_" AND "
	Set tWhere=tWhere_"Exists(Select * from HS_Registry_Patient."_tTable_" WHERE Patient=Pat.ID AND "_tCond_")"
	Quit
]]></Implementation>
</Method>

<Method name="ProcessSecondaryMPISearch">
<Description>
Run a patient search through multiple MPIs</Description>
<FormalSpec><![CDATA[pRequest:HS.Message.PatientSecondarySearchRequest,&pResponse:HS.Message.PatientSearchResponse,pSecondaryOps]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	#dim tSC As %Status
	Set tSC = $$$OK
	Do {

		#dim tRequestList
		#dim tRq As Ens.CallStructure
		#dim tIndex As %Integer
		#dim tSucceeded As %Integer
		
		Set tSucceeded = 0
		Set tRequestList=$L(pSecondaryOps,",")
		// Invoke the MPI
		For tIndex = 1:1:tRequestList {
			// Construct a call structure
			Set tRq = ##class(Ens.CallStructure).%New()
			Set tRq.Request = pRequest
			Set tRq.TargetDispatchName = $P(pSecondaryOps,",",tIndex)
			Set tRequestList(tIndex) = tRq
		}
		
		// Issue multiple requests concurrently
		Set tSC = ..SendRequestSyncMultiple(.tRequestList, ..MPITimeout)
		Quit:$$$ISERR(tSC)
		
		Set pResponse=pRequest.PrimaryResponse
		
		For tIndex = 1:1:$L(pSecondaryOps,",") {
			// Process the responses
			Set tRq = tRequestList(tIndex)
			If $$$ISERR(tRq.ResponseCode) {
				Set tSC = $$$ADDSC(tSC, tRq.ResponseCode)
				Continue
			}
			
			#dim tThisResponse As HS.Message.PatientSearchResponse
			Set tThisResponse = tRq.Response
			
			// Handle the results
			If $G(pResponse)=$$$NULLOREF {
				// First set of results
				Set pResponse = tThisResponse
			} Else {
				// Subsequent results, we merge them
				For tJ = 1:1:tThisResponse.Results.Count() {
					#dim tMatch As HS.Message.PatientSearchMatch
					Set tMatch = tThisResponse.Results.GetAt(tJ)
					Do pResponse.Results.Insert(tMatch)
				}
			}
			
			Set tSucceeded = tSucceeded + 1
		}
		
		// Bail out if we didn't get at least 1 result
		Quit:'tSucceeded
		
	} While (0)
Exit
	Quit tSC
]]></Implementation>
</Method>

<Method name="AddUpdateHub">
<FormalSpec>pRequest:HS.Message.AddUpdateHubRequest,*pResponse:HS.Message.AddUpdateHubResponse</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	If ^stConfig("LogBool")  { 
		Set tMetric = ##class(Synthea.StressMetrics).%New()
		Set tMetric.Type = "AddUpdateHub"
		Set tMetric.ClassName = "Synthea.HS.Hub.MPI.Manager"
		Set tMetric.LineStart = 875
		Set tMetric.Start = $ZDATETIME($H,3,1,3)
		set tStartZH = $ZH
	}
	#dim tSC As %Status
	#dim tRequest As HS.Message.AddPatientRequest
	#dim tPatient As HS.Registry.Patient
	#dim tNewRequest As HS.Message.AddUpdateHubRequest
	Set tSC=$$$OK,$ZT="Trap"
	DO {
		set tNewRequest=pRequest.%ConstructClone(1)
		Do tNewRequest.NewResponse(.pResponse)
		Set:tNewRequest.LastEnteredOn="" tNewRequest.LastEnteredOn=$ZDT($H,3,1)
		Set tUpdateNotification = ##class(HS.Message.IDUpdateNotificationRequest).%New()
		Set tMPIID="",tMRN=tNewRequest.Facility_"^"_tNewRequest.AssigningAuthority_"^"_tNewRequest.MRN
		Set tIsHomeFacility=0
		IF tNewRequest.Addresses.Count() {
			//copy home address (or first address is no home address) into & from old individual properties, for backwards compatibility
			#dim tAddress As HS.Types.Address
			For tI=1:1:tNewRequest.Addresses.Count(),1 {
				Set tAddress=tNewRequest.Addresses.GetAt(tI)
				If (tAddress.Use = "H")||(tAddress.Use = "HP")||((tI=1)&&$G(tCycle)) {
					Set tNewRequest.City=tAddress.City,tNewRequest.State=tAddress.State,tNewRequest.Street=tAddress.StreetLine,tNewRequest.Zip=tAddress.PostalCode
					Quit
				}
				Set tCycle=1
			}
		} ElseIf tNewRequest.City_tNewRequest.State_tNewRequest.Street_tNewRequest.Zip'="" {
			Set tAddress=##Class(HS.Types.Address).%New()
			Set tAddress.City=tNewRequest.City, tAddress.State=tNewRequest.State,tAddress.StreetLine=tNewRequest.Street,tAddress.PostalCode=tNewRequest.Zip
			Do tNewRequest.Addresses.Insert(tAddress)
		}
		IF tNewRequest.Telecoms.Count() {
			//populate old properties & new for backwards compatibility
			#dim tTele As HS.Types.Telecom
			For tI=1:1:tNewRequest.Telecoms.Count() {
				Set tTele=tNewRequest.Telecoms.GetAt(tI)
				Set tUse=tTele.Use
				IF tUse="H"||(tUse="HP"),tTele.Email="" {Set tNewRequest.Telephone=tTele.PhoneNumberFull}
				ElseIF tUse="WP" {Set tNewRequest.BusinessPhone=tTele.PhoneNumberFull}
				If (tTele.PhoneNumberFull=$C(34,34)){
					Set:(tNewRequest.BusinessPhone="") tNewRequest.BusinessPhone=$C(34,34)
					Set:(tNewRequest.Telephone="") tNewRequest.Telephone=$C(34,34)
				}
				Set:tTele.Email=$C(34,34) tTele.Email=""
			}
		} Else {
			IF tNewRequest.Telephone'="" {
				Set tTele=##Class(HS.Types.Telecom).%New()
				Set tTele.Use="H",tTele.PhoneNumberFull=tNewRequest.Telephone
				Do tNewRequest.Telecoms.Insert(tTele)
			}
			If tNewRequest.BusinessPhone'="" {
				Set tTele=##Class(HS.Types.Telecom).%New()
				Set tTele.Use="WP",tTele.PhoneNumberFull=tNewRequest.BusinessPhone
				Do tNewRequest.Telecoms.Insert(tTele)
			}
		}
		Set tSC=..InvokePreProcessor(.tNewRequest)
		Quit:$$$ISERR(tSC)

		//Keep original extension XML until after preprocessor, then update Extension property
		If (tNewRequest.CustomClassName="HS.Local.SDA3.PatientExtension"){
			Set tReader = ##class(%XML.Reader).%New()
			Do tReader.OpenString(tNewRequest.CustomXMLString)
			Do tReader.Correlate("PatientExtension","HS.Local.SDA3.PatientExtension")
			Do tReader.Next(.tExtension, .tSC)
			Set:$$$ISOK(tSC) tNewRequest.Extension = tExtension
		}
		//Validate identifiers
		Set tLegacyIDs=##class(HS.Registry.Config).GetKeyValue("\General\LegacyPatientIdentifierTypeRestriction",0)
		For tI=1:1 {
			Set tIdentifier=tNewRequest.Identifiers.GetAt(tI) Quit:tIdentifier=""
			Set tType=tIdentifier.Use
			Continue:tType=""  //we allow in ones with no "Use", but they won't be useful
			Continue:",DL,DN,LN,PI,PPN,PT,RI,SN,XX,"[(","_tType_",") 
			If 'tLegacyIDs {
				Set tObj=##class(HS.AssignAuth.IdentifierType).%OpenId(tType)
				If $IsObject(tObj),tObj.Active,tObj.InSearchList Continue
			}
			$$$LOGALERT($$$Text("Bad Identifier Type, skipping")_": "_tType)
			Do tNewRequest.Identifiers.RemoveAt(tI)
			Set tI=tI-1		//Since we just removed an element, we want the next iteration to use the same index
		}
		Quit:$$$ISERR(tSC)
		//Validate facility
		Set tFacility=##Class(HS.Facility.Config).%OpenId(tNewRequest.Facility)
		IF tFacility'="" {
			//Check to make sure this is coming from the right gateway (except HomeFacility is OK from anywhere)
			IF tFacility.Gateway.Name'=tNewRequest.GatewayName,'tFacility.HomeFacility {Set tSC=$$$ERROR($$$HSErrFacilityGatewayMismatch,tFacility.FacilityCode,tNewRequest.GatewayName) QUIT}
			Set tIsHomeFacility=tFacility.HomeFacility
		}
		ElseIf tNewRequest.GatewayName '= "" {
			IF '..DynamicFacilityRegistration {Set tSC=$$$ERROR($$$HSErrFacilityNotFound,tNewRequest.Facility) QUIT}
			//Add Facility
			Set tFacility=##Class(HS.Facility.Config).%New()
			Set tSC=##Class(HS.Gateway.Config).FindByName(tNewRequest.GatewayName,.tGateway) QUIT:$$$ISERR(tSC)
			$$$HSTRACE("Adding Facility: "_tNewRequest.Facility_" to gateway: "_tNewRequest.GatewayName,"tGateway",tGateway)
			Set tSC=tFacility.GatewaySetObjectId(tGateway) Q:'tSC
			Set tFacility.FacilityCode=tNewRequest.Facility
			Set tFacility.Name=tNewRequest.Facility
			Set tFacility.AssigningAuthority=1
			$$$HSTRACE("Saving Facility","tFacility",tFacility)
			Set tSC=tFacility.%Save() QUIT:$$$ISERR(tSC)
		}
		If 'tNewRequest.DoDelete {
			Set tSC=##Class(HS.Message.AddPatientRequest).CopyFrom(tNewRequest,.tRequest,0)
			Set tRequest.AddOrUpdate=tNewRequest.AddOrUpdate
			For i=1:1:tNewRequest.Identifiers.Count() { 
				do tRequest.Identifiers.Insert(tNewRequest.Identifiers.GetAt(i))
			
				Do tUpdateNotification.Identifiers.Insert(tNewRequest.Identifiers.GetAt(i))
			 }
			For i=1:1:tNewRequest.Telecoms.Count() { do tRequest.Telecoms.Insert(tNewRequest.Telecoms.GetAt(i)) }
			For i=1:1:tNewRequest.Addresses.Count() { do tRequest.Addresses.Insert(tNewRequest.Addresses.GetAt(i)) }
			For i=1:1:tNewRequest.Names.Count() { do tRequest.Names.Insert(tNewRequest.Names.GetAt(i)) }
			Set:'(tNewRequest.BirthPlace.%IsNull()) tRequest.BirthPlace=tNewRequest.BirthPlace.%ConstructClone()
			Set:'(tNewRequest.FathersName.%IsNull()) tRequest.FathersName=tN0ewRequest.FathersName.%ConstructClone()
			Set:'(tNewRequest.MothersName.%IsNull()) tRequest.MothersName=tNewRequest.MothersName.%ConstructClone()
			Set:'(tNewRequest.SpousesName.%IsNull()) tRequest.SpousesName=tNewRequest.SpousesName.%ConstructClone()
			Set:'(tNewRequest.Extension.%IsNull()) tRequest.Extension = tNewRequest.Extension.%ConstructClone()
		}
		Quit:$$$ISERR(tSC)
		
		// Create assigning authority if not there
		If ..DynamicAssignAuthorityRegistration,tNewRequest.AssigningAuthority]"" {
			$$$HSTRACE("Adding Assigning Authority: "_tNewRequest.AssigningAuthority)
			Set tSC=##class(HS.AssignAuth.Config).RegisterAssigningAuthority("MR",tNewRequest.AssigningAuthority) Quit:$$$ISERR(tSC)
		}
		
		Set tPatient=##Class(HS.Registry.Patient).MRNIndexOpen(tNewRequest.MRN,tNewRequest.AssigningAuthority,tNewRequest.Facility)
		
		If ^stConfig("LogBool")  { 
			Set tMetric2 = ##class(Synthea.StressMetrics).%New()
			Set tMetric2.Type = "MPIRequest"
			Set tMetric2.ClassName = $THIS
			Set tMetric2.LineStart = 1014
			Set tMetric2.Start = $ZDATETIME($H,3,1,3)
			set tStartZH2 = $ZH
		}

		If tNewRequest.DoDelete {
			If $IsObject(tPatient) {
				Set tSC=..FlashResend(tPatient.AssigningAuthority,tPatient.FacilityGetObjectId(),tPatient.MPIID,tPatient.MRN)
			}
			Quit:$$$ISERR(tSC)
			If ..MPIOperations'="" {
				//Since the external matching engine interface expect the older Remove Patient Request, create that
				Set tSC=##Class(HS.Message.RemovePatientRequest).CopyFrom(tNewRequest,.tDRequest)
				Set tDResponse=##class(HS.Message.RemovePatientResponse).%New()
				Set tSC = ..SendRequestSync(..MPIOperations,tDRequest,.tDResponse,..MPITimeout)
				Quit:$$$ISERR(tSC)
				If 'tDResponse.Accepted {Set tSC=$$$HSError($$$HSErrCantDeletePatient,tMRN) Quit}
			}
			Set tMPIID=""
			If tPatient'="" {
				Set tMPIID=tPatient.MPIID
				Do ..AAResendQ(tMPIID)
				If ..PIXManager]"" {
					#; find the identifiers for the MPIID before we update them
					Set tIDUpdateNotification = ..UpdateNotificationGetPriorIdentifiers(tMPIID)
				}
				Set tSC = ..OnMRNDelete(tNewRequest.MRN,tNewRequest.AssigningAuthority,tMPIID, tPatient.%Id(),tNewRequest.Facility) Quit:$$$ISERR(tSC)
				If ..PIXManager]"" {
					/// the tIDUpdateNotification has the list of prior identifiers for notification
					Set tSC = ..CreateAndSendPIXNotification(tMPIID,tIDUpdateNotification)
				}
				Set:'##Class(HS.Registry.Patient).MPIIDIndexExists(tMPIID) tMPIID="" // so that we won't attempt an MPIID scope push
				If tIsHomeFacility {Set tSC=..Audit("D",tPatient,tNewRequest) Quit:$$$ISERR(tSC)}
			}
		} ElseIf tPatient="" {
			//AddPatient
			Set tSC=..AddPatient(.tRequest,tNewRequest,tIsHomeFacility) Quit:$$$ISERR(tSC)  Set tMPIID=tRequest.MPIID
			Set tNewRequest.DoMPIUpdate=1 // to trigger PIX notifications
		} ElseIf tNewRequest.DoMPIUpdate {
			//UpdatePatient
			Set tSC=..UpdatePatient(tPatient,.tRequest,tNewRequest,tIsHomeFacility) Quit:$$$ISERR(tSC)   Set tMPIID=tRequest.MPIID
		} Else {
			Set tMPIID=tPatient.MPIID
		}
		
		
		If ^stConfig("LogBool") { 
			set tMetric2.Elapsed = tStartZH2 - $ZH
			Set tMetric2.End = $ZDATETIME($H,3,1,3)
			Set tMetric2.LineEnd = 1064
			Set ltSC = tMetric2.Save()
			Quit:$$$ISERR(ltSC)
		}
		
		Set pResponse.MPIID=tMPIID
		// When doing Analytics integration, for Mini-reg or other cases which populate the patient registry
		// without creating SDA on an edge gateway, queue up a fetch
		If 'tNewRequest.DoDelete,  $$$AnalyticsFeed,'$D(^HS.AADBQ(tMPIID,"Resend")),'..HasFeedableMRNs(tMPIID) {
			Set ^HS.AADBQ(tMPIID,"Update","*PatientRegistry*^*")="U^Patient^0",^HS.AADBQ(tMPIID,"LastUpdate")=$H 
		}
		// HS 2009.1.2 - take the list of InfoTypes from AdditionalInfo and replace what is stored
		//  Note that an empty list will remove them all
		Set tInfoTypeList=tNewRequest.AdditionalInfo.GetAt("InfoTypes")
		Kill ^HS.InfoTypes(tMRN)
		//HS 2012.1 - when doing a delete, this additionalnfo won't be here, so nothing more will happen for infotypes
		If $l(tInfoTypeList) {
			For ti=1:1:$l(tInfoTypeList,",") {			
				Set tInfoType=$p(tInfoTypeList,",",ti)
				If tInfoType'="" Set ^HS.InfoTypes(tMRN,tInfoType)="" 
				If tInfoType[".",'$D(^HS.InfoTypesSub(tInfoType)) {Set ^HS.InfoTypesSub(tInfoType)=""}
			}
		}
		// If we've moved a visit, this will update the prior MRN's infotype list
		Set tInfoTypeList=tNewRequest.AdditionalInfo.GetAt("UpdatePriorInfoTypes")
		IF tInfoTypeList'="" {
			Set tPriorMRN=$P(tInfoTypeList,"^",1,3),tInfoTypeList=$P(tInfoTypeList,"^",4)
			Kill ^HS.InfoTypes(tPriorMRN)
			If $l(tInfoTypeList) {
				For ti=1:1:$l(tInfoTypeList,",") {			
					Set tInfoType=$p(tInfoTypeList,",",ti)
					If tInfoType'="" Set ^HS.InfoTypes(tPriorMRN,tInfoType)="" 
				}
			}
		}
		IF tNewRequest.LogReportingEvent {
			#dim tAggregation As HS.IHE.ATNA.Repository.Aggregation
			Set tAggregation=##class(HS.IHE.ATNA.Repository.Aggregation).Create("InboundMessage","",pRequest.RequestingGateway)
			Do tAggregation.SetUser(pRequest)
			Set tAggregation.EventSubType=tNewRequest.MessageType
			Do tAggregation.AddPatient(tNewRequest.Facility_"^"_tNewRequest.MRN_"^"_tNewRequest.AssigningAuthority,"MRN",tNewRequest.LastName_", "_tNewRequest.FirstName_" "_tNewRequest.MiddleName)
			Do tAggregation.AddPatient(tMPIID,"MPIID",tNewRequest.LastName_", "_tNewRequest.FirstName_" "_tNewRequest.MiddleName)
			Set tSC=tAggregation.RecordAudit(tAggregation)
		}
		//AAUpdateQ won't be here when doing a delete
		IF tNewRequest.FeedAnalytics,tNewRequest.AAUpdateQ.Count() {Set tSC=..AAUpdateQ(tNewRequest,tMPIID,tMRN) Quit:$$$ISERR(tSC)}
		IF tNewRequest.DoPush||(tNewRequest.DoFlash) {
			Set tNewRequest.MPIID=pResponse.MPIID
			Set tSC=..SendRequestSync(..PushEvaluator,tNewRequest,.pResponse)
		}
		If ..PIXManager]"",'tNewRequest.DoDelete,tNewRequest.DoMPIUpdate||(##class(HS.Registry.Config).GetKeyValue("\MPI\ForcePIXNotify",0)) {
			Set tSC = ..CreateAndSendPIXNotification(tMPIID,tUpdateNotification)
		}
		DO:$$$ISOK(tSC) ..InvokePostProcessor(tNewRequest,.pResponse)
	} While (0)
	
	If ^stConfig("LogBool") { 
		set tMetric.Elapsed = $ZH - tStartZH
		Set tMetric.End = $ZDATETIME($H,3,1,3)
		Set tMetric.LineEnd = 1100 
		Set ltSC = tMetric.Save()
		Quit:$$$ISERR(ltSC)
	}	
Exit
	Set pResponse.ErrStatus=tSC
	If $$$ISERR(tSC) {
		Set tErr=$system.Status.GetErrorText(tSC)
		$$$LOGERROR(tErr)
	}
	// Note: always return OK, else Ensemble thinks there is a system error and does not return pResponse
	Quit $$$OK
Trap
	Set $ZT="",tSC=$$$EnsSystemError
	Goto Exit
]]></Implementation>
</Method>

<Method name="AddPatient">
<FormalSpec><![CDATA[&pRequest:HS.Message.AddPatientRequest,pAddUpRequest:HS.Message.AddUpdateHubRequest,pIsHomeFacility]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	If ^stConfig("LogBool")  { 
		Set tMetric = ##class(Synthea.StressMetrics).%New()
		Set tMetric.Type = "AddPatient"
		Set tMetric.ClassName = "Synthea.HS.Hub.MPI.Manager"
		Set tMetric.LineStart = 1107
		Set tMetric.Start = $ZDATETIME($H,3,1,3)
		set tStartZH = $ZH
	}
	#define DeleteIfQuotes(%val) $S(%val=$C(34,34):"",1:%val)	//two double quotes mean delete the value
	Do {
		Set $ZT="Trap", tSC=$$$OK
		#dim tSC As %Status
		Set tPatient=##Class(HS.Registry.Patient).%New()
		Set tPatient.AdditionalInfo=pRequest.AdditionalInfo
		For tI=1:1:pRequest.Addresses.Count() {Set x=##Class(HS.Registry.Patient.Address).%New(),tSC=x.CopyFrom(pRequest.Addresses.GetAt(tI),.x) Quit:$$$ISERR(tSC)  Do tPatient.Addresses.Insert(x)}
		Quit:$$$ISERR(tSC)
		Set tI=""
		For{
			Set tPhone = pRequest.Telecoms.GetNext(.tI)
			Quit:(tI="")

			Set x=##Class(HS.Registry.Patient.Telecom).%New()
			If (tPhone.PhoneNumber=$C(34,34)){
				Set pRequest.%ClearFields=pRequest.%ClearFields_$S(pRequest.%ClearFields="":"",1:",")_"Telecoms"
				Do pRequest.Telecoms.RemoveAt(tI)
				Set tI=tI-1
				Continue
			}
			Set tSC=x.CopyFrom(tPhone,.x)
			Quit:$$$ISERR(tSC)
			Do tPatient.Telecoms.Insert(x)
		}
		Quit:$$$ISERR(tSC)
		For tI=1:1:pRequest.Identifiers.Count() {
			If (pRequest.Identifiers.GetAt(tI).Extension=$C(34,34)){
				Set pRequest.%ClearFields=pRequest.%ClearFields_$S(pRequest.%ClearFields="":"",1:",")_"Identifiers"
				Do tPatient.Identifiers.Clear()
				Do pRequest.Identifiers.Clear()
				Quit
			}
			Set x=##Class(HS.Registry.Patient.Identifier).%New()
			Set tSC=x.CopyFrom(pRequest.Identifiers.GetAt(tI),.x) Quit:$$$ISERR(tSC)
			Do tPatient.Identifiers.Insert(x)
		}
		Quit:$$$ISERR(tSC)
		For tI=1:1:pRequest.Names.Count() {Set x=##Class(HS.Registry.Patient.Name).%New(),tSC=x.CopyFrom(pRequest.Names.GetAt(tI),.x) Quit:$$$ISERR(tSC)  Do tPatient.Names.Insert(x)}
		Quit:$$$ISERR(tSC)
		Set tPatient.AssigningAuthority=pRequest.AssigningAuthority
		Set:((pRequest.DOB'="")&&(pRequest.DOB'=$C(34,34))) tPatient.BirthDateTime=$ZDT(pRequest.DOB,3) //note - DOB is a date, has no time
		Set tPatient.BirthPlace=..CopyAndHandleQuotes(pRequest.BirthPlace)
		Set tPatient.BirthOrder=$$$DeleteIfQuotes(pRequest.BirthOrder)
		Set tPatient.EthnicGroup=$$$DeleteIfQuotes(pRequest.EthnicGroup)
		Set tPatient.CommunicationPreference=$$$DeleteIfQuotes(pRequest.CommunicationPreference)
		Do tPatient.FacilitySetObjectId(pRequest.Facility)
		Set tPatient.Gender=$$$DeleteIfQuotes(pRequest.Sex)
		Set tPatient.Language=$$$DeleteIfQuotes(pRequest.Language)
		//Set tPatient.LastUpdated not needed
		Set tPatient.MaritalStatus=$$$DeleteIfQuotes(pRequest.MaritalStatus)
		Set tPatient.MothersMaidenSurname=$$$DeleteIfQuotes(pRequest.MothersMaidenSurname)
		Set tPatient.MRN=pRequest.MRN
		Set tPatient.Name.Family=$$$DeleteIfQuotes(pRequest.LastName)
		Set tPatient.Name.Given=$$$DeleteIfQuotes(pRequest.FirstName)
		Set tPatient.Name.Middle=$$$DeleteIfQuotes(pRequest.MiddleName)
		Set tPatient.Name.Prefix=$$$DeleteIfQuotes(pRequest.Prefix)
		Set tPatient.Name.Suffix=$$$DeleteIfQuotes(pRequest.Suffix)
		Set tPatient.Race=$$$DeleteIfQuotes(pRequest.Race)
		Set tPatient.ReligiousAffiliation=$$$DeleteIfQuotes(pRequest.ReligiousAffiliation)
		Set tPatient.SSN=$$$DeleteIfQuotes(pRequest.SSN)
		Set tPatient.VIP=$$$DeleteIfQuotes(pRequest.VIP)
		// do not use two double quotes - delete instruction
		Set:pRequest.DeathTime'=$C(34,34) tPatient.DeathTime=pRequest.DeathTime
		Set tPatient.DeathStatus = $$$DeleteIfQuotes(pRequest.DeathStatus)
		Set tPatient.CreatedOn=pRequest.CreatedOn
		Set:tPatient.CreatedOn="" tPatient.CreatedOn=pRequest.LastEnteredOn
		Set tPatient.CreatedBy=pRequest.CreatedBy
		Set:tPatient.CreatedBy="" tPatient.CreatedBy=pRequest.LastEnteredBy
		Set tPatient.LastEnteredOn=pRequest.LastEnteredOn
		Set tPatient.LastEnteredBy=pRequest.LastEnteredBy
		Set:'(pRequest.FathersName.%IsNull()) tPatient.FathersName=..CopyAndHandleQuotes(pRequest.FathersName)
		Set:'(pRequest.MothersName.%IsNull()) tPatient.MothersName=..CopyAndHandleQuotes(pRequest.MothersName)
		Set:'(pRequest.SpousesName.%IsNull()) tPatient.SpousesName=..CopyAndHandleQuotes(pRequest.SpousesName)
		Set tPatient.CustomClassName=pRequest.CustomClassName
		Set tPatient.CustomXMLString=pRequest.CustomXMLString
		Set:'(pRequest.Extension.%IsNull()) tPatient.Extension=pRequest.Extension
		IF ..MPIOperations'="" {
			//We are passing in a new AddOrUpdate property, used by mini-reg.  
			//= nil- current behavior (let it decide)
			//="F" - let it decide, but force an override of all fields (we have a complete record)
			//="U" - we expect it to update a specific MPIID record with our added MRN
			//="A" - we expect it to create a new MPIID for our MRN
			//SMB 7/25/2012 - for HSPI, tell it the MPIID if we deterministically know this from the MRN+AA
			// with this change, the HSPI behavior of U and F are identical
			If pRequest.MPIID="" {
				&SQL(Select MPIID INTO :tMPIID FROM HS_Registry.Patient WHERE AssigningAuthority = UPPER(:pRequest.AssigningAuthority) AND MRN = UPPER(:pRequest.MRN))
				Set:SQLCODE=0 pRequest.MPIID=tMPIID
			}
			//1254
			
			If ^stConfig("LogBool")  { 
				Set tMetric2 = ##class(Synthea.StressMetrics).%New()
				Set tMetric2.Type = "AddPatientRequest"
				Set tMetric2.ClassName = $THIS
				Set tMetric2.LineStart = 1244
				Set tMetric2.Start = $ZDATETIME($H,3,1,3)
				set tStartZH2 = $ZH
			}
			Set tSC = ..SendRequestSync(..MPIOperations,pRequest,.tResponse,..MPITimeout)			
			If ^stConfig("LogBool") { 
				set tMetric2.Elapsed = tStartZH2-$ZH
				Set tMetric2.End = $ZDATETIME($H,3,1,3)
				Set tMetric2.LineEnd = 1252
				Set ltSC = tMetric2.Save()
				Quit:$$$ISERR(ltSC)
			}
			
			$$$HSTRACE("Sent Add to MPI","tSC,pRequest,tResponse",tSC,pRequest,$G(tResponse))
			Quit:$$$ISERR(tSC)
			IF tResponse.PatientId="" {
				Set tSC=$$$ERROR($$$HSErrMPIIDNotReturned,..MPIOperations,pRequest.Facility_"^"_pRequest.AssigningAuthority_"^"_pRequest.MRN)
				Quit
			}
			//validation - if we have some other MPIID linked to a patient with the same AA & MRN, there's a problem
			&SQL(Select MPIID INTO :tMPIID FROM HS_Registry.Patient WHERE AssigningAuthority = UPPER(:pRequest.AssigningAuthority) AND MRN = UPPER(:pRequest.MRN))
			IF SQLCODE=0,tMPIID'=tResponse.PatientId {
				Set tSC=$$$ERROR($$$HSErrMPIIDInconsistent,..MPIOperations,tResponse.PatientId,pRequest.Facility_"^"_pRequest.AssigningAuthority_"^"_pRequest.MRN,tMPIID)
				Quit
			}
			Set pRequest.MPIID=tResponse.PatientId,tPatient.MPIID=pRequest.MPIID
			Set tSC=tPatient.%Save()
		} Else {
			//The lock is added to protect an unusual situation where simultaneous addupdate request comes in for
			// the same person at different facilities, and the person is new - it might not link the two records.
			Lock +^HS.Registry.Patient.MPIIDCount
			Try {
				Set tSC=..DetermineMPIID(.pRequest),tPatient.MPIID=pRequest.MPIID
				Set:$$$ISOK(tSC) tSC=tPatient.%Save()
			} catch ex {
				Set tSC = ex.AsStatus()
			}
			Lock -^HS.Registry.Patient.MPIIDCount
		}
		Quit:$$$ISERR(tSC)
		If pIsHomeFacility {
			Set tSC=..Audit("C",tPatient,pAddUpRequest)
		}
	} While (0)
	If ^stConfig("LogBool") { 
		set tMetric.Elapsed = $ZH - tStartZH
		Set tMetric.End = $ZDATETIME($H,3,1,3)
		Set tMetric.LineEnd = 1255
		Set ltSC = tMetric.Save()
		Quit:$$$ISERR(ltSC)
	}
Exit
	Quit tSC
Trap
	Set $ZT="",tSC=$$$EnsSystemError
	Goto Exit
]]></Implementation>
</Method>

<Method name="UpdatePatient">
<FormalSpec><![CDATA[pPatient:HS.Registry.Patient,&pRequest:HS.Message.AddPatientRequest,pAddUpRequest:HS.Message.AddUpdateHubRequest,pIsHomeFacility]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	If ^stConfig("LogBool")  { 
		Set tMetric = ##class(Synthea.StressMetrics).%New()
		Set tMetric.Type = "UpdatePatient"
		Set tMetric.ClassName = "Synthea.HS.Hub.MPI.Manager"
		Set tMetric.LineStart = 1268
		Set tMetric.Start = $ZDATETIME($H,3,1,3)
		set tStartZH = $ZH
	}
	#define DeleteIfQuotes(%val) $S(%val=$C(34,34):"",1:%val)	//two double quotes mean delete the value
	Do {
		Set $ZT="Trap", tSC=$$$OK
		#dim tSC As %Status
		Set tForceUpdate=(pRequest.AddOrUpdate'="")
		
		//serialize old data for audit, for home facility
		If pIsHomeFacility {
			Set tSC=pPatient.XMLExportToString(.tOldData,"BeforeUpdate","literal") Quit:$$$ISERR(tSC)
		}
		IF pRequest.MPIID="" {
			Set pRequest.MPIID=pPatient.MPIID
		} ELSEIF pRequest.MPIID'=pPatient.MPIID {
			Set tSC=$$$ERROR($$$HSErrMPIIDInconsistent,"UpdatePatient",pPatient.MPIID,pRequest.Facility_"^"_pRequest.AssigningAuthority_"^"_pRequest.MRN,pRequest.MPIID)
		}
		// Note -- for now, we're assuming that for multi-instance fields if there is any data then it replaces all instances.
		// For single instance fields if there is no data then we leave the field as is
		// (Except for insurance number, which replace only other insurance number identifiers.)
		If pRequest.AdditionalInfo.Count()>0 {
			Set tSC=pPatient.AdditionalInfo.Clear() Quit:$$$ISERR(tSC)
			Set pPatient.AdditionalInfo=pRequest.AdditionalInfo
		}
		If (pRequest.Addresses.Count()>0)||tForceUpdate { Set tSC=pPatient.Addresses.Clear() Quit:$$$ISERR(tSC) }
		If (pRequest.Telecoms.Count()>0)||tForceUpdate { Set tSC=pPatient.Telecoms.Clear() Quit:$$$ISERR(tSC) }
		If (pRequest.Names.Count()>0)||tForceUpdate { Set tSC=pPatient.Names.Clear() Quit:$$$ISERR(tSC) }
		For tI=1:1:pRequest.Addresses.Count() {Set x=##Class(HS.Registry.Patient.Address).%New(),tSC=x.CopyFrom(pRequest.Addresses.GetAt(tI),.x) Quit:$$$ISERR(tSC)  Do pPatient.Addresses.Insert(x)}
		Quit:$$$ISERR(tSC)
		Set tI=""
		For{
			Set tPhone = pRequest.Telecoms.GetNext(.tI)
			Quit:(tI="")

			Set x=##Class(HS.Registry.Patient.Telecom).%New()
			If (tPhone.PhoneNumber=$C(34,34)){
				Set pRequest.%ClearFields=pRequest.%ClearFields_$S(pRequest.%ClearFields="":"",1:",")_"Telecoms"
				Do pRequest.Telecoms.RemoveAt(tI)
				Set tI=tI-1
				Continue
			}
			Set tSC=x.CopyFrom(tPhone,.x)
			Quit:$$$ISERR(tSC)
			Do pPatient.Telecoms.Insert(x)
		}
		Quit:$$$ISERR(tSC)
		For tI=1:1:pRequest.Names.Count() {Set x=##Class(HS.Registry.Patient.Name).%New(),tSC=x.CopyFrom(pRequest.Names.GetAt(tI),.x) Quit:$$$ISERR(tSC)  Do pPatient.Names.Insert(x)}
		Quit:$$$ISERR(tSC)
		
		//How many identifiers are coming in with the request (vs. copied over from the patient)
		Set tNewIDCount = pRequest.Identifiers.Count()
		If ..IdentifierCompatibilityMode {
			// Replace insurance numbers if we have them, or if coming from mini-Reg.  Otherwise leave them as is.
			If tForceUpdate {
				Set tUpdateIdentifiers=1
			} Else {
				For tI=1:1:pRequest.Identifiers.Count() If pRequest.Identifiers.GetAt(tI).Use = "SN" Set tUpdateIdentifiers=1 Quit
			}
			If (('$G(tUpdateIdentifiers))&&(pRequest.Identifiers.Count()>0)) {
				Set tUpdateIdentifiers = 1
				For tI=1:1:pPatient.Identifiers.Count() {
					Set tIdentifier=pPatient.Identifiers.GetAt(tI)
					If tIdentifier.Use = "SN" {
						Set x=##Class(HS.Types.Identifier).%New(),tSC=x.CopyFrom(tIdentifier,.x) Quit:$$$ISERR(tSC)  
						Do pRequest.Identifiers.Insert(x)
					}
				}
			}
		}
		Else {
			If tForceUpdate||(pRequest.Identifiers.Count()>0) {
				Set tUpdateIdentifiers=1
			}
			// Only replace identifiers if we have a new identifier of the same Use.
			If pRequest.Identifiers.Count()>0{
				Kill tIDUses
				For tI=1:1:pRequest.Identifiers.Count(){
					Set tIDUses(" "_pRequest.Identifiers.GetAt(tI).Use)=1
				}
				For tI=1:1:pPatient.Identifiers.Count(){
					Set tPatIdent = pPatient.Identifiers.GetAt(tI)
					If '$G(tIDUses(" "_tPatIdent.Use)){	//copy the patient identifiers, if we don't already have one of that Use in the request
						Set tIdent = ##class(HS.Types.Identifier).%New()
						Set tSC = tIdent.CopyFrom(tPatIdent,.tIdent)
						Quit:$$$ISERR(tSC)
						Do pRequest.Identifiers.Insert(tIdent)
					}
				}
				Quit:$$$ISERR(tSC)
			}
		}
		If $G(tUpdateIdentifiers) {
			Set tSC=pPatient.Identifiers.Clear() Quit:$$$ISERR(tSC)
			For tI=1:1:pRequest.Identifiers.Count() {
				Set x=##Class(HS.Registry.Patient.Identifier).%New(),tSC=x.CopyFrom(pRequest.Identifiers.GetAt(tI),.x)
				Quit:$$$ISERR(tSC)
				If ((tNewIDCount=1)&&(x.Extension=$C(34,34))){
					Set pRequest.%ClearFields=pRequest.%ClearFields_$S(pRequest.%ClearFields="":"",1:",")_"Identifiers"
					Do pRequest.Identifiers.Clear()
					Quit
				}
				Do pPatient.Identifiers.Insert(x)
			}
		}
		Quit:$$$ISERR(tSC)
		
		Do pPatient.FacilitySetObjectId(pRequest.Facility)
		Set pPatient.MRN=pRequest.MRN
		Set pPatient.AssigningAuthority=pRequest.AssigningAuthority
		Set pPatient.MPIID=pRequest.MPIID
		Set pPatient.LastUpdated=+$H
		If pRequest.LastName_pRequest.FirstName_pRequest.MiddleName]""||tForceUpdate {
			Set pPatient.Name.Family=$$$DeleteIfQuotes(pRequest.LastName)
			Set pPatient.Name.Given=$$$DeleteIfQuotes(pRequest.FirstName)
			Set pPatient.Name.Middle=$$$DeleteIfQuotes(pRequest.MiddleName)
			Set pPatient.Name.Prefix=$$$DeleteIfQuotes(pRequest.Prefix)
			Set pPatient.Name.Suffix=$$$DeleteIfQuotes(pRequest.Suffix)
		}
		
		If (pRequest.DOB=$C(34,34)) { Set pPatient.BirthDateTime = "" }
		ElseIf ((pRequest.DOB'="")||(tForceUpdate)) {Set pPatient.BirthDateTime=$S(pRequest.DOB]"":$ZDT(pRequest.DOB,3),1:"") } //note - DOB is a date, has no time
		Set:('pRequest.BirthPlace.%IsNull())||tForceUpdate pPatient.BirthPlace=..CopyAndHandleQuotes(pRequest.BirthPlace)
		Set:pRequest.BirthOrder]""||tForceUpdate pPatient.BirthOrder=$$$DeleteIfQuotes(pRequest.BirthOrder)
		Set:pRequest.EthnicGroup]""||tForceUpdate pPatient.EthnicGroup=$$$DeleteIfQuotes(pRequest.EthnicGroup)
		Set:pRequest.CommunicationPreference]""||tForceUpdate pPatient.CommunicationPreference=$$$DeleteIfQuotes(pRequest.CommunicationPreference)
		Set:pRequest.Sex]""||tForceUpdate pPatient.Gender=$$$DeleteIfQuotes(pRequest.Sex)
		Set:pRequest.Language]""||tForceUpdate pPatient.Language=$$$DeleteIfQuotes(pRequest.Language)
		Set:pRequest.MaritalStatus]""||tForceUpdate pPatient.MaritalStatus=$$$DeleteIfQuotes(pRequest.MaritalStatus)
		Set:pRequest.MothersMaidenSurname]""||tForceUpdate pPatient.MothersMaidenSurname=$$$DeleteIfQuotes(pRequest.MothersMaidenSurname)
		Set:pRequest.Race]""||tForceUpdate pPatient.Race=$$$DeleteIfQuotes(pRequest.Race)
		Set:pRequest.ReligiousAffiliation]""||tForceUpdate pPatient.ReligiousAffiliation=$$$DeleteIfQuotes(pRequest.ReligiousAffiliation)
		Set:pRequest.SSN]""||tForceUpdate pPatient.SSN=$$$DeleteIfQuotes(pRequest.SSN)
		Set:pRequest.VIP]""||tForceUpdate pPatient.VIP=$$$DeleteIfQuotes(pRequest.VIP)
		Set:pRequest.DeathTime]""||tForceUpdate pPatient.DeathTime=$$$DeleteIfQuotes(pRequest.DeathTime)
		Set:pRequest.DeathStatus]""||tForceUpdate pPatient.DeathStatus = $$$DeleteIfQuotes(pRequest.DeathStatus)
		Set:pRequest.LastEnteredOn]"" pPatient.LastEnteredOn=pRequest.LastEnteredOn
		Set:pRequest.LastEnteredBy]"" pPatient.LastEnteredBy=pRequest.LastEnteredBy
		Set:pPatient.CreatedOn="" pPatient.CreatedOn=pRequest.CreatedOn
		Set:pPatient.CreatedOn="" pPatient.CreatedOn=pRequest.LastEnteredOn
		Set:pPatient.CreatedBy="" pPatient.CreatedBy=pRequest.CreatedBy
		Set:pPatient.CreatedBy="" pPatient.CreatedBy=pRequest.LastEnteredBy

		Set:'(pRequest.FathersName.%IsNull()) pPatient.FathersName=..CopyAndHandleQuotes(pRequest.FathersName)
		Set:'(pRequest.MothersName.%IsNull()) pPatient.MothersName=..CopyAndHandleQuotes(pRequest.MothersName)
		Set:'(pRequest.SpousesName.%IsNull()) pPatient.SpousesName=..CopyAndHandleQuotes(pRequest.SpousesName)

		Set:pRequest.CustomClassName]""||tForceUpdate pPatient.CustomClassName=pRequest.CustomClassName,pPatient.CustomXMLString=pRequest.CustomXMLString
		Set:'(pRequest.Extension.%IsNull()) pPatient.Extension=pRequest.Extension
		Set tSC=pPatient.%Save()
		Quit:$$$ISERR(tSC)
		IF ..MPIOperations'="" {
			If ^stConfig("LogBool")  { 
				Set tMetric2 = ##class(Synthea.StressMetrics).%New()
				Set tMetric2.Type = "UpdatePatientRequest"
				Set tMetric2.ClassName = $THIS
				Set tMetric2.LineStart = 1462
				Set tMetric2.Start = $ZDATETIME($H,3,1,3)
				set tStartZH2 = $ZH
			}
			Set tSC = ..SendRequestSync(..MPIOperations,pRequest,.tResponse,..MPITimeout)
			If ^stConfig("LogBool") { 
				set tMetric2.Elapsed = tStartZH2 - $ZH
				Set tMetric2.End = $ZDATETIME($H,3,1,3)
				Set tMetric2.LineEnd = 1474
				Set ltSC = tMetric2.Save()
				Quit:$$$ISERR(ltSC)
			}

			
			$$$HSTRACE("Sent Update to MPI","tSC,pRequest,tResponse",tSC,pRequest,$G(tResponse))
			Quit:$$$ISERR(tSC)
		} 
		If pIsHomeFacility {
			Set tSC=..Audit("U",pPatient,pAddUpRequest,tOldData)
		}
	} While (0)
		If ^stConfig("LogBool") { 
		set tMetric.Elapsed = $ZH - tStartZH
		Set tMetric.End = $ZDATETIME($H,3,1,3)
		Set tMetric.LineEnd = 1436
		Set ltSC = tMetric.Save()
		Quit:$$$ISERR(ltSC)
	}

Exit
	Quit tSC
Trap
	Set $ZT="",tSC=$$$EnsSystemError
	Goto Exit
]]></Implementation>
</Method>

<Method name="CopyAndHandleQuotes">
<Description><![CDATA[
Copies an object, replacing any properties equal to double quotes with an empty value<br>
Recurses on object properties, and handles array and list collections of both objects and datatypes]]></Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>pOriginal:%RegisteredObject</FormalSpec>
<ReturnType>%RegisteredObject</ReturnType>
<Implementation><![CDATA[
	//two double quotes mean delete the value
	#define DeleteIfQuotes(%val) $S(%val=$C(34,34):"",1:%val)
	Set tClassname = pOriginal.%ClassName(1)
	Set tCopy = $ClassMethod(tClassname,"%New")
	Set tPropName=""
	For{
		Set tPropName = $$$comMemberNext(tClassname,$$$cCLASSproperty,tPropName)
		Quit:(tPropName="")
		//don't try to copy or check calculated properties
		$$$comMemberKeyGetLvar(tCalculated,tClassname,$$$cCLASSproperty,tPropName,$$$cPROPcalculated)
		$$$comMemberKeyGetLvar(tPrivate,tClassname,$$$cCLASSproperty,tPropName,$$$cPROPprivate)
		Continue:(tCalculated||tPrivate)
		If $IsObject($Property(pOriginal,tPropName)){
			If $Property(pOriginal,tPropName).%Extends("%Collection.AbstractListOfDT"){
				Set tList = $Property(pOriginal,tPropName)
				Set tCopyList = $Property(tCopy,tPropName)
				For tIdx=1:1:tList.Count(){
					If (tList.GetAt(tIdx)'=$C(34,34)){
						Do tCopyList.Insert(tList.GetAt(tIdx))
					}
				}
			}
			ElseIf $Property(pOriginal,tPropName).%Extends("%Collection.AbstractListOfObj"){
				Set tList = $Property(pOriginal,tPropName)
				Set tCopyList = $Property(tCopy,tPropName)
				For tIdx=1:1:tList.Count(){
					Do tCopyList.Insert(..CopyAndHandleQuotes(tList.GetAt(tIdx)))
				}
			}
			ElseIf $Property(pOriginal,tPropName).%Extends("%Collection.AbstractArrayOfDT"){
				Set tIdx=""
				Set tArray = $Property(pOriginal,tPropName)
				Set tCopyArray = $Property(tCopy,tPropName)
				For{
					Set tInstance = tArray.GetNext(.tIdx)
					Quit:(tIdx="")
					Do:(tInstance'=$C(34,34)) tCopyArray.SetAt(tInstance,tIdx)
				}
			}
			ElseIf $Property(pOriginal,tPropName).%Extends("%Collection.AbstractArrayOfObj"){
				Set tIdx=""
				Set tArray = $Property(pOriginal,tPropName)
				Set tCopyArray = $Property(tCopy,tPropName)
				For{
					Set tInstance = tArray.GetNext(.tIdx)
					Quit:(tIdx="")
					Do tCopyArray.SetAt(..CopyAndHandleQuotes(tInstance),tIdx)
				}
			}
			Else{//recurse
				Set $Property(tCopy,tPropName) = ..CopyAndHandleQuotes($Property(pOriginal,tPropName))
			}
		}
		Else{
			Set $Property(tCopy,tPropName) = $$$DeleteIfQuotes($Property(pOriginal,tPropName))
		}
	}
	Quit tCopy
]]></Implementation>
</Method>

<Method name="DetermineMPIID">
<Description>
If no external patient matching engine, determine this directly from the registry</Description>
<FormalSpec><![CDATA[&pRequest:HS.Message.AddPatientRequest]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	#dim tSC As %Status
	#dim SQLCODE As %Integer
	Set tSC=$$$OK,$ZT="Trap"
	Do {
		If pRequest.MPIID="" {
			//First, search by MRN+AA without facility (if we have 'em)
			IF pRequest.MRN'=""&& (pRequest.AssigningAuthority'="") {
				&sql(SELECT MPIID INTO :tMPIID
					FROM HS_Registry.Patient
		 			WHERE AssigningAuthority = UPPER(:pRequest.AssigningAuthority)
					AND MRN = UPPER(:pRequest.MRN))
				IF SQLCODE=100 Set tMPIID="" //to get around nasty SQL behavior
				If (SQLCODE'=0) && (SQLCODE'=100) {
					Set tSC = $$$ERROR($$$SQLError,$Get(SQLCODE),$Get(%msg)) Quit
				}
		 		$$$HSTRACE("Trying Link by MRN+AA","SQLCODE,MPIID,MRN,AA",SQLCODE,tMPIID,pRequest.MRN,pRequest.AssigningAuthority)
			}
		} Else {
			Set tMPIID=pRequest.MPIID
		}
			
		// Check for deterministic identifiers, validating them
		#dim tIdent As HS.Types.Identifier
		For tI=1:1:pRequest.Identifiers.Count() {
			Set tIdent=pRequest.Identifiers.GetAt(tI)
			IF tIdent.AssigningAuthorityName=""||(tIdent.Extension="")||(tIdent.Use="") CONTINUE
			Set tType=##Class(HS.AssignAuth.IdentifierType).TypeIndexOpen(tIdent.Use)
			IF tType="" CONTINUE
			IF 'tType.ExactMatch CONTINUE
			Set tUse=tIdent.Use,tAA=tIdent.AssigningAuthorityName,tEx=tIdent.Extension
			&SQL(Select Patient->MPIID into :txMPIID FROM HS_Registry_Patient.Identifier WHERE Use=:tUse AND Extension=:tEx AND AssigningAuthorityName=:tAA)
			Set:SQLCODE'=0 txMPIID=""
			// Make sure the MPIID we found matches what we expect
			If txMPIID'="" {
				If tMPIID="",pRequest.AddOrUpdate'="A" {
					Set tMPIID=txMPIID
				} ElseIf (txMPIID'=tMPIID) { 
					Set tSC=$$$HSError($$$HSErrDuplicateIdentifier,tEx,txMPIID) Quit
				}
			}
		}
		Quit:$$$ISERR(tSC)
		
		If (pRequest.AddOrUpdate="A") { Set tMPIID= "" Quit } // Adding a new MPI ID
		Quit:tMPIID'=""  //got a deterministic match
		Quit:..DemographicLinkMode="Never" // No probablistic linking
		
		Set tSSN=$TR(pRequest.SSN," _-") Set:tSSN="" tSSN="*NOMATCH*"
		// Note: If several match, return the first
		//First try with name, address, and fuzzy DOB
		IF ..DemographicLinkMode="Probable" {
			&sql(SELECT MPIID INTO :tMPIID
					FROM HS_Registry.Patient P
			 		WHERE Name_Given = :pRequest.FirstName
			 		  AND Name_Family = :pRequest.LastName
			 		  AND Exists(Select * from HS_Registry_Patient.Address A Where P.ID=A.Patient AND A.City=:pRequest.City AND A.State=:pRequest.State AND A.StreetLine=:pRequest.Street AND A.PostalCode=:pRequest.Zip)
			 		  AND HS_Registry.Patient_FuzzyDateMatch(:pRequest.DOB,Cast(BirthDateTime As Date)) = 1)
			 	$$$HSTRACE("Trying Probable Link1","SQLCODE,MPIID,First,Last,Street,City,State,Zip,DOB",SQLCODE,tMPIID,pRequest.FirstName,pRequest.LastName,pRequest.Street,pRequest.City,pRequest.State,pRequest.Zip,pRequest.DOB)
			//Next, try with name, zip, DOB
			IF SQLCODE=100 {
				&sql(SELECT MPIID INTO :tMPIID
					FROM HS_Registry.Patient P
			 		WHERE Name_Given = :pRequest.FirstName
			 		  AND Name_Family = :pRequest.LastName
			 		  AND Exists(Select * from HS_Registry_Patient.Address A Where P.ID=A.Patient AND A.PostalCode=:pRequest.Zip)
			 		  AND Cast(BirthDateTime As Date) = :pRequest.DOB)
			 	$$$HSTRACE("Trying Probable Link2","SQLCODE,MPIID,First,Last,Zip,DOB",SQLCODE,tMPIID,pRequest.FirstName,pRequest.LastName,pRequest.Zip,pRequest.DOB)
			}
			//Next, try with last name and SSN
			IF SQLCODE=100 {
				&sql(SELECT MPIID INTO :tMPIID
					FROM HS_Registry.Patient P
			 		WHERE Name_Family = :pRequest.LastName AND StrippedSSN=:tSSN)
			 	$$$HSTRACE("Trying Probable Link3","SQLCODE,MPIID,Last,SSN",SQLCODE,tMPIID,pRequest.LastName,tSSN)
			}
			//Next, try with first name, DOB, and SSN
			IF SQLCODE=100 {
				&sql(SELECT MPIID INTO :tMPIID
					FROM HS_Registry.Patient P
			 		WHERE Name_Given = :pRequest.FirstName
			 		  AND Cast(BirthDateTime As Date) = :pRequest.DOB AND StrippedSSN=:tSSN)
			 	$$$HSTRACE("Trying Probable Link4","SQLCODE,MPIID,First,DOB,SSN",SQLCODE,tMPIID,pRequest.FirstName,pRequest.DOB,tSSN)
			}
	
			IF SQLCODE=100 Set tMPIID="" //to get around nasty SQL behavior
			
			If (SQLCODE'=0) && (SQLCODE'=100) {
				Set tSC = $$$ERROR($$$SQLError,$Get(SQLCODE),$Get(%msg))
			 }
		}
		IF ..DemographicLinkMode="Strict" {
			&sql(SELECT MPIID INTO :tMPIID
					FROM HS_Registry.Patient P
			 		WHERE Name_Given = :pRequest.FirstName
			 		  AND Name_Family = :pRequest.LastName
			 		  AND Exists(Select * from HS_Registry_Patient.Address A Where P.ID=A.Patient AND A.City=:pRequest.City AND A.State=:pRequest.State AND A.StreetLine=:pRequest.Street AND A.PostalCode=:pRequest.Zip)
			 		  AND Cast(BirthDateTime As Date)=:pRequest.DOB)
			//Next, try with name, zip, DOB
			IF SQLCODE=100 {
				&sql(SELECT MPIID INTO :tMPIID
					FROM HS_Registry.Patient P
			 		WHERE Name_Given = :pRequest.FirstName
			 		  AND Name_Family = :pRequest.LastName
			 		  AND Cast(BirthDateTime As Date) = :pRequest.DOB
			 		  AND Exists(Select * from HS_Registry_Patient.Address A Where P.ID=A.Patient AND A.PostalCode=:pRequest.Zip))
			}
			//Next, try with last name, ZIP, SSN and DOB
			IF SQLCODE=100 {
				&sql(SELECT MPIID INTO :tMPIID
					FROM HS_Registry.Patient P
			 		WHERE Name_Family = :pRequest.LastName
			 		  AND Cast(BirthDateTime As Date) = :pRequest.DOB
			 		  AND Exists(Select * from HS_Registry_Patient.Address A Where P.ID=A.Patient AND A.PostalCode=:pRequest.Zip)
			 		  AND StrippedSSN=:tSSN)
			}
			//Next, try with first name, ZIP, DOB, and SSN
			IF SQLCODE=100 {
				&sql(SELECT MPIID INTO :tMPIID
					FROM HS_Registry.Patient P
			 		WHERE Name_Given = :pRequest.FirstName
			 		  AND Cast(BirthDateTime As Date) = :pRequest.DOB
			 		  AND Exists(Select * from HS_Registry_Patient.Address A Where P.ID=A.Patient AND A.PostalCode=:pRequest.Zip)
					  AND StrippedSSN=:tSSN)
			}
	
			IF SQLCODE=100 Set tMPIID="" //to get around nasty SQL behavior

			If (SQLCODE'=0) && (SQLCODE'=100) {
				Set tSC = $$$ERROR($$$SQLError,$Get(SQLCODE),$Get(%msg))
			 }
		}
		 
	} While(0)

	IF tMPIID="" {
		IF '$D(^HS.Registry.Patient.MPIIDCount) Set ^HS.Registry.Patient.MPIIDCount=100000000
		Set tMPIID=$I(^HS.Registry.Patient.MPIIDCount)
	}
	Set pRequest.MPIID=tMPIID

Exit
	Quit tSC
Trap
	Set $ZT="",tSC=$$$EnsSystemError
	Goto Exit
]]></Implementation>
</Method>

<Method name="MergePatient">
<FormalSpec>pRequest:HS.Message.MergePatientRequest,*pResponse:HS.Message.MergePatientResponse</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	
	If ^stConfig("LogBool")  { 
		Set tMetric = ##class(Synthea.StressMetrics).%New()
		Set tMetric.Type = "MergePatient"
		Set tMetric.ClassName = $THIS
		Set tMetric.LineStart = 1721
		Set tMetric.Start = $ZDATETIME($H,3,1,3)
		set tStartZH = $ZH
	}
	Do {
		Set $ZT="Trap"
		#dim tSC As %Status = $$$OK
		Set pResponse=##class(HS.Message.MergePatientResponse).%New()
		Set tOldMRN=pRequest.Facility_"^"_pRequest.PriorAssigningAuthority_"^"_pRequest.PriorMRN
		Set tNewMRN=pRequest.Facility_"^"_pRequest.AssigningAuthority_"^"_pRequest.MRN
		Quit:tOldMRN=tNewMRN
		Set tSC=..InvokePreProcessor(.pRequest) Quit:$$$ISERR(tSC)

		#; maintain a reference to the prior patient so that we can pass it in to the OnMRNMerge
		Set tPriorPatient=##Class(HS.Registry.Patient).MRNIndexOpen(pRequest.PriorMRN,pRequest.PriorAssigningAuthority,pRequest.Facility)
		Set tPriorMPIID = $S($isObject(tPriorPatient):tPriorPatient.MPIID,1:"")
		If $IsObject(tPriorPatient) {
			Set tSC=..FlashResend(pRequest.PriorAssigningAuthority,pRequest.Facility,tPriorMPIID,pRequest.PriorMRN)
			Quit:$$$ISERR(tSC)
		}
		Set tSC=..MergeLink(pRequest,.pResponse) Quit:$$$ISERR(tSC)
		#; process program / relationship / consent updates
		If $IsObject(tPriorPatient) {
			#; if no prior patient is in the registry there couldn't be consent/programs/relationships assigned
			Set tTargetPatient=##Class(HS.Registry.Patient).MRNIndexOpen(pRequest.MRN,pRequest.AssigningAuthority,pRequest.Facility)
			$$$HSTRACE("Target Patient","pResponse,tTargetPatient,MRN,AA,FAC",pResponse,tTargetPatient,pRequest.MRN,pRequest.AssigningAuthority,pRequest.Facility)
			If $IsObject(tTargetPatient) {
				Set tSC=..FlashResend(pRequest.AssigningAuthority,pRequest.Facility,tTargetPatient.MPIID,pRequest.MRN)
				Quit:$$$ISERR(tSC)
			}
			Set tSC = ..OnMRNMerge(pRequest,tPriorMPIID,tTargetPatient.MPIID) Quit:$$$ISERR(tSC)
		}

		Merge ^HS.InfoTypes(tNewMRN)=^HS.InfoTypes(tOldMRN) kill ^HS.InfoTypes(tOldMRN)
		If ..MPIOperations'="" {
			//send merge to external patient matching engine
			//This has to be done after running OnMRNMerge, to avoid a possible timing problem.
			//The matching engine may send an async HS.Message.IDUpdateNotificationRequest.
			//If so, this must happen after completing OnMRNMerge.
		
			If ^stConfig("LogBool")  { 
				Set tMetric2 = ##class(Synthea.StressMetrics).%New()
				Set tMetric2.Type = "MPIMergeRequest"
				Set tMetric2.ClassName = $THIS
				Set tMetric2.LineStart = 1766
				Set tMetric2.Start = $ZDATETIME($H,3,1,3)
				set tStartZH2 = $ZH
			}
			Set tSC = ..SendRequestSync(..MPIOperations,pRequest,.pResponse,..MPITimeout)
			If ^stConfig("LogBool") { 
				set tMetric2.Elapsed = tStartZH2 - $ZH
				Set tMetric2.End = $ZDATETIME($H,3,1,3)
				Set tMetric2.LineEnd = 1774 
				Set ltSC = tMetric2.Save()
				Quit:$$$ISERR(ltSC)
			}
		
		}
		Set tSC=..InvokePostProcessor(pRequest,.pResponse)
		Quit
	} While (0)
	
	If ^stConfig("LogBool") { 
		set tMetric.Elapsed = $ZH - tStartZH
		Set tMetric.End = $ZDATETIME($H,3,1,3)
		Set tMetric.LineEnd = 1770
		Set ltSC = tMetric.Save()
		Quit:$$$ISERR(ltSC)
	}
Exit
	Quit tSC
Trap
	Set $ZT="",tSC=$$$EnsSystemError
	Goto Exit
]]></Implementation>
</Method>

<Method name="MergeLink">
<FormalSpec>pRequest:HS.Message.MergePatientRequest,*pResponse:HS.Message.MergePatientResponse</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Do {
		Set $ZT="Trap"
		#dim tSC As %Status
		#dim tPriorPatient As HS.Registry.Patient
		#dim tTargetPatient As HS.Registry.Patient
		Set tSC=$$$OK
		Set tPriorPatient=##Class(HS.Registry.Patient).MRNIndexOpen(pRequest.PriorMRN,pRequest.PriorAssigningAuthority,pRequest.Facility)
		Set tTargetPatient=##Class(HS.Registry.Patient).MRNIndexOpen(pRequest.MRN,pRequest.AssigningAuthority,pRequest.Facility)
		IF ..MPIOperations="" {
			//Where there is no external patient matching engine, do this ourselves
			Quit:tPriorPatient=""  //nothing to merge
			IF tTargetPatient="" {
			//If there's no patient with the target MRN, change the MRN of the prior one
				Set tPriorPatient.AssigningAuthority=pRequest.AssigningAuthority
				Set tPriorPatient.MRN=pRequest.MRN
				Set tSC=tPriorPatient.%Save()
				Set tTargetPatient=tPriorPatient
				Set tIDUpdateRequest = ..UpdateNotificationGetPriorIdentifiers(tPriorPatient.MPIID)
				Set tIDUpdateRequest.MPIID=tPriorPatient.MPIID
				Set tSC = ..UpdateMPIIDRequest(tIDUpdateRequest,.tIDUpdateResponse)
				Quit:$$$ISERR(tSC)
			} ElseIf tPriorPatient.MPIID'=tTargetPatient.MPIID {
				// Both the prior & target MRNs exist
				Set tTargetMPIID=tTargetPatient.MPIID, tPriorMPIID=tPriorPatient.MPIID
				#; 1st message move the MRN to the new MPI
				Set tIDUpdateRequest = ..UpdateNotificationGetPriorIdentifiers(tPriorPatient.MPIID)
				Set tIDUpdateRequest.Identifiers = tIDUpdateRequest.PriorIdentifiers,tIDUpdateRequest.PriorIdentifiers=""
				Set tIDUpdateRequest.MPIID=tTargetMPIID
				Set tIDUpdateRequest.PriorMPIID=tPriorMPIID
				Set tSC = ..UpdateMPIIDRequest(tIDUpdateRequest,.tIDUpdateResponse)
				Quit:$$$ISERR(tSC)

			}
			//last but not least delete the old one
			Set:tPriorPatient'=tTargetPatient tSC=tPriorPatient.%DeleteId(tPriorPatient.%Id())
			Set tIDUpdateRequest = ..UpdateNotificationGetPriorIdentifiers(tPriorPatient.MPIID)
			Set tIDUpdateRequest.Identifiers = tIDUpdateRequest.PriorIdentifiers,tIDUpdateRequest.PriorIdentifiers=""
			Set tSC = ..UpdateMPIIDRequest(tIDUpdateRequest,.tIDUpdateResponse)
			Quit:$$$ISERR(tSC)

		} Else {
			//Where there is an external matching engine, here we just clean up the patient registry
			//Any updating of MPIIDs will come later after we tell the matching engine about the merge				
			If tPriorPatient'="" {
				If tTargetPatient="" {
					//If there's no patient with the target MRN, change the MRN of the prior one
					Set tPriorPatient.AssigningAuthority=pRequest.AssigningAuthority
					Set tPriorPatient.MRN=pRequest.MRN
					Set tSC=tPriorPatient.%Save()	
				} Else {
					// If both prior and target exist, we delete the prior
					Set tSC=tPriorPatient.%DeleteId(tPriorPatient.%Id())
				}
			}
		}
	} While (0)
Exit
	Quit tSC
Trap
	Set $ZT="",tSC=$$$EnsSystemError
	Goto Exit
]]></Implementation>
</Method>

<Method name="RemovePatient">
<Description>
2012.1 - Deprecated.  Will be removed in a future version.  We now use an AddUpdateHub request for deletes</Description>
<FormalSpec>pRequest:HS.Message.RemovePatientRequest,*pResponse:HS.Message.RemovePatientResponse</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	If ^stConfig("LogBool")  { 
		Set tMetric = ##class(Synthea.StressMetrics).%New()
		Set tMetric.Type = "RemovePatient"
		Set tMetric.ClassName = $THIS
		Set tMetric.LineStart = 1870
		Set tMetric.Start = $ZDATETIME($H,3,1,3)
		set tStartZH = $ZH
	}
	Do {
		Set $ZT="Trap"
		#dim tSC As %Status
		Set tSC=..InvokePreProcessor(.pRequest) Quit:$$$ISERR(tSC)
		If ..MPIOperations'="" {
			
			If ^stConfig("LogBool")  { 
				Set tMetric2 = ##class(Synthea.StressMetrics).%New()
				Set tMetric2.Type = "MPIRemoveRequest"
				Set tMetric2.ClassName = $THIS
				Set tMetric2.LineStart = 1883
				Set tMetric2.Start = $ZDATETIME($H,3,1,3)
				set tStartZH2 = $ZH
			}
			Set tSC = ..SendRequestSync(..MPIOperations,pRequest,.pResponse,..MPITimeout)
			If ^stConfig("LogBool") { 
				set tMetric2.Elapsed = tStartZH2-$ZH
				Set tMetric2.End = $ZDATETIME($H,3,1,3)
				Set tMetric2.LineEnd = 1892
				Set ltSC = tMetric2.Save()
				Quit:$$$ISERR(ltSC)
			}

			
			Quit:$$$ISERR(tSC)||'pResponse.Accepted
		} Else {
			Set tSC=pRequest.NewResponse(.pResponse) 
			Quit:$$$ISERR(tSC)
		}
		Set tPatient=##Class(HS.Registry.Patient).MRNIndexOpen(pRequest.MRN,pRequest.AssigningAuthority,pRequest.Facility)
		If tPatient=$$$NULLOREF {
			Set pResponse.Accepted=0
		} Else {
			Do ..AAResendQ(tPatient.MPIID)
			If ..PIXManager]"" {
				#; find the identifiers for the MPIID before we update them
				Set tIDUpdateNotification = ..UpdateNotificationGetPriorIdentifiers(tPatient.MPIID)
			}
			Set pResponse.Accepted=1
			Set tMRN=pRequest.Facility_"^"_pRequest.AssigningAuthority_"^"_pRequest.MRN
			Kill ^HS.InfoTypes(tMRN)
			Set tSC=tPatient.%DeleteId(tPatient.%Id())
			If ..PIXManager]"" {
				/// the tIDUpdateNotification has the list of prior identifiers for notification
				Set tSC = ..CreateAndSendPIXNotification(tPatient.MPIID,tIDUpdateNotification)
			}

		}
		IF $$$ISOK(tSC),pResponse.Accepted{
			Set tSC=..InvokePostProcessor(pRequest,.pResponse)
		}
	} While (0)
	If ^stConfig("LogBool") { 
		set tMetric.Elapsed = $ZH - tStartZH
		Set tMetric.End = $ZDATETIME($H,3,1,3)
		Set tMetric.LineEnd = 1911
		Set ltSC = tMetric.Save()
		Quit:$$$ISERR(ltSC)
	}
Exit
	If $$$ISOK(tSC),'pResponse.Accepted {
		Set tMRN=pRequest.MRN_"^"_pRequest.AssigningAuthority_"^"_pRequest.Facility
		Set tSC=$$$HSError($$$HSErrCantDeletePatient,tMRN)
	}
	Quit tSC
Trap
	Set $ZT="",tSC=$$$EnsSystemError
	Goto Exit
]]></Implementation>
</Method>

<Method name="UpdateNotificationGetPriorIdentifiers">
<ClassMethod>1</ClassMethod>
<FormalSpec>pMPIID:%String</FormalSpec>
<ReturnType>HS.Message.IDUpdateNotificationRequest</ReturnType>
<Implementation><![CDATA[
	try {
		Set tResponse = ##class(HS.Message.IDUpdateNotificationRequest).%New()
		Set tResponse.MPIID = pMPIID
		Set tSearchRequest = ##class(HS.Message.PatientSearchRequest).%New()
		Set tSearchRequest.MPIID=pMPIID
		Set tSC = ..GetMPIID(tSearchRequest,.tSearchResponse)
		For tIdx =1:1:tSearchResponse.Results.Count() {
			Set tMatch = tSearchResponse.Results.GetAt(tIdx)
			If tIdx=1 Set tResponse.PatientDemographics = tMatch
			Set tIdentifier = ##class(HS.Types.Identifier).%New() 
			Set tIdentifier.Root=tMatch.AssigningAuthority
			Set tIdentifier.Extension=tMatch.MRN
			Do tResponse.PriorIdentifiers.Insert(tIdentifier)
		}
	} catch ex {
		Throw ex
	}
	quit tResponse
]]></Implementation>
</Method>

<Method name="CreateAndSendPIXNotification">
<FormalSpec>pMPIID,pUpdateNotification:HS.Message.IDUpdateNotificationRequest=""</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	try {
		Set tSC = $$$OK
		If '$IsObject(pUpdateNotification) {
			Set pUpdateNotification = ##class(HS.Message.IDUpdateNotificationRequest).%New()
		} 
		Set pUpdateNotification.MPIID=pMPIID
		For tIdx=1:1:pUpdateNotification.Identifiers.Count() {
			Set tIdentifier=pUpdateNotification.Identifiers.GetAt(tIdx)
			Set tIdent(tIdentifier.Root_" ",tIdentifier.Extension_" ")=""
		}
		Set tSearchRequest = ##class(HS.Message.PatientSearchRequest).%New()
		Set tSearchRequest.MPIID=pMPIID
		Set tSC = ..GetMPIID(tSearchRequest,.tSearchResponse)
		For tIdx = 1:1:tSearchResponse.Results.Count() {
			Set tMatch = tSearchResponse.Results.GetAt(tIdx)
			If tIdx=1 && '$IsObject(pUpdateNotification.PatientDemographics) Set pUpdateNotification.PatientDemographics = tMatch
			Set tIdentifier = ##class(HS.Types.Identifier).%New() 
			Set tIdentifier.Root=tMatch.AssigningAuthority
			Set tIdentifier.Extension=tMatch.MRN
			If $D(tIdent(tIdentifier.Root_" ",tIdentifier.Extension_" ")) Continue
			Set tIdent(tIdentifier.Root_" ",tIdentifier.Extension_" ")=""
			Do pUpdateNotification.Identifiers.Insert(tIdentifier)
			For tIdx2 = 1:1:tMatch.Identifiers.Count() {
				Set tIdentifier=tMatch.Identifiers.GetAt(tIdx2)
				If $D(tIdent(tIdentifier.Root_" ",tIdentifier.Extension_" ")) Continue
				Set tIdent(tIdentifier.Root_" ",tIdentifier.Extension_" ")=""
				Do pUpdateNotification.Identifiers.Insert(tIdentifier)
			}
		}
		$$$HSTRACE("Notification","pUpdateNotification,tSearchResponse",pUpdateNotification,tSearchResponse)
		Set tSC = ..SendRequestAsync(..PIXManager,pUpdateNotification)
	} catch ex {
		Set tSC = ex.AsStatus()
	}
	Quit tSC
]]></Implementation>
</Method>

<Method name="RecentPatientUpdateRequest">
<FormalSpec>pRequest:HS.Message.RecentPatientUpdateRequest,*pResponse:HS.Message.RecentPatientUpdateRequest</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Do {
		IF pRequest.MPIID'="" {
			//for this type of message, we're only passing in the MPIID, and will populate the
			//rest of the request from the patient registry
			Set tStatement=##Class(%SQL.Statement).%New()
			Set tSC=tStatement.%Prepare("Select %ID from HS_Registry.Patient WHERE MPIID=? ORDER By IsNull(Facility->Tier,99999),LastEnteredOnC DESC")
			Quit:$$$ISERR(tSC)
			Set tRes=tStatement.%Execute(pRequest.MPIID)
			IF tRes.%Next() {
				Set tId=tRes.%GetData(1)
				Set tPatient=##Class(HS.Registry.Patient).%OpenId(tId)
				Set tMatch=##Class(HS.Types.PatientSerial).%New()
				Set tMatch.MPIID=tPatient.MPIID
				Set:tPatient.BirthDateTime'="" tMatch.DOB=$ZDH(tPatient.BirthDateTime,3)
				Set tMatch.Sex=tPatient.Gender
				Set tMatch.LastName=tPatient.Name.Family
				Set tMatch.FirstName=tPatient.Name.Given
				Set tMatch.MiddleName=tPatient.Name.Middle
				Do pRequest.MPIIDList.Insert(tMatch)
			}
		}
		Set tSC= ##Class(HS.Hub.MPI.RecentViews).RecentPatientUpdateRequest(pRequest,.pResponse)
	} While (0)
Exit
	Quit tSC
Trap
	Set $ZT="",tSC=$$$EnsSystemError
	Goto Exit
]]></Implementation>
</Method>

<Method name="ExternalUpdateMPIIDRequest">
<Description>
Invoke pre and postprocessors when an inbound request is received from an external MPI to update the MPI ID for one or many MRN's</Description>
<FormalSpec>pRequest:HS.Message.IDUpdateNotificationRequest,*pResponse:HS.Message.AddUpdateHubResponse</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Try {
		Set tSC = $$$OK
		Set pResponse = ##class(HS.Message.AddUpdateHubResponse).%New()
		Set tSC=..InvokePreProcessor(.pRequest) Quit:$$$ISERR(tSC)		
		Set tSC=..UpdateMPIIDRequest(pRequest,.pResponse) Quit:$$$ISERR(tSC)
		Set tResponse=##class(Ens.Response).%New()	
		Set tSC=..InvokePostProcessor(pRequest,.tResponse)
	} Catch ex {
		Set tSC = ex.AsStatus()
	}

	Set pResponse.ErrStatus=tSC
	Quit tSC
]]></Implementation>
</Method>

<Method name="UpdateMPIIDRequest">
<Description>
An inbound request from the MPI to update the MPI ID for one or many MRN's</Description>
<FormalSpec>pRequest:HS.Message.IDUpdateNotificationRequest,*pResponse:HS.Message.AddUpdateHubResponse</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Try {
		Set tSC = $$$OK
		Set pResponse = ##class(HS.Message.AddUpdateHubResponse).%New()
		#; if we are sending out transactions from the pix manager get the demographics
		If ..PIXManager]"" {
			#; grab the patient demographics and prior identifiers
			Set tIDUpdateNotification = ..UpdateNotificationGetPriorIdentifiers($Select(pRequest.PriorMPIID]"":pRequest.PriorMPIID,1:pRequest.MPIID))
			$$$HSTRACE("tIDUpdateNotification","tIDUpdateNotification",tIDUpdateNotification)
			If '$IsObject(tIDUpdateNotification.PatientDemographics) {
				#; if the prior mpiid has no records, then the demographics will be empty, fetch demo's from new mpiid
				Set tIDUpdateDemographics = ..UpdateNotificationGetPriorIdentifiers(pRequest.MPIID)
				Set tIDUpdateNotification.PatientDemographics=tIDUpdateDemographics.PatientDemographics
			}
			Set pRequest.PatientDemographics = tIDUpdateNotification.PatientDemographics
			/// only update the prior identifiers if they weren't given
			Set:'pRequest.PriorIdentifiers.Count() pRequest.PriorIdentifiers=tIDUpdateNotification.PriorIdentifiers
		}

		#; only need to update the MPIID if it is different
		If pRequest.MPIID'=pRequest.PriorMPIID && (pRequest.PriorMPIID]"") {
			Set tHome=##class(HS.Facility.Config).GetHomeFacility()
			Set tSQL="SELECT ID FROM HS_Registry.Patient WHERE AssigningAuthority = ? AND MRN = ?"
			TSTART
			For tIdx = 1:1:pRequest.Identifiers.Count() {
				Set tIdentifier = pRequest.Identifiers.GetAt(tIdx)
				Set tRS = ##class(%SQL.Statement).%ExecDirect(,tSQL,tIdentifier.Root,tIdentifier.Extension)
				If 'tRS.SQLCODE {
					While tRS.%Next() {
						Set tPatient=##class(HS.Registry.Patient).%OpenId(tRS.ID)
						If tPatient.MPIID'=pRequest.MPIID {
							If tPatient.MPIID=pRequest.PriorMPIID {
								// Can only have one MRN for the home facility
								
								If tIdentifier.Root=tHome {
									&SQL(SELECT ID INTO :tId FROM HS_Registry.Patient WHERE MPIID=:pRequest.MPIID AND Facility = :tHome )
									If 'SQLCODE {
										Set tDPatient=##class(HS.Registry.Patient).%OpenId(tId)
										Set tSC=##class(HS.Registry.Patient).%DeleteId(tId)
										$$$ThrowOnError(tSC)
										Set tSC=..Audit("D",tDPatient,pRequest)
										$$$ThrowOnError(tSC)
									}
								}
							} Else {
								$$$LOGWARNING($$$FormatText($$$Text("MPI ID update expected ID %1 or %2 but found %3"),pRequest.PriorMPIID, pRequest.MPIID, tPatient.MPIID))
							}
							Set tPatient.MPIID = pRequest.MPIID
							Set tSC = tPatient.%Save()
							$$$ThrowOnError(tSC)
						}
					} 
				} Else {
					$$$LOGWARNING($$$FormatText($$$Text("MPI ID update for unknown MRN %1"),tIdentifier.Root_" - "_tIdentifier.Extension))	
				}
			}
			Set tSC = ..OnMPIUpdate(pRequest) $$$ThrowOnError(tSC)
			TCOMMIT
		}
		
		//Update any flash gateways.  Has to happen outside of transaction
		If pRequest.MPIID'=pRequest.PriorMPIID && (pRequest.PriorMPIID]"") {
			For tIdx = 1:1:pRequest.Identifiers.Count() {
				Set tIdentifier = pRequest.Identifiers.GetAt(tIdx)
				Set tRS = ##class(%SQL.Statement).%ExecDirect(,tSQL,tIdentifier.Root,tIdentifier.Extension)
				If 'tRS.SQLCODE {
					While tRS.%Next() {
						Set tPatient=##class(HS.Registry.Patient).%OpenId(tRS.ID)
						Set tSC=..FlashResend(tPatient.AssigningAuthority,tPatient.Facility.FacilityCode,tPatient.MPIID,tPatient.MRN)
					}
				}
			}
		}

		If ..PIXManager]"" {
			If pRequest.PriorMPIID'=pRequest.MPIID && (pRequest.PriorMPIID]"") {
				$$$HSTRACE("Send notification about MPI ID Update","pRequest",pRequest)
				#; send directly as CreateAndSend will get all identifiers - this is the notification of the moving identifiers
				Set tSC = ..SendRequestAsync(..PIXManager,pRequest)
				$$$ThrowOnError(tSC)
				#; need to send a notification about the prior mpiid
				Set tSearchRequest = ##class(HS.Message.PatientSearchRequest).%New()
				Set tSearchRequest.MPIID=pRequest.PriorMPIID
				Set tSC = ..GetMPIID(tSearchRequest,.tSearchResponse)
				$$$ThrowOnError(tSC)
				If tSearchResponse.Results.Count()=0 {
					Set tSearchRequest.MPIID=pRequest.MPIID
					Set tSC = ..GetMPIID(tSearchRequest,.tSearchResponse)
					$$$ThrowOnError(tSC)
				}
				Set tIDUpdateNotification = ##class(HS.Message.IDUpdateNotificationRequest).%New()
				Set tIDUpdateNotification.PatientDemographics = $S($IsObject(tSearchResponse.Results.GetAt(1)):tSearchResponse.Results.GetAt(1),1:##Class(HS.Message.PatientSearchMatch).%New())
				Set tSC = ..CreateAndSendPIXNotification(pRequest.PriorMPIID,tIDUpdateNotification)
				$$$ThrowOnError(tSC)
			}
			#; this is the notification of the identifiers currently on the mpi (after the update)
			Set tSC = ..CreateAndSendPIXNotification(pRequest.MPIID)
			$$$ThrowOnError(tSC)
		}
	} Catch ex {
		Set tSC = ex.AsStatus()
	}
	If $$$ISERR(tSC) {TROLLBACK}
	Set pResponse.ErrStatus=tSC
	Quit tSC
]]></Implementation>
</Method>

<Method name="FlashResend">
<FormalSpec>pAA,pFac,pMPIID,pMRN</FormalSpec>
<Implementation><![CDATA[
	Set tSC = $$$OK
	Try {	
		Quit:""=..PushEvaluator
		Set tRequest=##class(HS.Message.FlashResendRequest).%New()
		Set tRequest.AssigningAuthority=pAA
		Set tRequest.Facility=pFac
		Set tRequest.MPIID=pMPIID
		Set tRequest.MRN=pMRN
		Set tSC=..SendRequestSync(..PushEvaluator,tRequest)
	} Catch ex {
		Set tSC = ex.AsStatus()
	}
	Quit tSC
]]></Implementation>
</Method>

<Method name="OnMRNDelete">
<Description>
Called when an MRN is deleted.</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>pMRN:%String,pAA:%String,pMPIID:%String,pPatientId:%String,pFacility</FormalSpec>
<Implementation><![CDATA[
	Try {	
		Set tSC = $$$OK
		TSTART
		Set tSC=##class(HS.Registry.Patient).%DeleteId(pPatientId) Quit:$$$ISERR(tSC)
		Set tSC = ##class(HS.Consent.Policy.MPIPatient).MRNDelete(pMRN,pAA,pMPIID) Quit:$$$ISERR(tSC)
		// For programs and relationships, an MRN delete is the same as a merge with no target
		Set tRequest=##class(HS.Message.MergePatientRequest).%New()
		Set tRequest.PriorMRN=pMRN
		Set tRequest.PriorAssigningAuthority=pAA
		Set tSC = ##Class(HS.Push.PatientClinicianRelationship).MRNMerge(tRequest,pMPIID,"") Quit:$$$ISERR(tSC) 
		Set tSC = ##class(HS.Registry.Program.Member).MRNMerge(tRequest,pMPIID,"") Quit:$$$ISERR(tSC)
		Set tSC = ##class(HS.MPI.SecondaryQueryCache).MRNDelete(pMRN,pAA,pFacility,pMPIID) Quit:$$$ISERR(tSC)

		// Check if the MPIID still exists after the MRN delete.  It will not if the MRN being deleted was the last one.
		&SQL(Select ID from HS_Registry.Patient WHERE MPIID=:pMPIID)
		If SQLCODE=100 {
			// If MPIID no longer exists, remove the MPI based Consent, Relationship, and Program Membership data.
			Set tSC = ##class(HS.Push.PatientClinicianRelationship).MPIDelete(pMPIID) Quit:$$$ISERR(tSC)
			Set tSC = ##class(HS.Registry.Program.Member).MPIDelete(pMPIID) Quit:$$$ISERR(tSC)
			Set tSC = ##class(HS.Consent.Policy.MPIPatient).MPIDelete(pMPIID) Quit:$$$ISERR(tSC)
		}
		
		Do ..AAResendQ(pMPIID)
	} Catch ex {
		Set tSC = ex.AsStatus()
	}
	IF $$$ISERR(tSC) {TROLLBACK} Else {TCOMMIT}
	Quit tSC
]]></Implementation>
</Method>

<Method name="OnMRNMerge">
<Description>
Called when one MRN is merged into another to update cohorts / consent</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>pRequest:HS.Message.MergePatientRequest,pPriorMPIID:%String,pTargetMPIID:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	try {
		Set tSC = $$$OK
		TSTART
		#; if the MPI ID is changing call OnMPIUpdate
		Set tSC = ##Class(HS.Consent.Policy.MPIPatient).MRNMerge(pRequest,pPriorMPIID,pTargetMPIID) Quit:$$$ISERR(tSC) 
		Set tSC = ##Class(HS.Push.PatientClinicianRelationship).MRNMerge(pRequest,pPriorMPIID,pTargetMPIID) Quit:$$$ISERR(tSC) 
		Set tSC = ##class(HS.Registry.Program.Member).MRNMerge(pRequest,pPriorMPIID,pTargetMPIID) Quit:$$$ISERR(tSC)
		Set tSC = ##class(HS.MPI.SecondaryQueryCache).MRNMerge(pRequest,pPriorMPIID,pTargetMPIID) Quit:$$$ISERR(tSC)
		// Check if the PriorMPIID still exists after the MRN merge.  It will not if the MRN being merged was the last one.
		&SQL(Select ID from HS_Registry.Patient WHERE MPIID=:pPriorMPIID)
		If SQLCODE=100 {
			// If MPIID no longer exists, remove the MPI based Consent, Relationship, and Program membership data.
			Set tSC = ##class(HS.Push.PatientClinicianRelationship).MPIDelete(pPriorMPIID) Quit:$$$ISERR(tSC)
			Set tSC = ##class(HS.Registry.Program.Member).MPIDelete(pPriorMPIID) Quit:$$$ISERR(tSC)
			Set tSC = ##class(HS.Consent.Policy.MPIPatient).MPIDelete(pPriorMPIID) Quit:$$$ISERR(tSC)
		}
		
		Do:pPriorMPIID'=pTargetMPIID ..AAResendQ(pPriorMPIID),..AAResendQ(pTargetMPIID)
	} Catch ex {
		Set tSC = ex.AsStatus()
	}
	IF $$$ISERR(tSC) {TROLLBACK} Else {TCOMMIT}
	Quit tSC
]]></Implementation>
</Method>

<Method name="OnMPIUpdate">
<Description>
Updating the MPI ID from one value to another </Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>pIDUpdateRequest:HS.Message.IDUpdateNotificationRequest=""</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Quit:pIDUpdateRequest.MPIID=pIDUpdateRequest.PriorMPIID $$$OK
	#; update consent policies, relationships, and programs
	Set tSC=##Class(HS.Consent.Policy.MPIPatient).MPIUpdate(pIDUpdateRequest) Quit:$$$ISERR(tSC) tSC
	Set tSC = ##Class(HS.Push.PatientClinicianRelationship).MPIUpdate(pIDUpdateRequest) Quit:$$$ISERR(tSC) tSC
	Set tSC = ##class(HS.Registry.Program.Member).MPIUpdate(pIDUpdateRequest) Quit:$$$ISERR(tSC) tSC
	Set tSC = ##class(HS.MPI.SecondaryQueryCache).MPIUpdate(pIDUpdateRequest) Quit:$$$ISERR(tSC) tSC
	// Check if the PriorMPIID still exists after the MPIUpdate.  
	// If the update moved MRNs to another MPIID, the PriorMPIID may no longer exist
	&SQL(Select ID from HS_Registry.Patient WHERE MPIID=:pIDUpdateRequest.PriorMPIID)
	If SQLCODE=100 {
		// If MPIID no longer exists, remove the MPI based Consent, Relationship, and Program membership data.
		Set tSC = ##class(HS.Push.PatientClinicianRelationship).MPIDelete(pIDUpdateRequest.PriorMPIID) Quit:$$$ISERR(tSC)
		Set tSC = ##class(HS.Registry.Program.Member).MPIDelete(pIDUpdateRequest.PriorMPIID) Quit:$$$ISERR(tSC)
		Set tSC = ##class(HS.Consent.Policy.MPIPatient).MPIDelete(pIDUpdateRequest.PriorMPIID) Quit:$$$ISERR(tSC)
	}
	Do ..AAResendQ(pIDUpdateRequest.PriorMPIID),..AAResendQ(pIDUpdateRequest.MPIID)
	Quit tSC
]]></Implementation>
</Method>

<Method name="Audit">
<Description>
event action - C - create, U - Update, D - Delete</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>pEventAction,pPatient:HS.Registry.Patient,pRequest:HS.Types.RequestInfo,pOldData:%String=""</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tSC=$$$OK
	Do {
		#dim tAggregation As HS.IHE.ATNA.Repository.Aggregation
		Set tAggregation=##class(HS.IHE.ATNA.Repository.Aggregation).Create("Patient Record",.pInitiatingLogID,,pEventAction)
		DO tAggregation.SetUser(pRequest)
		Set tTag=$Case(pEventAction,"C":"Patient","D":"Patient",:"AfterUpdate")
		Set tSC=pPatient.XMLExportToString(.tPatientData,tTag,"literal") Quit:$$$ISERR(tSC)
		If pEventAction="C" {Set tDetails="<Create>"_tPatientData_"</Create>"}
		ElseIf pEventAction="U" {Set tDetails="<Update>"_pOldData_tPatientData_"</Update>"}
		Else {Set tDetails="<Delete>"_tPatientData_"</Delete>"}
		Set tMRN=pPatient.Facility.FacilityCode_"^"_pPatient.MRN_"^"_pPatient.AssigningAuthority
		Set tName=pPatient.Name.Family_", "_pPatient.Name.Given
		Set:pPatient.Name.Middle'="" tName=tName_", "_pPatient.Name.Middle
		Set tAggregation.Criteria=tDetails
		Do tAggregation.AddPatient(tMRN,"MRN",tName)
		Set tSC= tAggregation.RecordAudit(tAggregation)
	} While 0
	Quit tSC
]]></Implementation>
</Method>

<Method name="AAUpdateQ">
<ClassMethod>1</ClassMethod>
<FormalSpec>pRequest,pMPIID,pMRN</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tSC=$$$OK,$ZT="Trap"
	//The shared lock is just to protect this from the snapshot copying of the queue
	Lock +^HS.AADBQ(pMPIID)
	Do {
		//First, process resends
		Set tKey="R",tFac=pRequest.Facility
		For {
			Set tVal=pRequest.AAUpdateQ.GetNext(.tKey) Quit:$E(tKey)'="R"
			//key=R^facility^AA^medrec#
			Set tPat=##Class(HS.Registry.Patient).MRNIndexOpen($P(tKey,"^",4),$P(tKey,"^",3),$P(tKey,"^",2))
			If '$IsObject(tPat) CONTINUE
			Do ..AAResendQNonLock(tPat.MPIID,1)
		}
		Quit:$D(^HS.AADBQ(pMPIID,"Resend"))  //no point in continuing if we're going to do a full resend
		//next, process all inserts, updates, deletes
		For tAction="I","U","D" {
			set tKey=tAction
			For {
				Set tVal=pRequest.AAUpdateQ.GetNext(.tKey) Quit:$E(tKey)'=tAction
				//key=I or U or D^streamlettype, val is a comma separated list of streamlet IDs_"^"_hasencflag, ending in comma
				Set tType=$P(tKey,"^",2)
				For tI=1:1:$L(tVal,",")-1 {
					Set tItem=$P(tVal,",",tI),tTag=pRequest.Facility_"^"_$P(tItem,"^"),tHasEnc=$P(tItem,"^",2)
					If tAction="I" {Set ^HS.AADBQ(pMPIID,"Update",tTag)="I^"_tType_"^"_tHasEnc,^HS.AADBQ(pMPIID,"LastUpdate")=$H Continue} //for inserts
					//for inserts and deletes, first check for pending moves
					If tAction="D" {  //for deletes
						//if not pending, just flag as delete
						If '$D(^HS.AADBQ(pMPIID,"Update",tTag),tUp) {Set ^HS.AADBQ(pMPIID,"Update",tTag)="D^"_tType_"^"_tHasEnc,^HS.AADBQ(pMPIID,"LastUpdate")=$H}
						//discard pending insert if we're just gonna delete it
						ElseIf $P(tUp,"^")="I"  {Kill ^HS.AADBQ(pMPIID,"Update",tTag)}
						//change pending update to delete
						ElseIf $P(tUp,"^")="U" {Set $P(tUp,"^")="D",^HS.AADBQ(pMPIID,"Update",tTag)=tUp,^HS.AADBQ(pMPIID,"LastUpdate")=$H}
						Continue
					}
					//for updates
					//if not pending, just flag as update
					If '$D(^HS.AADBQ(pMPIID,"Update",tTag),tUp) {Set ^HS.AADBQ(pMPIID,"Update",tTag)="U^"_tType_"^"_tHasEnc,^HS.AADBQ(pMPIID,"LastUpdate")=$H}
					//change pending insert to update
					ElseIf $P(tUp,"^")="I" {Set $P(tUp,"^")="U",^HS.AADBQ(pMPIID,"Update",tTag)=tUp,^HS.AADBQ(pMPIID,"LastUpdate")=$H}
					//can't have a pending delete if we're updating it
				}
			}
		}
	} While 0
Exit
	Lock -^HS.AADBQ(pMPIID)
	Quit tSC
Trap
	Set $ZT="",tSC=$$$EnsSystemError
	Goto Exit
]]></Implementation>
</Method>

<Method name="AAResendQ">
<Description>
pNoCheck avoids a redundant check to see if we're doing analytics feeding</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>pMPIID,pNoCheck=0,pPriority=2</FormalSpec>
<Implementation><![CDATA[
	IF pNoCheck||($$$AnalyticsFeed) {
		Lock +^HS.AADBQ(pMPIID)
		Set ^HS.AADBQ(pMPIID,"Resend")="", ^HS.AADBQ(pMPIID, "LastUpdate") = $H, ^HS.AADBQ(pMPIID, "Priority") = pPriority
		Kill ^HS.AADBQ(pMPIID,"Update")
		Lock -^HS.AADBQ(pMPIID)
	}
]]></Implementation>
</Method>

<Method name="AAResendQNonLock">
<Description>
Nonlock version of AAResendQ</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>pMPIID,pNoCheck=0,pPriority=2</FormalSpec>
<Implementation><![CDATA[
	IF pNoCheck||($$$AnalyticsFeed) {
		Set ^HS.AADBQ(pMPIID,"Resend")="", ^HS.AADBQ(pMPIID, "LastUpdate") = $H, ^HS.AADBQ(pMPIID, "Priority") = pPriority
		Kill ^HS.AADBQ(pMPIID,"Update")
	}
]]></Implementation>
</Method>

<Method name="AAQBackground">
<Description>
This is jobbed by the management operations when it receives a gateway registration request which changes a
gateway's FeedAnalytics property, and when we're globally set up to do analytics feeding</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>pGateway,pPriority=3</FormalSpec>
<Implementation><![CDATA[
	Set $ZT="Trap",tSC=$$$OK
	$$$LOGINFO($$$Text("Started"))
	Do {
		Set tSQL="Select MPIID from HS_Registry.Patient where Facility->Gateway->Name =?"
		SET tStatement = ##class(%SQL.Statement).%New()
		Set tSC=tStatement.%Prepare(tSQL) Quit:$$$ISERR(tSC)
		Set tRS=tStatement.%Execute(pGateway)
		While tRS.%Next() {
			Do ..AAResendQ(tRS.%GetData(1),1,pPriority)
		}
	} While 0
Exit
	Set $ZT=""
	If $$$ISOK(tSC) {
		$$$LOGINFO($$$Text("Completed OK"))
	} Else {
		$$$LOGERROR($system.Status.GetErrorText(tSC))
	}
	Quit
Trap
	Set $ZT="",tSC=$$$EnsSystemError
	Goto Exit
]]></Implementation>
</Method>

<Method name="HasFeedableMRNs">
<Description>
Pass in an MPIID.  Will determine if the MPIID has any MRNs which belong to facilities
which reside on a gateway that is configured to feed analytics</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>pMPIID</FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	&SQL(Select Count(*) INTO :tCount
	 FROM HS_Registry.Patient P,HS_Facility.Config F
	 WHERE MPIID=:pMPIID AND P.Facility=F.FacilityCode and F.Gateway->FeedAnalytics=1)
	 Quit tCount>0
]]></Implementation>
</Method>

<Method name="GetFeedableMRNs">
<Description>
Pass in an MPIID.  Will find all MRNs which belong to facilities which reside on a gateway
that is configured to feed analytics, and populate the MRNs list of pResponse</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pMPIID,&pResponse:HS.Message.AnalyticsQResponse=""]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set:'$IsObject(pResponse) pResponse=##class(HS.Message.AnalyticsQResponse).%New()
	&SQL(DECLARE FMRNCursor CURSOR FOR 
	Select P.AssigningAuthority,P.Facility,P.MRN INTO :tAA, :tFac, :tMRN
	 FROM HS_Registry.Patient P,HS_Facility.Config F
	 WHERE MPIID=:pMPIID AND P.Facility=F.FacilityCode and F.Gateway->FeedAnalytics=1
	 ORDER By IsNull(Facility->Tier,99999),LastEnteredOnC DESC)
	&SQL(OPEN FMRNCursor)
	FOR {
		&SQL(FETCH FMRNCursor)
		Quit:SQLCODE
		Do pResponse.MRNs.Insert(tFac_"^"_tAA_"^"_tMRN)
	}
	&SQL(CLOSE FMRNCursor)
	Quit $$$OK
]]></Implementation>
</Method>

<Storage name="Default">
<Type>%Library.CacheStorage</Type>
<DefaultData>ManagerDefaultData</DefaultData>
<Data name="ManagerDefaultData">
<Subscript>"Manager"</Subscript>
<Value name="1">
<Value>MPIOperations</Value>
</Value>
<Value name="2">
<Value>MatchMode</Value>
</Value>
<Value name="3">
<Value>PreProcessor</Value>
</Value>
<Value name="4">
<Value>PostProcessor</Value>
</Value>
<Value name="5">
<Value>UpdatePreProcessor</Value>
</Value>
<Value name="6">
<Value>SearchPostProcessor</Value>
</Value>
</Data>
</Storage>
</Class>


<Class name="Synthea.HS.Hub.Push.RegNotifyManager">
<IncludeCode>HS.Common,%callout,%ZHSLIB</IncludeCode>
<Super>HS.Util.Trace.Helper,Ens.BusinessOperation</Super>
<TimeChanged>65195,61744.887093</TimeChanged>
<TimeCreated>61417,45352.484868</TimeCreated>
<Inheritance>right</Inheritance>

<Parameter name="HSDEPLOY">
<Default>1</Default>
</Parameter>

<Property name="GatewayOperations">
<Description><![CDATA[
Name of the Access Gateway Remote Operations component in this production. <br> 
Should be the name of a business host that performs actual communications with the access gateway Web service(s), via SOAP messages. ]]></Description>
<Type>Ens.DataType.ConfigName</Type>
<InitialExpression>"GATEWAY"</InitialExpression>
</Property>

<Property name="FailureTimeout">
<Description>
How long to keep retrying before giving up and returning an error code</Description>
<Type>%Numeric</Type>
<InitialExpression>-1</InitialExpression>
</Property>

<Parameter name="SETTINGS">
<Description>
Settings for this Business Process</Description>
<Type>%String</Type>
<Default>GatewayOperations</Default>
</Parameter>

<XData name="MessageMap">
<Data><![CDATA[
<MapItems>
	<MapItem MessageType="HS.Message.Push.RegistrationRequest"> 
		<Method>RegistrationRequest</Method>
	</MapItem>
	<MapItem MessageType="HS.Message.Push.DeleteRequest"> 
		<Method>DeleteRequest</Method>
	</MapItem>
	<MapItem MessageType="HS.Message.Push.IncorporateClinicalMessageRequest">
		<Method>IncorporateClinicalMessageRequest</Method>
	</MapItem>
</MapItems>
]]></Data>
</XData>

<Method name="RegistrationRequest">
<FormalSpec><![CDATA[pRequest:HS.Message.Push.RegistrationRequest,&pResponse:Ens.Response]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set pResponse=##class(Ens.Response).%New()
	Quit:'$$$HSLicensed("Clinical Message Delivery") $$Error^%apiOBJ(6083,$ZE)
	//For a message pushed due to a subscription
	If 'pRequest.Draft,'pRequest.Download,pRequest.RecipientReposDocIds.Count()=0 {
		Set tSub=pRequest.Subscription
		If (tSub.DeliveryType="EMAIL") {
			If tSub.RecipientType="S" {
				Set tRecip=##Class(HS.Push.Registry.Recipient).%OpenId(tSub.RecipientID)
			} Else {
				Set tRecip=##Class(HS.Registry.Person.User).%OpenId(tSub.RecipientID)
			}
			Set pRequest.ToList=tRecip.Name
		}
		IF tSub.RecipientType="S" {
			Set tDelivP=##Class(HS.Push.Delivery.SystemPolicy).%OpenId(tSub.DeliveryPolicyID)
		} Else {
			Set tDelivP=##Class(HS.Push.Delivery.UserPolicy).%OpenId(tSub.DeliveryPolicyID)
		}
		Set tUseAttachments=tDelivP.DeliveryOption.UseAttachments
		Quit ..RegisterDocument(pRequest,0,tUseAttachments)
	}
	//For a message sent from a clinician
	Set tSC=$$$OK,$ZT="Trap"
	Do {
		//compute ToList, CCList, BlindList
		#dim tRecipInfo As HS.Push.Types.RecipientSerialInfo
		//XDR docs will already have ToList
		If 'pRequest.XDRIN {
			For tRecipNum=1:1:pRequest.RecipientList.Count() {
				Set tRecipInfo=pRequest.RecipientList.GetAt(tRecipNum)
				Set tRecipId=tRecipInfo.RecipientID
				Set tRecip=$CASE(tRecipInfo.RecipientType
					,"C":##Class(HS.Registry.Person.User).%OpenId(tRecipId)
					,"S":##Class(HS.Push.Registry.Recipient).%OpenId(tRecipId)
					,"G":##Class(HS.Registry.ClinicianGroup).%OpenId(tRecipId)
				)
				Set tProp=tRecipInfo.RecipientLine_"List"
				Set tLine=$ZobjProperty(pRequest,tProp)
				Set:tLine'="" tLine=tLine_"; "
				Set tLine=tLine_tRecip.Name
				Set $ZobjProperty(pRequest,tProp)=tLine
			}
		}
		// Register it for the sender
		If pRequest.SenderID Set tSC=..RegisterDocument(pRequest,1) Quit:$$$ISERR(tSC)
		Quit:pRequest.Draft||(pRequest.Download)
		
		// Register it for each recipient
		For tRecipNum=1:1:pRequest.RecipientList.Count() {
			Set pRequest.DocumentId=pRequest.RecipientReposDocIds.GetAt(tRecipNum)
			Set tRecipInfo=pRequest.RecipientList.GetAt(tRecipNum)
			Set tSub=##Class(HS.Types.SubscriptionSerialInfo).%New()
			Set tSub.Subject=pRequest.Subscription.Subject
			Set tSub.TransformationType=pRequest.Subscription.TransformationType
			Set tSub.RecipientID=tRecipInfo.RecipientID
			Set tSub.RecipientType=tRecipInfo.RecipientType
			//get delivery policy stuff
			//This is similar but not identical to code in the evaluator
			//In the evaluator, we care about the transformation, which has yet to happen.
			//Here, any transformation has already happened.
			//For XDR input to message center, there won't be a delivery policy.
			If pRequest.XDRIN {
				Set tSub.DeliveryType="XDR"
				Set tRecip=##Class(HS.Registry.Person.User).%OpenId(tRecipInfo.RecipientID)
				Set tSub.UserId=tRecip.UserID
				Set tUseAttachments=0 //not relevant
			} Else {
				IF tRecipInfo.RecipientType="S" {
					Set tDelivP=##Class(HS.Push.Delivery.SystemPolicy).%OpenId(tRecipInfo.DeliveryPolicyId)
				} Else {
					Set tDelivP=##Class(HS.Push.Delivery.UserPolicy).%OpenId(tRecipInfo.DeliveryPolicyId)
					Set tSub.BatchNotification=tDelivP.BatchNotification
					Set tRecip=##Class(HS.Registry.Person.User).%OpenId(tRecipInfo.RecipientID)
					Set tSub.UserId=tRecip.UserID
				}
				Set:tDelivP.AccessGateway'="" tSub.AccessGWID=tDelivP.AccessGateway.%Id()
				Set tSub.EmailAddress=tDelivP.EmailAddress
				Set tSub.DeliveryPolicyID=tDelivP.%Id()
				Set tSub.DeliveryOperation=tDelivP.DeliveryOption.DeliveryOperation
				Set tUseAttachments=tDelivP.DeliveryOption.UseAttachments
				Set tSub.DeliveryType=tDelivP.DeliveryOption.DeliveryType
				Set tSub.FaxNumber=tDelivP.FaxNumber
				Set tSub.EmailOperation=tDelivP.DeliveryOption.EmailOperation
				Set tSub.EndPoint=tDelivP.EndPoint
			}
			Set pRequest.Subscription=tSub
			Set tSC=..RegisterDocument(pRequest,0,tUseAttachments) Quit:$$$ISERR(tSC)
		}
	} While (0)
Exit
	Quit tSC
Trap
	Set $ZT="",tSC=$$$EnsSystemError
	Goto Exit
]]></Implementation>
</Method>

<Method name="RegisterDocument">
<FormalSpec>pRequest:HS.Message.Push.RegistrationRequest,pForSender:%Boolean=0,pUseAttachments:%Boolean=0</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tSC=$$$OK,$ZT="Trap"
	Do {
		#dim tSub As HS.Types.SubscriptionSerialInfo
		#dim tReg As HS.Push.MessageCenter.Document
		Set tSC=##Class(HS.Push.MessageCenter.Document).CopyFrom(pRequest,.tReg) Quit:$$$ISERR(tSC)
		
		For tI=1:1:pRequest.Attachments.Count() {Do tReg.Attachments.Insert(pRequest.Attachments.GetAt(tI))}
		For tRecipNum=1:1:pRequest.RecipientList.Count() {Set tSC=tReg.RecipientList.Insert(pRequest.RecipientList.GetAt(tRecipNum))}
		Set tReg.Address=pRequest.Address
		Set tSub=pRequest.Subscription
		//IF tSub.DeliveryType="" {
		IF pForSender {
			// Delete prior draft (if any), and add new version to Sent or Drafts folder
			If pRequest.DocumentId]"" {
				Set tSC=##Class(HS.Push.MessageCenter.Folder).GetSysFolder(pRequest.SenderID,"Drafts",.tFoldId)
				Quit:$$$ISERR(tSC)
				&sql(DELETE FROM HS_Push_MessageCenter.Document Where FolderId=:tFoldId AND DocumentId=:pRequest.DocumentId)
			}
			If 'pRequest.Draft {
				Set tSC=##Class(HS.Push.MessageCenter.Folder).GetSysFolder(pRequest.SenderID,"Sent",.tFoldId)
				Quit:$$$ISERR(tSC)
			}
			Set tReg.FolderId=tFoldId
			Set tSub.RecipientID=pRequest.SenderID
			Set tSub.RecipientType="C"
			Set tSub.UserId=pRequest.UserId
			Set tReg.Subscription=tSub
			Set tReg.UnRead=1
			Set tReg.Received=$ZDT($H,3)
			Set tReg.Updated=$ZDT($H,3)
			Set tSC=tReg.%Save() QUIT
		}
		IF tSub.EmailOperation]""||pRequest.XDRIN,'pForSender {
			Set tReg.Subscription=tSub
			Set tSC=##Class(HS.Push.MessageCenter.Folder).GetSysFolder(pRequest.Subscription.RecipientID,"Inbox",.tFoldId)
			Quit:$$$ISERR(tSC)
			Set tReg.FolderId=tFoldId
			Set tReg.UnRead=1
			Set tReg.Received=$ZDT($H,3)
			Set tReg.Updated=$ZDT($H,3)
			Set tSC=tReg.%Save() Quit:$$$ISERR(tSC)
			
			//This is for Email notification - won't happen for XDR in
			If tSub.EmailAddress]"" {
				If tSub.BatchNotification {
					// Save for transmission in an e-mail digest
					Set tDocNotif=##class(HS.Push.DocumentNotification).%New()
					Set tDocNotif.DocumentId=pRequest.DocumentId
					Set tDocNotif.MPIID=pRequest.MPIID
					Set tDocNotif.RepositoryGWID=pRequest.RepositoryGWID
					Set tDocNotif.Subscription=pRequest.Subscription
					Set tDocNotif.WhenReceived=$ZDT($H,3)
					Set tDocNotif.MessageCenterDocumentId=tReg.%Id()
					Set tDelivPolicy=##class(HS.Push.Delivery.UserPolicy).%OpenId(pRequest.Subscription.DeliveryPolicyID)
					Set tDocNotif.NotificationTime=tDelivPolicy.NextNotificationTime()
					Set tSC=tDocNotif.%Save()
				} Else {
					//Construct the email contents.
					Set tRequestE=##class(HS.Message.Push.ConstructEmailRequest).%New()
					Set tRequestE.DocumentId=pRequest.DocumentId
					Set tRequestE.MessageCenterDocumentId=tReg.%Id()
					Set tRequestE.MPIID=pRequest.MPIID
					Set tRequestE.RepositoryGWID=pRequest.RepositoryGWID
					Set tRequestE.Subscription=pRequest.Subscription
					Set tRequestE.SenderName=pRequest.SenderName
					Set tSC=..SendRequestAsync(tSub.EmailOperation,tRequestE)
				}
			}
		} ELSE {
			//other - using a custom EDI delivery operation or FAX or direct e-mail
			Set tReg.Subscription=tSub
			Set tSC=tReg.%Save() Quit:$$$ISERR(tSC)
			Set tRequestD=##Class(HS.Message.Push.NotifyDeliveryRequest).%New()
			Set tRequestD.DocumentId=pRequest.DocumentId
			Set tRequestD.MPIID=pRequest.MPIID
			Set tRequestD.RepositoryGWID=pRequest.RepositoryGWID
			Set tRequestD.Subscription=pRequest.Subscription
			Set tRequestD.DocRegistryId=tReg.%Id()
			Set tRequestD.UseAttachments=pUseAttachments
			If (tSub.DeliveryType="EMAIL") {
				Set tRequestD.SenderName=pRequest.SenderName
				Set tRequestD.SenderEmail=..GetSenderEmail(tSub.DeliveryPolicyID, tSub.RecipientType, pRequest.SenderID)
			}
			
			Set tSC=..SendRequestAsync(..GatewayOperations,tRequestD)
		}
	} While (0)
Exit
	Quit tSC
Trap
	Set $ZT="",tSC=$$$EnsSystemError
	Goto Exit
]]></Implementation>
</Method>

<Method name="GetSenderEmail">
<Description>
Find an appropriate return address for Direct e-mail</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>pDeliveryPolicyID:%String,pRecipientType:%String,pSenderID:%String</FormalSpec>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
	// First get the user's primary e-mail that matches the type of the delivery policy of the recipient, 
	// then try any primary e-mail type
	If pRecipientType="S" {
		&sql(SELECT Telecoms_Email, CASE WHEN policy.DeliveryOption->EmailType = Telecoms_EmailType THEN '1' ELSE '0' END AS matches 
				INTO :tEmail,:tDummy
				FROM HS_Push_Delivery.SystemPolicy policy,HS_Registry_Person.UserClinician_Telecoms email
				WHERE policy.ID = :pDeliveryPolicyID 
				AND email.UserClinician= :pSenderID
				AND email.Telecoms_PrimaryFlag = '1'
				ORDER BY matches DESC)
	} Else {
		&sql(SELECT Telecoms_Email, CASE WHEN policy.DeliveryOption->EmailType = Telecoms_EmailType THEN '1' ELSE '0' END AS matches 
				INTO :tEmail,:tDummy
				FROM HS_Push_Delivery.UserPolicy policy,HS_Registry_Person.UserClinician_Telecoms email
				WHERE policy.ID = :pDeliveryPolicyID 
				AND email.UserClinician= :pSenderID
				AND email.Telecoms_PrimaryFlag = '1'
				ORDER BY matches DESC)
	}
	Quit $S(SQLCODE=0:tEmail,1:"")
]]></Implementation>
</Method>

<Method name="DeleteRequest">
<FormalSpec><![CDATA[pRequest:HS.Message.Push.DeleteRequest,&pResponse:Ens.Response]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tSC=$$$OK,$ZT="Trap"
	Do {
		Set tGateway=pRequest.Gateway
		For tDocNum=1:1:pRequest.DocumentIds.Count() {
			Set tDocId=pRequest.DocumentIds.GetAt(tDocNum)
			&SQL(DELETE FROM HS_Push.DocumentRegistry WHERE RepositoryGWEndPoint=:tGateway AND DocumentId=:tDocId)
		}
	} While (0)
Exit
	Quit tSC
Trap
	Set $ZT="",tSC=$$$EnsSystemError
	Goto Exit
]]></Implementation>
</Method>

<Method name="CheckCreateCMCRequest">
<Description>
in order to process an XDR request at an edge, we first need to check it at the registry
to determine if there's an MPIID/patient, as well as if there are user-clinicians associated
with the sender and any recipients.</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>pRequest:HS.Message.Push.CreateClinicalMessageRequest</FormalSpec>
<ReturnType>HS.Message.Push.CreateClinicalMessageCheck</ReturnType>
<Implementation><![CDATA[
	Set tSC=$$$OK
	Set tResponse=##class(HS.Message.Push.CreateClinicalMessageCheck).%New()
	If pRequest.MRN'="",pRequest.AssigningAuthority'="" {
		Set tMRN=pRequest.MRN, tAA=pRequest.AssigningAuthority
		&SQL(Select MPIID into :tMPIID FROM HS_Registry.Patient WHERE MRN=:tMRN AND AssigningAuthority=:tAA)
		If SQLCODE=0 Set tResponse.MPIID=tMPIID
	}
	Set tSC=##class(HS.Registry.Person.User).FindByEmail(pRequest.SenderEmail,.tSender,.tName,.tUserId) Quit:$$$ISERR(tSC)
	Set tResponse.SenderId=tSender, tResponse.UserId=tUserId, tResponse.SenderName=tName
	If 'tSender Set tResponse.SenderName=pRequest.SenderEmail
	For tI=1:1:pRequest.To.Count() {
		Set tToEmail=pRequest.To.GetAt(tI)
		Set:tToEmail["<" tToEmail=$P($P(tToEmail,"<",2),">")
		Set tSC=##class(HS.Registry.Person.User).FindByEmail(tToEmail,.tRecip,.tName) Quit:$$$ISERR(tSC)
		If 'tRecip {
			Set tName=pRequest.To.GetAt(tI)
		} Else {
			Do tResponse.RecipientIds.Insert(tRecip)
		}
		Set tResponse.ToList=tResponse.ToList_$S(tI>1:", ",1:"")_tName
	}

	Set tResponse.Status= tSC
	Quit tResponse
]]></Implementation>
</Method>

<Method name="IncorporateClinicalMessageRequest">
<FormalSpec><![CDATA[pRequest:HS.Message.Push.IncorporateClinicalMessageRequest,&pResponse:HS.Util.EmptyEnsResponse]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tSC=$$$OK
	Try {
		Set pResponse=##class(HS.Util.EmptyEnsResponse).%New()
		#dim tInboxDoc As HS.Push.MessageCenter.Document
		Do ##class(HS.Push.MessageCenter.Document).GetDocumentInfo(pRequest.RegistryDocId,.tInboxDoc)
		$$$HSTRACE("Got DocumentInfo","tInboxDoc",tInboxDoc)
		Set tExternalFacility=##class(HS.Push.MessageCenter.Document).GetExternalDirectFacility()
		Set tMRN=tInboxDoc.Facility_"@"_tInboxDoc.AssigningAuthority_"@"_tInboxDoc.MRN
		Set tMPIID=tInboxDoc.MPIID
		If tMPIID="" {
			//have to add patient
			Set tMessage=##class(HS.Message.AddUpdateHubRequest).%New()
			Set tMessage.Facility=tExternalFacility
			Set tMessage.AssigningAuthority=tMessage.Facility
			Set tMessage.MRN=tMRN
			Set tMessage.GatewayName=##Class(HS.Facility.Config).%OpenId(tExternalFacility).Gateway.Name
			Set tName=tInboxDoc.LastName,tMessage.LastName=$P(tName,","),tFirst=$P(tName,",",2)
			Set tMessage.FirstName=$P(tFirst," "),tMessage.MiddleName=$P(tFirst," ",2,99)
			Set tMessage.Sex=tInboxDoc.Sex, tMessage.DOB=tInboxDoc.DOB
			Set tMessage.Street=tInboxDoc.Address.StreetLine,tMessage.City=tInboxDoc.Address.City
			Set tMessage.State=tInboxDoc.Address.State,tMessage.Zip=tInboxDoc.Address.PostalCode
			Set tMessage.DoMPIUpdate=1, tMessage.EventType="Doc"
			Set tSC=..SendRequestSync("Synthea.HS.Hub.MPI.Manager",tMessage,.tResponse) Quit:$$$ISERR(tSC)
			Set tSC=tResponse.ErrStatus Quit:$$$ISERR(tSC)
			Set tMPIID=tResponse.MPIID
		}
		set tSourceId = ##class(HS.Data.OIDMap).GetOIDForCode(tExternalFacility)
		set tSourcePatientId=tMRN_"^^^&"_tSourceId_"&ISO"
		set tHealthcareFacilityTypeCode=##class(HS.IHE.XDSb.Types.CodedValue).%New("385432009","SNOMED","Not Applicable")
		set tPracticeSettingCode=##class(HS.IHE.XDSb.Types.CodedValue).%New("385432009","SNOMED","Not Applicable")
		set tClassCode=##class(HS.IHE.XDSb.Types.CodedValue).%New("Transfer Summarization","Connect-a-thon classCodes","Transfer Summarization")
		set tTypeCode=##class(HS.IHE.XDSb.Types.CodedValue).%New("18761-7","LOINC","Transfer Summarization Note")
		#dim tAttach as HS.Message.Push.DocumentAttachmentResponse
		For tAttchnum=1:1:tInboxDoc.Attachments.Count() {
			Set tPnR=##class(HS.Message.IHE.XDSb.ProvideAndRegisterRequest).%New()
			Set tPnR.ContentTypeCode=##class(HS.IHE.XDSb.Types.CodedValue).%New("Transfer Summarization","Connect-a-thon contentTypeCodes","Transfer Summarization")
			Set tPnR.Comments=pRequest.Comments
			Set tPnR.PatientId=tMPIID_"^^^&"_$$$AffinityDomainOID_"&ISO"
			Set tPnR.Title=tInboxDoc.Subscription.Subject
			Set tPnR.SourceId=tSourceId
			Set tPnR.RequestingUser=pRequest.RequestingUser
			Set tPnR.RequestingUserRoles=pRequest.RequestingUserRoles
			Set tPnR.AdditionalInfo=pRequest.AdditionalInfo
			Set tPnR.SAMLData=pRequest.SAMLData
			Set tAttReq=##class(HS.Message.Push.DocumentAttachmentRequest).%New()
			Set tAttReq.DocumentId=tInboxDoc.DocumentId
			Set tAttReq.Gateway=tInboxDoc.RepositoryGWEndPoint
			Set tAttReq.Attachment=tAttchnum
			//fetch the attachment stream
			Set tSC=..SendRequestSync(..GatewayOperations,tAttReq,.tAttach)
			Quit:$$$ISERR(tSC)
			//Now that we have the attachment, create a document and insert it into the PnR
			set tDocument = ##class(HS.Message.IHE.XDSb.Document).%New()
			Set tDocument.SourcePatientId=tSourcePatientId
			//create the slots for demographics
			Do tDocument.SourcePatientInfo.Insert(##class(HS.IHE.XDSb.Types.SlotValue).%New("PID-3|"_tDocument.SourcePatientId))
			Set tName=tInboxDoc.LastName //this actually contains the full name
			Set tLast=$P(tName,","),tFirst=$P(tName,",",2),tMiddle=$P(tFirst," ",2,99),tFirst=$P(tFirst," ")
			Do tDocument.SourcePatientInfo.Insert(##class(HS.IHE.XDSb.Types.SlotValue).%New("PID-5|"_tLast_"^"_tFirst_"^"_tMiddle))
			Do:tInboxDoc.DOB'="" tDocument.SourcePatientInfo.Insert(##class(HS.IHE.XDSb.Types.SlotValue).%New("PID-7|"_$ZDT(tInboxDoc.DOB,8)))
			Do tDocument.SourcePatientInfo.Insert(##class(HS.IHE.XDSb.Types.SlotValue).%New("PID-8|"_tInboxDoc.Sex))
			Set tAddress=tInboxDoc.Address.StreetLine_"^^"_tInboxDoc.Address.City_"^"_tInboxDoc.Address.State_"^"_tInboxDoc.Address.PostalCode
			Do tDocument.SourcePatientInfo.Insert(##class(HS.IHE.XDSb.Types.SlotValue).%New("PID-11|"_tAddress))
			
			Set tMime=$ZCVT(tAttach.MimeType,"U")
			Set:tMime["/" tMime=$P(tMime,"/",2)
			If tMime="TEXT"||(tMime="XML") {
				Do tDocument.BodyCharacter.CopyFrom(tAttach.Stream)
			} Else {
				Do tDocument.Body.CopyFrom(tAttach.Stream)
			}
			Set tDocument.MimeType=tAttach.MimeType
			//try to extract some more metadata from the document, if we can.  Don't worry about errors.
			If tMime="XML" {
				Set tTag=""
				Set txSC=##class(HS.IHE.Util).GetXPathValue(tDocument.BodyCharacter,"/","local-name(*)",.tTag,.tDocObject)
				If $$$ISOK(txSC),tTag="ClinicalDocument" {
					Set txSC = ##class(HS.IHE.Util).GetXPathValue(tDocument.BodyCharacter,"/hl7:ClinicalDocument/hl7:effectiveTime","@value",.tValue,.tDocObject)
					If $$$ISOK(txSC),tValue]"" Set tDocument.CreationTime=##class(HS.Util.XSLTHelper).xmltimestampToUTC(tValue)
					Set txSC = ##class(HS.IHE.Util).GetXPathValue(tDocument.BodyCharacter,"/hl7:ClinicalDocument/hl7:languageCode","@code",.tValue,.tDocObject)
					If $$$ISOK(txSC),tValue]"" Set tDocument.LanguageCode=tValue
					Set txSC = ##class(HS.IHE.Util).GetXPathValue(tDocument.BodyCharacter,"/hl7:ClinicalDocument/hl7:confidentialityCode","@code",.tCode,.tDocObject)
					Set txSC2 = ##class(HS.IHE.Util).GetXPathValue(tDocument.BodyCharacter,"/hl7:ClinicalDocument/hl7:confidentialityCode","@codeSystem",.tScheme,.tDocObject)
					Set txSC3 = ##class(HS.IHE.Util).GetXPathValue(tDocument.BodyCharacter,"/hl7:ClinicalDocument/hl7:confidentialityCode","@displayName",.tDescription,.tDocObject)
					If $$$ISOK(txSC),$$$ISOK(txSC2),$$$ISOK(txSC3),tCode]"",tScheme]"" Do tDocument.ConfidentialityCode.Insert(##class(HS.IHE.XDSb.Types.CodedValue).Create(tCode,tScheme,tDescription))
				}
			}
			//default in other required metadata
			Do:tDocument.ConfidentialityCode.Count()=0 tDocument.ConfidentialityCode.Insert(##class(HS.IHE.XDSb.Types.CodedValue).Create("N","2.16.840.1.113883.5.25","Normal"))
			Set:tDocument.CreationTime="" tDocument.CreationTime=##class(HS.Util.XSLTHelper).xmltimestampToUTC($tr($zdt($h,8),": "))
			Set:tDocument.LanguageCode="" tDocument.LanguageCode="en-US"
			Set tCoded=""
			If tAttach.FormatScheme'="",tAttach.FormatCode'="" {
				Set tCoded=##class(HS.IHE.CodedEntry).UniqueIndexOpen("FormatCode",tAttach.FormatScheme,tAttach.FormatCode)
			}
			If $IsObject(tCoded) {
				Set tFormat=##class(HS.IHE.XDSb.Types.CodedValue).%New(tAttach.FormatCode,tAttach.FormatScheme,tCoded.Description)
			} Else {
				Set tFormat=##class(HS.IHE.XDSb.Types.CodedValue).%New("Generic Image","Connect-a-thon formatCodes","Generic Image")
			}
			Set tDocument.FormatCode=tFormat
			Set tDocument.HealthcareFacilityTypeCode=tHealthcareFacilityTypeCode
			Set tDocument.PracticeSettingCode=tPracticeSettingCode
			Set tDocument.ClassCode=tClassCode
			Set tDocument.TypeCode=tTypeCode
			Set tDocument.Title=tInboxDoc.Attachments.GetAt(tAttchnum).Name
			Do tPnR.Documents.Insert(tDocument)
			Set tSC=..SendRequestSync("HS.IHE.XDSb.DocumentSource.Operations",tPnR,.tPnRResponse)
			Quit:$$$ISERR(tSC)
		}
		//and submit the PnR
		Quit:$$$ISERR(tSC)
		//Mark document as having been incorporated
		Do ##class(HS.Push.MessageCenter.Document).MarkIncorporated(pRequest.RegistryDocId,pRequest.RequestingUser)
	} catch {
		set tSC=$$$ERROR($$$CacheError,$ze)
	}
	Quit tSC
]]></Implementation>
</Method>
</Class>


<Class name="Synthea.HSPI.API">
<Description><![CDATA[
HSPI MPI Operations component for use with the Healthshare Patient Index. <br> ]]></Description>
<Abstract>1</Abstract>
<IncludeCode>HS.Common,%ZHSLIB,%MPRL</IncludeCode>
<TimeChanged>65234,14306</TimeChanged>
<TimeCreated>60521,50343.894</TimeCreated>

<Method name="AddPatient">
<Description>

any call to AddUpdate will always have F+AA+MRN,

The AddOrUpdate property determines what to do with the request:

Add:        If F+AA+MRN already exist, it's an error
            Create a new record, assign new MPIID
            Always overwriting all data
Update or Force or "": U and F are identical now. We accept both for backwards compatibility
            If F+AA+MRN does not exist, create a new record and honor non-empty MPIID passed in the message 
            If F+AA+MRN exists, use it, and any value of MPIID in the message is ignored 
            If AddOrUpdate is "", data is incomplete, don't blank out existing data, otherwise, overwrite all data
            call synchronizeEnterpriseId only if MPIID has not been determined.
</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>pRequest:HS.Message.AddPatientRequest,*pResponse:HS.Message.AddPatientResponse</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	If ^stConfig("LogBool")  { 
		Set tMetric = ##class(Synthea.StressMetrics).%New()
		Set tMetric.Type = "AddPatient"
		Set tMetric.ClassName = $THIS
		Set tMetric.LineStart = 27
		Set tMetric.Start = $ZDATETIME($H,3,1,3)
		set tStartZH = $ZH
	}
	if '$$$HSLicensed("Patient Index") quit $$Error^%apiOBJ($$$OperationNotLicensed)
	set logLevel=+$g(^HSPI.LogLevel)
	if logLevel>=1 set logIndex=$i(^HSPI.Log),^HSPI.Log(logIndex,0)=$$$FullMethodName
	if logLevel>=1 set ^HSPI.Log(logIndex,$i(logCount))=pRequest.%Oid()
	if logLevel>=1 set ^HSPI.Log(logIndex,$i(logCount))=$lb(##class(%UTC).NowLocal())
	if logLevel>=2 set ^HSPI.Log(logIndex,$i(logCount))=$lb("AddOrUpdate="_pRequest.AddOrUpdate,"MPIID="_pRequest.MPIID,"Facility="_pRequest.Facility,"AA="_pRequest.AssigningAuthority,"MRN="_pRequest.MRN)
	set tSC=$$$OK,zh=$zh
	try {
		set definitionClass = ##class(HS.Registry.Config).GetKeyValue("\HSPI\LinkageDefinition","Local.Linkage.Definition")
		set normalizedClass = $classmethod(definitionClass,"getMetaValue","class:normalized")
		set classifiedClass = $classmethod(definitionClass,"getMetaValue","class:classified")
		set classifiedTable = $classmethod(definitionClass,"getMetaValue","table:classified")
		;
		set pResponse = ##class(HS.Message.AddPatientResponse).%New()
		;
		if ( pRequest.AddOrUpdate = "A" ) {
			set patient=##class(HSPI.Data.Patient).indexFAMOpen(pRequest.Facility,pRequest.AssigningAuthority,pRequest.MRN) 
			if $isObject(patient) {
				set tSC = $$$ERROR($$$GeneralError,"Patient already exists") quit
			} else {
				set patient = ##class(HSPI.Data.Patient).%New()
			}
			set mpiid = $classmethod(definitionClass,"newEnterpriseId")
			set pResponse.MPIUpdateFlag = 1
			set copyNull = 1
		} else {
			; this handles case for AddOrUpdate = F, U or ""
			if (pRequest.AddOrUpdate'="U") && (pRequest.AddOrUpdate'="F") && (pRequest.AddOrUpdate'="") {
				set tSC=$$$ERROR($$$GeneralError,"AddOrUpdate flag is invalid")
				quit
			}
			;
			set patient = ##class(HSPI.Data.Patient).indexFAMOpen(pRequest.Facility,pRequest.AssigningAuthority,pRequest.MRN)
			if $isObject(patient) {
				if logLevel>=2 set ^HSPI.Log(logIndex,$i(logCount))=$lb("existing")
				set mpiid = ""
				set pResponse.MPIUpdateFlag = 2
			} else {
				set patient = ##class(HSPI.Data.Patient).%New()
				if logLevel>=2 set ^HSPI.Log(logIndex,$i(logCount))=$lb("new")
				set mpiid = pRequest.MPIID
				set pResponse.MPIUpdateFlag = 1
			}
			set copyNull = (pRequest.AddOrUpdate'="")
		}
		;
		set preserveHistory = ##class(HS.Registry.Config).GetKeyValue("\HSPI\PreserveHistoricalData",0)
		;
		set tSC = ..copyPatientDataFromMessage(pRequest,patient,copyNull,preserveHistory) quit:$$$ISERR(tSC)
		if mpiid'="" set patient.MPIID = mpiid
		set tSC = patient.%Save() quit:$$$ISERR(tSC)
		;
		if $g(^MPRL.Config("skipLinkage",definitionClass)) {
			if patient.MPIID="" {
				set patient.MPIID = $classmethod(definitionClass,"newEnterpriseId")
				set tSC = patient.%Save() quit:$$$ISERR(tSC)
				set pResponse.PatientId = patient.MPIID
			}
		} else {
			set comment = $case(pResponse.MPIUpdateFlag,1:"Add patient",2:"Update patient",:"UnknownAction")_" '"_pRequest.AssigningAuthority_":"_pRequest.MRN_"'"
			set source = "HSPI.API:AddPatient"
			set tSC = $classmethod(definitionClass,"updateOneLinkageData","HSPI.Data.Patient",patient.%Id(),comment,source) quit:$$$ISERR(tSC)
			; use the MPIID saved in the original object first
			set pResponse.PatientId = patient.MPIID
			; we reopen the normalized object becuse the MPIID could have been updated by another parallel process
			set patientNormalizedId = $classmethod(normalizedClass,"convertOrigOidToNormId",patient.%Oid())
			set normalizedPatient = $classmethod(normalizedClass,"%OpenId",patientNormalizedId)
			if $isObject(normalizedPatient) set pResponse.PatientId = normalizedPatient.enterpriseId
		}
		;
	} catch {
		set tSC=$$$ERROR($$$CacheError,$ze)
	}
	if logLevel>=2 set ^HSPI.Log(logIndex,$i(logCount))=$lb("MPIID="_pResponse.PatientId)
	if logLevel>=1 set ^HSPI.Log(logIndex,$i(logCount))=$lb(##class(%UTC).NowLocal(),"tSC="_tSC,"duration="_($zh-zh))
	If ^stConfig("LogBool") { 
		set tMetric.Elapsed = $ZH - tStartZH
		Set tMetric.End = $ZDATETIME($H,3,1,3)
		Set tMetric.LineEnd = 106
		Set ltSC = tMetric.Save()
		Quit:$$$ISERR(ltSC)
	}
	quit tSC
]]></Implementation>
</Method>

<Method name="MergePatient">
<Description>
The record with prior-AA and prior-MRN is deleted, then we call synchronization on surviving MRN and prior-MPIID.
If surviving patient doesn't exist, then we change the prior patient's MRN from prior MRN to survnving MRN.
</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>pRequest:HS.Message.MergePatientRequest,*pResponse:HS.Message.MergePatientResponse</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	if '$$$HSLicensed("Patient Index") quit $$Error^%apiOBJ($$$OperationNotLicensed)
	set logLevel=+$g(^HSPI.LogLevel)
	if logLevel>=1 set logIndex=$i(^HSPI.Log),^HSPI.Log(logIndex,0)=$$$FullMethodName
	if logLevel>=1 set ^HSPI.Log(logIndex,$i(logCount))=pRequest.%Oid()
	if logLevel>=1 set ^HSPI.Log(logIndex,$i(logCount))=$lb(##class(%UTC).NowLocal())
	if logLevel>=2 set ^HSPI.Log(logIndex,$i(logCount))=$lb("Facility="_pRequest.Facility,"AssigningAuthority="_pRequest.AssigningAuthority,"MRN="_pRequest.MRN,"PriorAssigningAuthority="_pRequest.PriorAssigningAuthority,"PriorMRN="_pRequest.PriorMRN)
	set tSC=$$$OK,zh=$zh
	try {
		set definitionClass = ##class(HS.Registry.Config).GetKeyValue("\HSPI\LinkageDefinition","Local.Linkage.Definition")
		set normalizedClass = $classmethod(definitionClass,"getMetaValue","class:normalized")
		set pResponse = ##class(HS.Message.MergePatientResponse).%New()
		;
		set patientToBeDeleted = ##class(HSPI.Data.Patient).indexFAMOpen(pRequest.Facility,pRequest.PriorAssigningAuthority,pRequest.PriorMRN)
		if $isObject(patientToBeDeleted)=0 quit
		;
		set comment = "Merge patient from '"_pRequest.PriorAssigningAuthority_":"_pRequest.PriorMRN_"' to '"_pRequest.AssigningAuthority_":"_pRequest.MRN_"'"
		set source = "HSPI.API:MergePatient"
		;
		#dim tListIdentifiers as %Library.ListOfObjects
		set patientToSurvive = ##class(HSPI.Data.Patient).indexFAMOpen(pRequest.Facility,pRequest.AssigningAuthority,pRequest.MRN)
		if $IsObject(patientToSurvive)=0 {
			//If there's no patient with the target MRN, change the MRN of the prior one
			set patientToBeDeleted.AssigningAuthority = pRequest.AssigningAuthority
			set patientToBeDeleted.MRN = pRequest.MRN
			set tSC = patientToBeDeleted.%Save() quit:$$$ISERR(tSC)
			; call logAudit, in this case, MPIID didn't change, but MRN got changed from underneath it
			do $classmethod(definitionClass,"logAudit","MRN:modify","",patientToBeDeleted.%Id(),pRequest.PriorAssigningAuthority_":"_pRequest.PriorMRN,patientToBeDeleted.AssigningAuthority_":"_patientToBeDeleted.MRN,comment,source)
			#; send an update notification to the MPI.Manager so that it can send a PIX notification
			set tSC = ..findPatientsforMPIID(patientToBeDeleted.MPIID,.tListIdentifiers)
			set tIDUpdateNotification = ##class(HS.Message.IDUpdateNotificationRequest).%New()
			set tIDUpdateNotification.MPIID = patientToBeDeleted.MPIID
			set tIDUpdateNotification.Identifiers = tListIdentifiers
			set tIdentifier = ##class(HS.Types.Identifier).%New()
			set tIdentifier.Root = pRequest.PriorAssigningAuthority
			set tIdentifier.Extension = pRequest.PriorMRN
			do tIDUpdateNotification.PriorIdentifiers.Insert(tIdentifier)
			;
			set tSC = ##class(Ens.Director).CreateBusinessService("HS.Hub.Services",.tService) quit:$$$ISERR(tSC)
			set tSC = tService.ProcessInput(tIDUpdateNotification) quit:$$$ISERR(tSC)
			quit
		}
		;
		set mpiidToBeDeleted = patientToBeDeleted.MPIID
		set mpiidToSurvive = patientToSurvive.MPIID
		;
		; Assign mpiidToSurvive to patientToBeDeleted before deleting patientToBeDeleted
		; This assignment will generate an IDUpdateNotification
		If patientToSurvive.MPIID'=patientToBeDeleted.MPIID {
			set nidToBeDeleted = $classmethod(normalizedClass,"convertOrigIdClassnameToNormId",patientToBeDeleted.%Id(),"HSPI.Data.Patient")
			set tSC = $classmethod(definitionClass,"assignEnterpriseId",nidToBeDeleted,mpiidToSurvive,comment,source) 
		}
		;
		set pidToSurvive = patientToSurvive.%Id()
		set pidToBeDeleted = patientToBeDeleted.%Id()
		set nidToBeDeleted = $classmethod(normalizedClass,"convertOrigIdClassnameToNormId",pidToBeDeleted,"HSPI.Data.Patient")
		set tSC = ##class(HSPI.Data.Patient).%DeleteId(pidToBeDeleted) quit:$$$ISERR(tSC)
 		; call logAudit, log patient is deleted
		do $classmethod(definitionClass,"logAudit","patient:delete","",nidToBeDeleted,"","",comment,source)
		;
		set tSC = $classmethod(definitionClass,"updateOneLinkageData","HSPI.Data.Patient",pidToBeDeleted,comment,source) quit:$$$ISERR(tSC)
		set tSC = $classmethod(definitionClass,"updateOneLinkageData","HSPI.Data.Patient",pidToSurvive,comment,source,,,,mpiidToBeDeleted) quit:$$$ISERR(tSC)
		;
		set pResponse.PriorMPIID = mpiidToBeDeleted
		set pResponse.TargetMPIID = mpiidToSurvive
		;
	} catch {
		set tSC=$$$ERROR($$$CacheError,$ze)
	}
	if logLevel>=2 set ^HSPI.Log(logIndex,$i(logCount))=$lb("PriorMPIID="_pResponse.PriorMPIID,"TargetMPIID="_pResponse.TargetMPIID)
	if logLevel>=1 set ^HSPI.Log(logIndex,$i(logCount))=$lb(##class(%UTC).NowLocal(),"tSC="_tSC,"duration="_($zh-zh))
	quit tSC
]]></Implementation>
</Method>

<Method name="RemovePatient">
<Description>

delete the patient with F+AA+MRN
</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>pRequest:HS.Message.RemovePatientRequest,*pResponse:HS.Message.RemovePatientResponse</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	if '$$$HSLicensed("Patient Index") quit $$Error^%apiOBJ($$$OperationNotLicensed)
	set logLevel=+$g(^HSPI.LogLevel)
	if logLevel>=1 set logIndex=$i(^HSPI.Log),^HSPI.Log(logIndex,0)=$$$FullMethodName
	if logLevel>=1 set ^HSPI.Log(logIndex,$i(logCount))=pRequest.%Oid()
	if logLevel>=1 set ^HSPI.Log(logIndex,$i(logCount))=$lb(##class(%UTC).NowLocal())
	if logLevel>=2 set ^HSPI.Log(logIndex,$i(logCount))=$lb("Facility="_pRequest.Facility,"AssigningAuthority="_pRequest.AssigningAuthority,"MRN="_pRequest.MRN)
	set tSC=$$$OK,zh=$zh
	try {
		set definitionClass = ##class(HS.Registry.Config).GetKeyValue("\HSPI\LinkageDefinition","Local.Linkage.Definition")
		set pResponse = ##class(HS.Message.RemovePatientResponse).%New()
		;
		set comment = "Delete patient '"_pRequest.AssigningAuthority_":"_pRequest.MRN_"'"
		set source = "HSPI.API:RemovePatient"
		;
		if ##class(HSPI.Data.Patient).indexFAMExists(pRequest.Facility,pRequest.AssigningAuthority,pRequest.MRN)=0 quit
		;
		set patient = ##class(HSPI.Data.Patient).indexFAMOpen(pRequest.Facility,pRequest.AssigningAuthority,pRequest.MRN,,.tSC)
		if $isObject(patient)=0 quit
		;
		set patientId = patient.%Id()
		set tSC = patient.%DeleteId(patientId) quit:$$$ISERR(tSC)
		do $classmethod(definitionClass,"logAudit","patient:delete","",patientId,"","",comment,source)
		set tSC = $classmethod(definitionClass,"updateOneLinkageData","HSPI.Data.Patient",patientId,comment,source) quit:$$$ISERR(tSC)
		;
	} catch {
		set tSC=$$$ERROR($$$CacheError,$ze)
	}
	if logLevel>=1 set ^HSPI.Log(logIndex,$i(logCount))=$lb(##class(%UTC).NowLocal(),"tSC="_tSC,"duration="_($zh-zh))
	quit tSC
]]></Implementation>
</Method>

<Method name="PatientSearch">
<Description>

Supports the HealthShare request and response message objects shown in the method signature. 
The optional third argument returns incidental information needed to support Patient Index UI classes;
it has NO effect on the search operation or its results.
</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>pRequest:HS.Message.PatientSearchRequest,*pResponse:HS.Message.PatientSearchResponse,*pNormalizedIdsGroupedByMPIID</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	set returnNormalizedIds = ($zu(141) > 2)
	kill pNormalizedIdsGroupedByMPIID
	;
	if '$$$HSLicensed("Patient Index") quit $$Error^%apiOBJ($$$OperationNotLicensed)
	set logLevel=+$g(^HSPI.LogLevel)
	if logLevel>=1 set logIndex=$i(^HSPI.Log),^HSPI.Log(logIndex,0)=$$$FullMethodName
	if logLevel>=1 set ^HSPI.Log(logIndex,$i(logCount))=pRequest.%Oid()
	if logLevel>=1 set ^HSPI.Log(logIndex,$i(logCount))=$lb(##class(%UTC).NowLocal())
	set tSC=$$$OK,zh=$zh
	set tSkipSynchronization=1
	try {
		set summary = ""
		set mpiid = "" for i=1:1:pRequest.MPIIDLIST.Count() set mpiid = mpiid_","_pRequest.MPIIDLIST.GetAt(i)
		if mpiid'="" set summary = summary_",MPIID='"_$e(mpiid,2,*)_"'"
		if pRequest.Facility'="" set summary = summary_",Facility='"_pRequest.Facility_"'"
		if pRequest.AssigningAuthority'="" set summary = summary_",AssigningAuthority='"_pRequest.AssigningAuthority_"'"
		if pRequest.MRN'="" set summary = summary_",MRN='"_pRequest.MRN_"'"
		if pRequest.LastName'="" set summary = summary_",LastName='"_pRequest.LastName_"'"
		if pRequest.FirstName'="" set summary = summary_",FirstName='"_pRequest.FirstName_"'"
		if pRequest.MiddleName'="" set summary = summary_",MiddleName='"_pRequest.MiddleName_"'"
		if pRequest.Sex'="" set summary = summary_",Sex='"_pRequest.Sex_"'"
		if pRequest.DOB'="" set summary = summary_",DOB='"_pRequest.DOB_"'"
		if pRequest.DOBRangeEnd'="" set summary = summary_",DOBRangeEnd='"_pRequest.DOBRangeEnd_"'"
		if pRequest.Street'="" set summary = summary_",Street='"_pRequest.Street_"'"
		if pRequest.City'="" set summary = summary_",City='"_pRequest.City_"'"
		if pRequest.State'="" set summary = summary_",State='"_pRequest.State_"'"
		if pRequest.Zip'="" set summary = summary_",Zip='"_pRequest.Zip_"'"
		if pRequest.Telephone'="" set summary = summary_",Telephone='"_pRequest.Telephone_"'"
		if pRequest.SSN'="" set summary = summary_",SSN='"_pRequest.SSN_"'"
		if pRequest.Identifiers.Count()>0 {
			if pRequest.Identifiers.GetAt(1).Use'="" set summary = summary_",Identifier.Use='"_pRequest.Identifiers.GetAt(1).Use_"'"
			if pRequest.Identifiers.GetAt(1).Extension'="" set summary = summary_",Identifier.Extension='"_pRequest.Identifiers.GetAt(1).Extension_"'"
			if pRequest.Identifiers.GetAt(1).AssigningAuthorityName'="" set summary = summary_",Identifier.AssigningAuthorityName='"_pRequest.Identifiers.GetAt(1).AssigningAuthorityName_"'"
		}
		set summary = $e(summary,2,*)
		;
		if logLevel>=2 set ^HSPI.Log(logIndex,$i(logCount))=$lb(summary)
		;
		set definitionClass = ##class(HS.Registry.Config).GetKeyValue("\HSPI\LinkageDefinition","Local.Linkage.Definition")
		set normalizedClass = $classmethod(definitionClass,"getMetaValue","class:normalized")
		set classifiedClass = $classmethod(definitionClass,"getMetaValue","class:classified")
		set classifiedTable = $classmethod(definitionClass,"getMetaValue","table:classified")
		;
		if +pRequest.MaxMatches=0 set pRequest.MaxMatches=100
		;
		set pResponse = ##class(HS.Message.PatientSearchResponse).%New()
		;
		set comment = "Search patient with summary: "_summary
		set source = "HSPI.API:SearchPatient"
		;
		set patientSearch = ##class(HSPI.Data.Search).%New()
		set tSC = ..copyPatientDataFromMessage(pRequest,patientSearch,0,0) quit:$$$ISERR(tSC)
		;
		set address = ##class(HSPI.Data.Type.Address).%New()
		set address.StreetLine = pRequest.Street
		set address.City = pRequest.City
		set address.State = pRequest.State
		set address.PostalCode = pRequest.Zip
		do patientSearch.Addresses.Insert(address)
		;
		set phone = ##class(HSPI.Data.Type.Telecom).%New()
		set phone.PhoneNumberFull = pRequest.Telephone
		do patientSearch.Telecoms.Insert(phone)
		;
		set tSC = patientSearch.%Save() quit:$$$ISERR(tSC)
		; call updateOneLinkageData to create the normalized object, but classified data should not be created
		set tSC = $classmethod(definitionClass,"updateOneLinkageData","HSPI.Data.Search",patientSearch.%Id(),,,tSkipSynchronization) quit:$$$ISERR(tSC)
		;
		set patientNormalizedId = $classmethod(normalizedClass,"convertOrigOidToNormId",patientSearch.%Oid())
		set patientSearchNormalized = $classmethod(normalizedClass,"%OpenId",patientNormalizedId,,.tSC) quit:$$$ISERR(tSC)
		;
		; apply startswith search, store results in ^CacheTemp(indexTemp,"nid",nid)=mpiid
		set indexTemp = $i(^CacheTemp)
		kill ^CacheTemp(indexTemp)
		;
		set tSC = ..directSearch(pRequest,normalizedClass,indexTemp) quit:$$$ISERR(tSC)
		; compute weight and store results in ^CacheTemp(indexTemp)
		set nid="" for  {
			set nid=$o(^CacheTemp(indexTemp,"nid",nid),1,mpiid) quit:nid=""
			if mpiid="" continue
			set obj = $classmethod(normalizedClass,"%OpenId",nid)
			if $isObject(obj)=0 continue
			set wp = $classmethod(normalizedClass,"getWeightPatternByObj",patientSearchNormalized,obj)
			set linkWeight = +$li(wp,1)
			set nidsGroupedByMPIID(mpiid,nid,linkWeight)=""
			if $d(^CacheTemp(indexTemp,"mpiid",mpiid),weightOld) {
				if linkWeight>weightOld {
					kill ^CacheTemp(indexTemp,"sorted",weightOld,mpiid)
					set ^CacheTemp(indexTemp,"sorted",linkWeight,mpiid)=""
					set ^CacheTemp(indexTemp,"mpiid",mpiid)=linkWeight
				}
			} else {
				set ^CacheTemp(indexTemp,"sorted",linkWeight,mpiid)=""
				set ^CacheTemp(indexTemp,"mpiid",mpiid)=linkWeight
			}
		}
		;
		; find in-memory linkage data by calling buildOneClassifiedDataInMemory
		set validateThreshold = $parameter(classifiedClass,"validateThreshold")
		set minMatchPercentage = pRequest.MinMatchPercentage
		set minWeight = (minMatchPercentage/100)*validateThreshold
		;
		set tSC = patientSearchNormalized.buildOneClassifiedDataInMemory(minWeight,.searchResults) quit:$$$ISERR(tSC)
		;
		for i=1:1:pRequest.MPIIDLIST.Count() set mpiid = pRequest.MPIIDLIST.GetAt(i) if mpiid'="" set identifierConditions("MPIID",mpiid) = ""
		if pRequest.Facility'="" set identifierConditions("Facility") = pRequest.Facility
		if pRequest.AssigningAuthority'="" set identifierConditions("AssigningAuthority") = pRequest.AssigningAuthority
		if pRequest.MRN'="" set identifierConditions("MRN") = pRequest.MRN
		;
		for countResult=1:1:searchResults {
			set nid = $li(searchResults(countResult),1)
			set linkWeight = $li(searchResults(countResult),2)
			;
			set originalClassname = $classmethod(normalizedClass,"convertNormIdToOrigClassname",nid)
			if originalClassname'="HSPI.Data.Patient" continue
			set foundPatient = $classmethod(normalizedClass,"%OpenId",nid)
			;
			if $isObject(foundPatient)=0 continue
			;
			set mpiid = foundPatient.enterpriseId
			if mpiid="" continue
			;
			; check against identifier proeprties
			if $d(identifierConditions),..checkIdentifierConditions(.identifierConditions,mpiid)=0 continue
			;
			; support HSPI.UI.PatientSearch by collecting NID values and link weights
			set nidsGroupedByMPIID(mpiid,nid,linkWeight)=""
			if $d(^CacheTemp(indexTemp,"mpiid",mpiid),weightOld) {
				if linkWeight>weightOld {
					kill ^CacheTemp(indexTemp,"sorted",weightOld,mpiid)
					set ^CacheTemp(indexTemp,"sorted",linkWeight,mpiid)=""
					set ^CacheTemp(indexTemp,"mpiid",mpiid)=linkWeight
				}
			} else {
				set ^CacheTemp(indexTemp,"sorted",linkWeight,mpiid)=""
				set ^CacheTemp(indexTemp,"mpiid",mpiid)=linkWeight
			}
			;
			; count how many we already have that are above linkWeight
			set count=0
			set weight = linkWeight
			for  {
				set mpiid="" for  set mpiid=$o(^CacheTemp(indexTemp,"sorted",weight,mpiid)) quit:mpiid=""  set count = count+1
				set weight=$o(^CacheTemp(indexTemp,"sorted",weight)) quit:weight=""
			}
			;
			if count>=pRequest.MaxMatches quit
		}
		;
		set count=0,logvalue2=""
		set weight="" for { set weight = $o(^CacheTemp(indexTemp,"sorted",weight),-1)  quit:weight=""
			set mpiid="" for { set mpiid = $o(^CacheTemp(indexTemp,"sorted",weight,mpiid))  quit:mpiid=""
				; support HSPI.UI.PatientSearch by returning the NID values associated with each MPIID
				if (returnNormalizedIds) {
					set nid="" for { set nid = $o(nidsGroupedByMPIID(mpiid,nid))  quit:nid=""
						set linkWeight="" for { set linkWeight = $o(nidsGroupedByMPIID(mpiid,nid,linkWeight))  quit:linkWeight=""
							set pNormalizedIdsGroupedByMPIID(weight,mpiid,linkWeight,nid) = ""
						}
					}
				}
				; prepare the search response
				set mpiMatch = ##class(HS.Message.PatientMPIMatch).%New()
				set mpiMatch.MPIID = mpiid
				set mpiMatch.Rank = weight
				set tSC = ..loadComposite(pRequest,mpiMatch,.nobjArray)  Quit:$$$ISERR(tSC)
				set mpiMatch.AssigningAuthority = "$HSPI"
				set mpiMatch.Facility = "$HSPI"
				set mpiMatch.MRN = mpiid
				do pResponse.MPIIDList.Insert(mpiMatch)

				// Deduplicate Identifiers when adding searchMatch MRNs
				for iIdent=mpiMatch.Identifiers.Count():-1:1 { set tIdent = mpiMatch.Identifiers.GetAt(iIdent)
					set hash = $Property(tIdent,"%%OID")  set:'$L(hash)&&$$$ISOK(tIdent.%SerializeObject()) hash = $Property(tIdent,"%%OID")
					set hash = $S($L(hash)<=230:hash, 1:$E(hash,1,220)_".x"_$$$NUM($ZHex($ZCRC($E(hash,221,*),7)),8))
					set identHash(hash) = iIdent
				}
				// Insert source records as SearchMatch elements, with cross reference in MPIMatch.SearchMatches
				set record="" for { set record = $o(nobjArray(record), 1, nobj)  quit:record=""  // pre-screened for the top maxRecords entries
					set searchMatch = ##class(HS.Message.PatientSearchMatch).%New()
					set searchMatch.Facility = nobj.originalObject.Facility
					set searchMatch.CreatedOn = nobj.originalObject.CreatedOn
					set searchMatch.AssigningAuthority = nobj.originalObject.AssigningAuthority
					set searchMatch.MRN = nobj.originalObject.MRN
					set searchMatch.MPIIDListItem = pResponse.MPIIDList.Count()
					set searchMatch.MPIID = mpiid
					set searchMatch.RankOrScore = weight
					do pResponse.Results.Insert(searchMatch)

					do mpiMatch.SearchMatches.Insert(pResponse.Results.Count())

					set ident = ##class(HS.Types.Identifier).%New()
					set ident.Root = searchMatch.AssigningAuthority
					set ident.Extension = searchMatch.MRN
					kill aaType
					set:$$$ISERR(##class(HS.AssignAuth.Config).FindByCode(.aaType,ident.Root,.otherId,.aaName))||'$D(aaName) aaName="", aaType=""
					set ident.AssigningAuthorityName = aaName
					set ident.Use = $S(aaType?.E1"+"1.N:$P(aaType,"+",1,*-1),1:aaType) ; strip off trailing count if there was more than one match
					set hash = $Property(ident,"%%OID")  set:'$L(hash)&&$$$ISOK(ident.%SerializeObject()) hash = $Property(ident,"%%OID")
					set hash = $S($L(hash)<=230:hash, 1:$E(hash,1,220)_".x"_$$$NUM($ZHex($ZCRC($E(hash,221,*),7)),8))
					do:'$D(identHash(hash)) mpiMatch.Identifiers.Insert(ident)				
				}
				set logvalue2 = logvalue2_$lb("MPIID="_mpiid_",Rank="_weight)
				set count = count+1
				quit:count>=pRequest.MaxMatches
			} quit:$$$ISERR(tSC)
			quit:count>=pRequest.MaxMatches
		} quit:$$$ISERR(tSC)
		set pResponse.ResultsCount=pResponse.Results.Count()
		;
	} catch {
		set tSC=$$$ERROR($$$CacheError,$ze)
	}
	;
	; we always clean up searchObject even in case of error
	if '$g(^HSPI.Config("API","retainSearchObject")) {
		try {
			set patientSearchId = $S($IsObject(patientSearch):patientSearch.%Id(), 1:"")
			if patientSearchId '= "" {
				set tSC2 = ##class(HSPI.Data.Search).%DeleteId(patientSearchId)
				if $$$ISERR(tSC2) set tSC = $$$ADDSC(tSC,tSC2)
				set tSC2 = $classmethod(definitionClass,"updateOneLinkageData","HSPI.Data.Search",patientSearchId,$g(comment),$g(source),tSkipSynchronization)
				if $$$ISERR(tSC2) set tSC = $$$ADDSC(tSC,tSC2)
			}
		} catch {
			set tSC = $$$ADDSC(tSC,$$$ERROR($$$CacheError,$ze))
		}
	}
	;
	if logLevel>=2 set ^HSPI.Log(logIndex,$i(logCount))=$g(logvalue2)
	if logLevel>=1 set ^HSPI.Log(logIndex,$i(logCount))=$lb(##class(%UTC).NowLocal(),"tSC="_tSC,"duration="_($zh-zh))
	quit tSC
]]></Implementation>
</Method>

<Method name="checkIdentifierConditions">
<ClassMethod>1</ClassMethod>
<FormalSpec>identifierConditions,mpiid</FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	if $d(identifierConditions("MPIID")),$d(identifierConditions("MPIID",mpiid))=0 quit 0
	if ($d(identifierConditions("Facility"))=0)&&($d(identifierConditions("AssigningAuthority"))=0)&&($d(identifierConditions("MRN"))=0) quit 1
	set found = 0
	&sql(declare FAMCursor CURSOR for select Facility,AssigningAuthority,MRN  into :tFacility,:tAssigningAuthority,:tMRN from HSPI_data.patient where MPIID= :mpiid)
	&sql(open FAMCursor)
	for  {
		&sql(fetch FAMCursor)
		quit:SQLCODE
		if $d(identifierConditions("Facility"))&&(identifierConditions("Facility")'=tFacility) continue
		if $d(identifierConditions("AssigningAuthority"))&&(identifierConditions("AssigningAuthority")'=tAssigningAuthority) continue
		if $d(identifierConditions("MRN"))&&(identifierConditions("MRN")'=tMRN) continue
		set found = 1
	} 
	&sql(close FAMCursor)
	quit found
]]></Implementation>
</Method>

<Method name="loadComposite">
<ClassMethod>1</ClassMethod>
<FormalSpec>pRequest:HS.Message.PatientSearchRequest,pPatient:HS.Message.PatientMPIMatch,*nobjArray</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tSC=$$$OK
	s compClass = ##class(HS.Registry.Config).GetKeyValue("\HSPI\CompositeRecordDefinition","Local.CompositeRecord.Transient.Definition")
	Set tSC = $classmethod(compClass, "getCompositeRecord", pPatient.MPIID, "mostTrusted", .objComposite, .metaResult)  Quit:$$$ISERR(tSC) tSC
	Set tSC = ..copyPatientDataToMessage(objComposite,pPatient)  Quit:$$$ISERR(tSC) tSC
	// Construct nobjArray to collect related source records
	Do {
		// count #groups; overall max record count is #groups x 20 
		// (because about 100 records is a good number but we need a higher maximum for more groups)
		set count = 0
		set group = "" for {
			set group = $o(metaResult("group",group))
			quit:group=""
			set count = $i(count)
		}
		//set ..groupCount = count
		set maxRecords = count * 20 
		
		// look at all records and make the array of top ranked record numbers
		set group = "" for { set group = $o(metaResult("group",group))  quit:group=""
			set groups("total",group) = 0
			set groups("ranked",group) = 0
			set groups("winner",group) = $g(metaResult("group",group,"winner"))
			set groups("isoverride",group) = $g(metaResult("group",group,"isoverride"))
			if (groups("isoverride",group)) {
				set record = "" for { set record = $o(metaResult("group",group,"record",record))  quit:record=""
					set groups("total",group) = $i(groups("total",group))
				}
				set chosen(1,group) = groups("winner",group)
			} else {
				set record = "" for { set record = $o(metaResult("group",group,"record",record))  quit:record=""
					set groups("total",group) = $i(groups("total",group))
					set rank = $g(metaResult("group",group,"record",record,"ranking"))
					if ((rank '= 0) && (rank '= "")) { 
						set chosen(rank,group) = record 
						set groups("ranked",group) = $i(groups("ranked",group))
					}
				}
			}
		}
		// make the normalized object array: iterate by rank, then group, and collect record identifiers; stop when you reach maxRecords
		set count = 0
		set rank = "" for { set rank = $o(chosen(rank))  quit:rank=""
			quit:rank="z"
			set group = "" for {  set group = $o(chosen(rank,group), 1, record)  quit:group=""
				if ('$d(nobjArray(record))) {
					set count = $i(count)
					set nid = $g(metaResult("object",record))
					set nobjArray(record) = nid
					set nobjArray(record,"timeModified") = $g(metaResult("object",record,"timeModified"))
				}
				quit:(count=maxRecords)
			}
			quit:(count=maxRecords)
		}
	} While 0
	Quit tSC
]]></Implementation>
</Method>

<Method name="GetCompositeRecord">
<ClassMethod>1</ClassMethod>
<FormalSpec>pRequest:HS.Message.GetCompositeRecordRequest,*pResponse:HS.Message.GetCompositeRecordResponse</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	if '$$$HSLicensed("Patient Index") quit $$Error^%apiOBJ($$$OperationNotLicensed)
	set logLevel=+$g(^HSPI.LogLevel)
	if logLevel>=1 set logIndex=$i(^HSPI.Log),^HSPI.Log(logIndex,0)=$$$FullMethodName
	if logLevel>=1 set ^HSPI.Log(logIndex,$i(logCount))=pRequest.%Oid()
	if logLevel>=1 set ^HSPI.Log(logIndex,$i(logCount))=$lb(##class(%UTC).NowLocal())
	if logLevel>=2 set ^HSPI.Log(logIndex,$i(logCount))=$lb("MPIID="_pRequest.MPIID)
	set tSC=$$$OK,zh=$zh
	try {
		set definitionClass = ##class(HS.Registry.Config).GetKeyValue("\HSPI\CompositeRecordDefinition","Local.CompositeRecord.Transient.Definition")
		set tSC = $classmethod(definitionClass,"getCompositeRecord",pRequest.MPIID,"mostTrusted",.objComposite) quit:$$$ISERR(tSC)
		set pResponse = ##class(HS.Message.GetCompositeRecordResponse).%New()
		set tSC = ..copyPatientDataToMessage(objComposite,pResponse) quit:$$$ISERR(tSC)
	} catch {
		set tSC=$$$ERROR($$$CacheError,$ze)
	}
	if logLevel>=1 set ^HSPI.Log(logIndex,$i(logCount))=$lb(##class(%UTC).NowLocal(),"tSC="_tSC,"duration="_($zh-zh))
	quit tSC
]]></Implementation>
</Method>

<Method name="GetMPIID">
<ClassMethod>1</ClassMethod>
<FormalSpec>pRequest:HS.Message.GetMPIIDRequest,*pResponse:HS.Message.GetMPIIDResponse</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	if '$$$HSLicensed("Patient Index") quit $$Error^%apiOBJ($$$OperationNotLicensed)
	set logLevel=+$g(^HSPI.LogLevel)
	if logLevel>=1 set logIndex=$i(^HSPI.Log),^HSPI.Log(logIndex,0)=$$$FullMethodName
	if logLevel>=1 set ^HSPI.Log(logIndex,$i(logCount))=pRequest.%Oid()
	if logLevel>=1 set ^HSPI.Log(logIndex,$i(logCount))=$lb(##class(%UTC).NowLocal())
	set tSC=$$$OK,zh=$zh
	Set pResponse=##class(HS.Message.GetMPIIDResponse).%New()
	try {
		for i=1:1:pRequest.PatientIdentifiers.Count() {
			set one = pRequest.PatientIdentifiers.GetAt(i)
			set one.MPIID = ..getOneMPIID(one.Facility,one.AssigningAuthority,one.MRN)
			do pResponse.PatientIdentifiers.Insert(one)
		}
	} catch {
		set tSC=$$$ERROR($$$CacheError,$ze)
	}
	if logLevel>=1 set ^HSPI.Log(logIndex,$i(logCount))=$lb(##class(%UTC).NowLocal(),"tSC="_tSC,"duration="_($zh-zh))
	quit tSC
]]></Implementation>
</Method>

<Method name="getOneMPIID">
<ClassMethod>1</ClassMethod>
<FormalSpec>pFacility:%String="",pAssigningAuthority:%String="",pMRN:%String=""</FormalSpec>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
	set mpiid = ""
	try { &sql( select mpiid into :mpiid from HSPI_Data.Patient where Facility=:pFacility and AssigningAuthority=:pAssigningAuthority and MRN=:pMRN ) } catch (ex) {}
	quit mpiid
]]></Implementation>
</Method>

<Method name="directSearch">
<ClassMethod>1</ClassMethod>
<FormalSpec>pRequest:HS.Message.PatientSearchRequest,normalizedClass:%String,indexTemp:%Integer</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	set tSC=$$$OK
	try {
		set whereClause = ""
		set sqlargs = 0
		set totalLength = 0
		;
		set mpiidCount = pRequest.MPIIDLIST.Count()
		if (mpiidCount > 0) { 
			set mpiidClause = ""
			for i=1:1:mpiidCount {
				set mpiid = pRequest.MPIIDLIST.GetAt(i)
				if (mpiid '= "") {
					set mpiidClause = mpiidClause _ ",'" _ mpiid _ "'"
				}
			}
			if ($L(mpiidClause) > 1) {
				set mpiidClause = $e(mpiidClause,2,*)
				set whereClause = whereClause _ " and mpiid IN (" _ mpiidClause _ ")"
			}
		}
		if pRequest.FirstName'="" {
			set whereClause = whereClause_" and name_given %startswith ?"
			set sqlargs($i(sqlargs)) = pRequest.FirstName
			set totalLength = totalLength+$l(pRequest.FirstName)
		}
		if pRequest.LastName'="" {
			set whereClause = whereClause_" and name_family %startswith ?"
			set sqlargs($i(sqlargs)) = pRequest.LastName
			set totalLength = totalLength+$l(pRequest.LastName)
		}
		if pRequest.Facility'="" {
			set whereClause = whereClause_" and facility = ?"
			set sqlargs($i(sqlargs)) = pRequest.Facility
		}
		if pRequest.AssigningAuthority'="" {
			set whereClause = whereClause_" and assigningauthority = ?"
			set sqlargs($i(sqlargs)) = pRequest.AssigningAuthority
		}
		if pRequest.MRN'="" {
			set whereClause = whereClause_" and mrn = ?"
			set sqlargs($i(sqlargs)) = pRequest.MRN
		}
		if pRequest.DOB'="" {
			if pRequest.DOBRangeEnd'="" {
				set whereClause = whereClause_" and birthdatetime >= ? and birthdatetime < ?"
				set sqlargs($i(sqlargs)) = $zdatetime(pRequest.DOB_",0",3)
				set sqlargs($i(sqlargs)) = $zdatetime((pRequest.DOBRangeEnd+1)_",0",3)
			} else {
				set whereClause = whereClause_" and birthdatetime = ?"
				set sqlargs($i(sqlargs)) = $zdatetime(pRequest.DOB_",0",3)
			}
		}
		;
		if mpiidCount=0,pRequest.MRN="",pRequest.DOB="",totalLength<4 quit
		;
		set sql = "select %ID as id, mpiid from HSPI_Data.Patient where "_$e(whereClause,6,*)
		;
		set statement=##class(%SQL.Statement).%New()
		set tSC = statement.%Prepare(sql) quit:$$$ISERR(tSC)
		set result = statement.%Execute(sqlargs...)
		while result.%Next() {
			set nid = $classmethod(normalizedClass,"convertOrigIdClassnameToNormId",result.id,"HSPI.Data.Patient")
			set ^CacheTemp(indexTemp,"nid",nid)=result.mpiid
		}
		;
	} catch {
		set tSC=$$$ERROR($$$CacheError,$ze)
	}
	quit tSC
]]></Implementation>
</Method>

<Method name="copyPatientDataFromMessage">
<Description>

patient is of type HSPI.Data.Type.Patient but since foundation may not have any HSPI classes we can't have the class in a formalspec
</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>message:HS.Message.AddPatientRequest,patient:HSPI.Data.Patient,copyNull:%Boolean=0,preserveHistory:%Boolean=0</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
#define CopyPropertyWithValue(%copynull,%target,%source,%value) if %copynull||(%source'="") set %target=$s(%source="":"",%source="""""":"",1:%value)
#define CopyProperty(%target,%source) $$$CopyPropertyWithValue(copyNull,%target,%source,%source)
#define CopyMPIID(%target,%source)    $$$CopyPropertyWithValue(0,%target,%source,%source)
#define CopyPropertyIgnoreError(%target,%source) try { $$$CopyProperty(%target,%source) } catch {}
	set tSC=$$$OK
	try {
		set nowUTC = ##class(%UTC).NowUTC()
		; if the primary name is changed and the previous primary name is not empty, then save a historical record in Names
		if preserveHistory {
			if ($lb(patient.Name.Given,patient.Name.Family,patient.Name.Middle,patient.Name.Prefix,patient.Name.Suffix)'=$lb("","","","","")) &&
			   ($lb(patient.Name.Given,patient.Name.Family,patient.Name.Middle,patient.Name.Prefix,patient.Name.Suffix)'=$lb(message.FirstName,message.LastName,message.MiddleName,message.Prefix,message.Suffix)) {
				set history = ##class(HSPI.Data.Type.Name).%New()
				set history.Given = patient.Name.Given
				set history.Family = patient.Name.Family
				set history.Middle = patient.Name.Middle
				set history.Prefix = patient.Name.Prefix
				set history.Suffix = patient.Name.Suffix
				set history.isArchived = 1
				set history.timeArchived = nowUTC
				do patient.Names.Insert(history)
			}
		}
		$$$CopyProperty(patient.Name.Given,message.FirstName)
		$$$CopyProperty(patient.Name.Family,message.LastName)
		$$$CopyProperty(patient.Name.Middle,message.MiddleName)
		$$$CopyProperty(patient.Name.Prefix,message.Prefix)
		$$$CopyProperty(patient.Name.Suffix,message.Suffix)
		$$$CopyPropertyWithValue(copyNull,patient.BirthDateTime,message.DOB,$zd(message.DOB,3))
		$$$CopyProperty(patient.BirthPlace,message.BirthPlace)
		$$$CopyProperty(patient.Gender,message.Sex)
		$$$CopyProperty(patient.MaritalStatus,message.MaritalStatus)
		$$$CopyProperty(patient.ReligiousAffiliation,message.ReligiousAffiliation)
		$$$CopyProperty(patient.Race,message.Race)
		$$$CopyProperty(patient.EthnicGroup,message.EthnicGroup)
		$$$CopyProperty(patient.Language,message.Language)
		$$$CopyProperty(patient.VIP,message.VIP)
		$$$CopyProperty(patient.MothersMaidenSurname,message.MothersMaidenSurname)
		$$$CopyMPIID(patient.MPIID,message.MPIID)
		$$$CopyProperty(patient.Facility,message.Facility)
		$$$CopyProperty(patient.AssigningAuthority,message.AssigningAuthority)
		$$$CopyProperty(patient.MRN,message.MRN)
		$$$CopyProperty(patient.SSN,message.SSN)
		$$$CopyProperty(patient.AdditionalInfo,message.AdditionalInfo)
		;
		; ignore error for backwards compatibility
		$$$CopyPropertyIgnoreError(patient.CreatedBy,message.CreatedBy)
		$$$CopyPropertyIgnoreError(patient.CreatedOn,message.CreatedOn)
		$$$CopyPropertyIgnoreError(patient.LastEnteredBy,message.LastEnteredBy)
		$$$CopyPropertyIgnoreError(patient.LastEnteredOn,message.LastEnteredOn)
		$$$CopyPropertyIgnoreError(patient.DeathTime,message.DeathTime)
		$$$CopyPropertyIgnoreError(patient.FathersName,message.FathersName)
		$$$CopyPropertyIgnoreError(patient.MothersName,message.MothersName)
		$$$CopyPropertyIgnoreError(patient.SpousesName,message.SpousesName)
		$$$CopyPropertyIgnoreError(patient.BirthOrder,message.BirthOrder)
		$$$CopyPropertyIgnoreError(patient.CommunicationPreference,message.CommunicationPreference)
		$$$CopyPropertyIgnoreError(patient.Extension,message.Extension)
		;
		try {
			set clearFields = message.%ClearFields
			for i=1:1:$l(clearFields,",") set one = $p(clearFields,",",i) if one'="" set clearFields(one) = ""
		} catch {
			; ignore error for backwards compatibility
		}
		;
		for nameCollection = "Identifiers","Addresses","Telecoms","Names" {
			if copyNull||$d(clearFields(nameCollection))||($property(message,nameCollection).Count()>0) {
				set objTargetCollection = $property(patient,nameCollection)
				set cntTargetCollection = $property(patient,nameCollection).Count()
				if preserveHistory {
					for i=1:1:cntTargetCollection {
						set objTargetOne = objTargetCollection.GetAt(i)
						if 'objTargetOne.isArchived set objTargetOne.isArchived=1,objTargetOne.timeArchived=nowUTC
					}
				} else {
					do objTargetCollection.Clear()
				}
			}
		}
		;
		for nameCollection = "Identifiers","Addresses","Telecoms","Names" {
			for i=1:1:$property(message,nameCollection).Count() {
				set source = $property(message,nameCollection).GetAt(i)
				set target = $classmethod($property(patient,nameCollection).ElementType,"%New")
				do target.copyProperties(source,copyNull)
				set targetCollection = $property(patient,nameCollection)
				do targetCollection.Insert(target)
			}
		}
		;
		; cull collections to make sure historical data are not duplicates of current data
		for nameCollection = "Identifiers","Addresses","Telecoms","Names" {
			kill toDelete
			set objCollection = $property(patient,nameCollection)
			set cntCollection = objCollection.Count()
			for i=1:1:cntCollection {
				set itemH = objCollection.GetAt(i)
				if 'itemH.isArchived continue
				if $d(toDelete(i)) continue
				if nameCollection="Names" {
					set itemA = patient.Name
					if itemA.isSameAs(itemH) set toDelete(i) = 1
					continue
				}
				for j=1:1:cntCollection {
					set itemA = objCollection.GetAt(j)
					if itemA.isArchived continue
					if itemA.isSameAs(itemH) set toDelete(i) = 1
				}
			}
			; loop toDelete and delete them
			set index="" for  set index = $o(toDelete(index),-1) quit:index=""  do objCollection.RemoveAt(index)
		}
		;
		set patient.LastUpdated = $P($H,",")
		;
	} catch {
		set tSC=$$$ERROR($$$CacheError,$ze)
	}
	quit tSC
]]></Implementation>
</Method>

<Method name="copyPatientDataToMessage">
<ClassMethod>1</ClassMethod>
<FormalSpec>patient:HSPI.Data.Patient,message:HS.Types.PatientInfo</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	set tSC=$$$OK
	try {
		set message.FirstName = patient.Name.Given
		set message.LastName = patient.Name.Family
		set message.MiddleName = patient.Name.Middle
		set message.Prefix = patient.Name.Prefix
		set message.Suffix = patient.Name.Suffix
		set message.DOB = $s(patient.BirthDateTime="":"",1:$zdh(patient.BirthDateTime,3))
		set message.BirthPlace = patient.BirthPlace
		set message.Sex = patient.Gender
		set message.MaritalStatus = patient.MaritalStatus
		set message.ReligiousAffiliation = patient.ReligiousAffiliation
		set message.Race = patient.Race
		set message.EthnicGroup = patient.EthnicGroup
		set message.Language = patient.Language
		set message.VIP = patient.VIP
		set message.MothersMaidenSurname = patient.MothersMaidenSurname
		set message.Facility = patient.Facility
		set message.AssigningAuthority = patient.AssigningAuthority
		set message.MRN = patient.MRN
		set message.SSN = patient.SSN
		set message.AdditionalInfo = patient.AdditionalInfo
		;
		; ignore error for backwards compatibility
		try { set message.CreatedBy = patient.CreatedBy } catch {}
		try { set message.CreatedOn = patient.CreatedOn } catch {}
		try { set message.LastEnteredBy = patient.LastEnteredBy } catch {}
		try { set message.LastEnteredOn = patient.LastEnteredOn } catch {}
		try { set message.DeathTime = patient.DeathTime } catch {}
		try { set message.FathersName = patient.FathersName } catch {}
		try { set message.MothersName = patient.MothersName } catch {}
		try { set message.SpousesName = patient.SpousesName } catch {}
		try { set message.BirthOrder = patient.BirthOrder } catch {}
		try { set message.CommunicationPreference = patient.CommunicationPreference } catch {}
		try { set message.Extension = patient.Extension } catch {}
		;
		for i=1:1:patient.Identifiers.Count() {
			set source = patient.Identifiers.GetAt(i)
			set target = ##class(HS.Types.Identifier).%New()
			set target.Extension = source.Extension
			set target.Root = source.AssigningAuthorityName
			set target.Use = source.Use
			set:$$$ISERR(##class(HS.AssignAuth.Config).FindByCode(target.Use,target.Root,.otherId,.aaName))||'$D(aaName) aaName=""
			set target.AssigningAuthorityName = aaName
			do message.Identifiers.Insert(target)
		}
		for i=1:1:patient.Addresses.Count() {
			set source = patient.Addresses.GetAt(i)
			set target = ##class(HS.Types.Address).%New()
			set target.StreetLine = source.StreetLine
			set target.UnitNumber = source.UnitNumber
			set target.POBox = source.POBox
			set target.County = source.County
			set target.City = source.City
			set target.State = source.State
			set target.PostalCode = source.PostalCode
			set target.Precinct = source.Precinct
			set target.Country = source.Country
			set target.Use = source.Use
			do message.Addresses.Insert(target)
			;
			// Copy selected fields from first address item into obsolete top level properties
			if $I(tFirst)=1 {
				set message.Street = source.StreetLine
				set message.City = source.City
				set message.State = source.State
				set message.Zip = source.PostalCode
			}
		}
		for i=1:1:patient.Telecoms.Count() {
			set source = patient.Telecoms.GetAt(i)
			set target = ##class(HS.Types.Telecom).%New()
			set target.PhoneNumberFull = source.PhoneNumberFull
			set target.URL = source.URL
			set target.Email = source.Email
			set target.Use = source.Use
			do message.Telecoms.Insert(target)
		}
		for i=1:1:patient.Names.Count() {
			set source = patient.Names.GetAt(i)
			set target = ##class(HS.Types.PersonName).%New()
			set target.Family = source.Family
			set target.Given = source.Given
			set target.Middle = source.Middle
			set target.Prefix = source.Prefix
			set target.Suffix = source.Suffix
			set target.Type = source.Type
			do message.Names.Insert(target)
		}
	} catch {
		set tSC=$$$ERROR($$$CacheError,$ze)
	}
	quit tSC
]]></Implementation>
</Method>

<Method name="findPatientsforMPIID">
<ClassMethod>1</ClassMethod>
<FormalSpec>pMPIID:%String,*pListIdentifiers:%Library.ListOfObjects</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	try {
		set tSC=$$$OK
		set pListIdentifiers=##class(%Library.ListOfObjects).%New()
		&sql(declare IdentifiersCursor CURSOR for select MRN,AssigningAuthority  into :tMRN,:tAA from HSPI_data.patient where MPIID= :pMPIID)
		&sql(open IdentifiersCursor)
		for  {
			&sql(fetch IdentifiersCursor)
			quit:SQLCODE
			set tIdentifier = ##class(HS.Types.Identifier).%New()
			set tIdentifier.Root=tAA
			set tIdentifier.Extension=tMRN
			do pListIdentifiers.Insert(tIdentifier)
		} 
		&sql(close IdentifiersCursor)
	} catch ex {
		set tSC = ex.AsStatus()
	}
	quit tSC
]]></Implementation>
</Method>

<Method name="getNormalizedId">
<ClassMethod>1</ClassMethod>
<FormalSpec>normalizedClass,patientFAM,nid</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	set tSC = $$$OK
	set patient = ##class(HSPI.Data.Patient).indexFAMOpen($g(patientFAM("Facility")),$g(patientFAM("AssigningAuthority")),$g(patientFAM("MRN")))
	if $isObject(patient) {
		set nid = $classmethod(normalizedClass,"convertOrigOidToNormId",patient.%Oid())
	} else {
		set tSC = $$$ERROR($$$GeneralError,"Patient doesn't exist: '"_$g(patientFAM("Facility"))_":"_$g(patientFAM("AssigningAuthority"))_":"_$g(patientFAM("MRN"))_"'")
	}
	quit tSC
]]></Implementation>
</Method>

<Method name="linkPair">
<ClassMethod>1</ClassMethod>
<FormalSpec>aPatientFAM,bPatientFAM,comment=""</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	if '$$$HSLicensed("Patient Index") quit $$Error^%apiOBJ($$$OperationNotLicensed)
	set definitionClass = ##class(HS.Registry.Config).GetKeyValue("\HSPI\LinkageDefinition","Local.Linkage.Definition")
	set normalizedClass = $classmethod(definitionClass,"getMetaValue","class:normalized")
	set classifiedClass = $classmethod(definitionClass,"getMetaValue","class:classified")
	set tSC = ..getNormalizedId(normalizedClass,.aPatientFAM,.aid) quit:$$$ISERR(tSC) tSC
	set tSC = ..getNormalizedId(normalizedClass,.bPatientFAM,.bid) quit:$$$ISERR(tSC) tSC
	;
	quit $classmethod(classifiedClass,"linkPair",aid,bid,comment,"HSPI.API:linkPair")
]]></Implementation>
</Method>

<Method name="unlinkPair">
<ClassMethod>1</ClassMethod>
<FormalSpec>aPatientFAM,bPatientFAM,comment=""</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	if '$$$HSLicensed("Patient Index") quit $$Error^%apiOBJ($$$OperationNotLicensed)
	set definitionClass = ##class(HS.Registry.Config).GetKeyValue("\HSPI\LinkageDefinition","Local.Linkage.Definition")
	set normalizedClass = $classmethod(definitionClass,"getMetaValue","class:normalized")
	set classifiedClass = $classmethod(definitionClass,"getMetaValue","class:classified")
	set tSC = ..getNormalizedId(normalizedClass,.aPatientFAM,.aid) quit:$$$ISERR(tSC) tSC
	set tSC = ..getNormalizedId(normalizedClass,.bPatientFAM,.bid) quit:$$$ISERR(tSC) tSC
	;
	quit $classmethod(classifiedClass,"unlinkPair",aid,bid,comment,"HSPI.API:unlinkPair")
]]></Implementation>
</Method>

<Method name="resetPair">
<ClassMethod>1</ClassMethod>
<FormalSpec>aPatientFAM,bPatientFAM,comment=""</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	if '$$$HSLicensed("Patient Index") quit $$Error^%apiOBJ($$$OperationNotLicensed)
	set definitionClass = ##class(HS.Registry.Config).GetKeyValue("\HSPI\LinkageDefinition","Local.Linkage.Definition")
	set normalizedClass = $classmethod(definitionClass,"getMetaValue","class:normalized")
	set classifiedClass = $classmethod(definitionClass,"getMetaValue","class:classified")
	set tSC = ..getNormalizedId(normalizedClass,.aPatientFAM,.aid) quit:$$$ISERR(tSC) tSC
	set tSC = ..getNormalizedId(normalizedClass,.bPatientFAM,.bid) quit:$$$ISERR(tSC) tSC
	;
	quit $classmethod(classifiedClass,"resetPair",aid,bid,comment,"HSPI.API:resetPair")
]]></Implementation>
</Method>

<Method name="changeComment">
<ClassMethod>1</ClassMethod>
<FormalSpec>aPatientFAM,bPatientFAM,comment=""</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	if '$$$HSLicensed("Patient Index") quit $$Error^%apiOBJ($$$OperationNotLicensed)
	set definitionClass = ##class(HS.Registry.Config).GetKeyValue("\HSPI\LinkageDefinition","Local.Linkage.Definition")
	set normalizedClass = $classmethod(definitionClass,"getMetaValue","class:normalized")
	set classifiedClass = $classmethod(definitionClass,"getMetaValue","class:classified")
	set tSC = ..getNormalizedId(normalizedClass,.aPatientFAM,.aid) quit:$$$ISERR(tSC) tSC
	set tSC = ..getNormalizedId(normalizedClass,.bPatientFAM,.bid) quit:$$$ISERR(tSC) tSC
	;
	quit $classmethod(classifiedClass,"changeComment",aid,bid,comment,"HSPI.API:changeComment")
]]></Implementation>
</Method>

<Method name="assignCustomStatus">
<ClassMethod>1</ClassMethod>
<FormalSpec>aPatientFAM,bPatientFAM,customStatus,comment=""</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	if '$$$HSLicensed("Patient Index") quit $$Error^%apiOBJ($$$OperationNotLicensed)
	set definitionClass = ##class(HS.Registry.Config).GetKeyValue("\HSPI\LinkageDefinition","Local.Linkage.Definition")
	set normalizedClass = $classmethod(definitionClass,"getMetaValue","class:normalized")
	set customStatusClass = $classmethod(definitionClass,"getMetaValue","class:customStatus")
	set tSC = ..getNormalizedId(normalizedClass,.aPatientFAM,.aid) quit:$$$ISERR(tSC) tSC
	set tSC = ..getNormalizedId(normalizedClass,.bPatientFAM,.bid) quit:$$$ISERR(tSC) tSC
	;
	quit $classmethod(customStatusClass,"assign",aid,bid,customStatus,comment,"HSPI.API:assignCustomStatus")
]]></Implementation>
</Method>

<Method name="deleteCustomStatus">
<ClassMethod>1</ClassMethod>
<FormalSpec>aPatientFAM,bPatientFAM</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	if '$$$HSLicensed("Patient Index") quit $$Error^%apiOBJ($$$OperationNotLicensed)
	set definitionClass = ##class(HS.Registry.Config).GetKeyValue("\HSPI\LinkageDefinition","Local.Linkage.Definition")
	set normalizedClass = $classmethod(definitionClass,"getMetaValue","class:normalized")
	set customStatusClass = $classmethod(definitionClass,"getMetaValue","class:customStatus")
	set tSC = ..getNormalizedId(normalizedClass,.aPatientFAM,.aid) quit:$$$ISERR(tSC) tSC
	set tSC = ..getNormalizedId(normalizedClass,.bPatientFAM,.bid) quit:$$$ISERR(tSC) tSC
	;
	quit $classmethod(customStatusClass,"delete",aid,bid)
]]></Implementation>
</Method>
</Class>


<Class name="Synthea.InboundHL7Adapter">
<Super>Ens.InboundAdapter</Super>
<TimeChanged>65190,59859.976384</TimeChanged>
<TimeCreated>65190,59859.976384</TimeCreated>

<Property name="CallInterval">
<Type>%Numeric</Type>
<InitialExpression>2000000</InitialExpression>
<Parameter name="MINVAL" value="0.1"/>
</Property>
</Class>


<Class name="Synthea.QueueMetrics">
<Super>%Persistent</Super>
<TimeChanged>65223,52960</TimeChanged>
<TimeCreated>65202,46406.444537</TimeCreated>

<Property name="Type">
<Type>%String</Type>
</Property>

<Property name="Time">
<Type>%String</Type>
</Property>

<Property name="Size">
<Type>%String</Type>
</Property>

<UDLText name="T">
<Content><![CDATA[
// Process that records queue values

]]></Content>
</UDLText>

<Method name="RecordQueues">
<ClassMethod>1</ClassMethod>
<Implementation><![CDATA[
	//Grabs every tracked queue and logs in Synthea.QueueMetrics
	Set tQueueList = $ZSTRIP(^stConfig("QueueList"),"*W") //Config
	Set tListLength = $LENGTH(tQueueList,",")
	
	for i=1:1:tListLength {
		try {
			set tType = $PIECE(tQueueList, ",", i)
			set meter = ##class(Synthea.QueueMetrics).%New()
			set meter.Type = tType
			set meter.Time = $ZDATETIME($H,3,1,3)
			set meter.Size = ^Ens.Queue(tType, 0, "count")
			do meter.%Save()
		}
		catch {}
	}
]]></Implementation>
</Method>

<Method name="EndTrack">
<ClassMethod>1</ClassMethod>
<Implementation><![CDATA[
	//Stops recording data from queues
	set ^stConfig("EndQueueTrack") = 1
]]></Implementation>
</Method>

<Method name="Track">
<ClassMethod>1</ClassMethod>
<FormalSpec>Interval:%Numeric,Limit:%Numeric="-1"</FormalSpec>
<Implementation><![CDATA[
	//Automation of the recording of queues
	set count = 0
	//Backup, should be set before called
	set ^stConfig("EndQueueTrack") = 0
	
	while ((count '= Limit) & '^stConfig("EndQueueTrack")) {
		JOB ..RecordQueues()
		set count = count + 1
		
		hang Interval
	}
]]></Implementation>
</Method>

<Method name="GetEnd">
<ClassMethod>1</ClassMethod>
<FormalSpec>Type,End</FormalSpec>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
	//Returns end of queue activity
	&sql(select MAX("Time") into :Time from Synthea.QueueMetrics where "Time" < :End and not Size = 0)
	return Time
]]></Implementation>
</Method>

<Method name="GetStart">
<ClassMethod>1</ClassMethod>
<FormalSpec>Type,Start</FormalSpec>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
	//Returns beginning of queue activity
	&sql(select MIN("Time") into :Time from Synthea.QueueMetrics where "Time" > :Start and not Size = 0)
	return Time
]]></Implementation>
</Method>

<Method name="GetMax">
<ClassMethod>1</ClassMethod>
<FormalSpec>Type:%String=""</FormalSpec>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
	//Returns highest queue peak and time
	if (Type = "") {
		&sql(select TOP 1 Type, Size, "Time" into :Type, :Size, :Time from Synthea.QueueMetrics order by Size desc)			
	}
	else {
		&sql(select TOP 1 Size, "Time" into :Size, :Time from Synthea.QueueMetrics where Type = :Type order by Size desc)
	}
	return Size_"_"_Type_"_"_Time
]]></Implementation>
</Method>

<Method name="GetDelta">
<ClassMethod>1</ClassMethod>
<FormalSpec>Type,Start,End</FormalSpec>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
	//Returns difference in queue from Start and End
	&sql(select Size into :sSize from Synthea.QueueMetrics where "Time" = :Start)
	&sql(select Size into :eSize from Synthea.QueueMetrics where "Time" = :End)
	return eSize - sSize
]]></Implementation>
</Method>

<Method name="GetMetrics">
<ClassMethod>1</ClassMethod>
<FormalSpec>Start,End</FormalSpec>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
	//Useless, cause if dumps 100 on inbound, inbound passes to MPI
	//If MPI takes care of 1, no max can be on MPI 
	
	set WQ = ..GetMax()
	set wType = $PIECE(WQ, "_", 2)
	set wPeak = $PIECE(WQ, "_", 3)
	set wMax = $PIECE(WQ, "_", 1)
	
	set rStart = ..GetStart(wType, Start, End)
	set rEnd = ..GetEnd(wType, End)
	
	set Rise = ..GetDelta(wType, rStart, wPeak)
	set Fall = ..GetDelta(wType, wPeak, rEnd)
	
	set spChange = ##class(Synthea.Util).DateTimeToDay(rStart) - ##class(Synthea.Util).DateTimeToDay(wPeak)
	set peChange = ##class(Synthea.Util).DateTimeToDay(rStart) - ##class(Synthea.Util).DateTimeToDay(wPeak)

	set spMinutes = spChange * 24*60
	set peMinutes = peChange * 24*60
	
	set riseRate = spChange/spMinutes
	set fallRate = peChange/peMinutes
]]></Implementation>
</Method>

<Storage name="Default">
<Type>%Library.CacheStorage</Type>
<DataLocation>^Synthea.QueueMetricsD</DataLocation>
<DefaultData>QueueMetricsDefaultData</DefaultData>
<IdLocation>^Synthea.QueueMetricsD</IdLocation>
<IndexLocation>^Synthea.QueueMetricsI</IndexLocation>
<StreamLocation>^Synthea.QueueMetricsS</StreamLocation>
<Data name="QueueMetricsDefaultData">
<Value name="1">
<Value>%%CLASSNAME</Value>
</Value>
<Value name="2">
<Value>Type</Value>
</Value>
<Value name="3">
<Value>Time</Value>
</Value>
<Value name="4">
<Value>Size</Value>
</Value>
</Data>
</Storage>
</Class>


<Class name="Synthea.SDAPersistentContainer">
<Super>%Persistent,HS.SDA3.Container</Super>
<TimeChanged>65190,59859.669923</TimeChanged>
<TimeCreated>65190,59859.669923</TimeCreated>

<Storage name="Default">
<Type>%Library.CacheStorage</Type>
<DataLocation>^Synthea.SDAPersiste64C3D</DataLocation>
<DefaultData>SDAPersistentContainerDefaultData</DefaultData>
<IdLocation>^Synthea.SDAPersiste64C3D</IdLocation>
<IndexLocation>^Synthea.SDAPersiste64C3I</IndexLocation>
<StreamLocation>^Synthea.SDAPersiste64C3S</StreamLocation>
<Data name="AdditionalInfo">
<Attribute>AdditionalInfo</Attribute>
<Structure>subnode</Structure>
<Subscript>"AdditionalInfo"</Subscript>
</Data>
<Data name="SDAPersistentContainerDefaultData">
<Value name="1">
<Value>%%CLASSNAME</Value>
</Value>
<Value name="2">
<Value>Patient</Value>
</Value>
<Value name="3">
<Value>Encounters</Value>
</Value>
<Value name="4">
<Value>Alerts</Value>
</Value>
<Value name="5">
<Value>AdvanceDirectives</Value>
</Value>
<Value name="6">
<Value>Allergies</Value>
</Value>
<Value name="7">
<Value>IllnessHistories</Value>
</Value>
<Value name="8">
<Value>SocialHistories</Value>
</Value>
<Value name="9">
<Value>FamilyHistories</Value>
</Value>
<Value name="10">
<Value>Guarantors</Value>
</Value>
<Value name="11">
<Value>Diagnoses</Value>
</Value>
<Value name="12">
<Value>Observations</Value>
</Value>
<Value name="13">
<Value>Problems</Value>
</Value>
<Value name="14">
<Value>PhysicalExams</Value>
</Value>
<Value name="15">
<Value>Procedures</Value>
</Value>
<Value name="16">
<Value>Documents</Value>
</Value>
<Value name="17">
<Value>LabOrders</Value>
</Value>
<Value name="18">
<Value>RadOrders</Value>
</Value>
<Value name="19">
<Value>OtherOrders</Value>
</Value>
<Value name="20">
<Value>Medications</Value>
</Value>
<Value name="21">
<Value>Vaccinations</Value>
</Value>
<Value name="22">
<Value>Appointments</Value>
</Value>
<Value name="23">
<Value>Referrals</Value>
</Value>
<Value name="24">
<Value>ClinicalRelationships</Value>
</Value>
<Value name="25">
<Value>ProgramMemberships</Value>
</Value>
<Value name="26">
<Value>MemberEnrollments</Value>
</Value>
<Value name="27">
<Value>MedicalClaims</Value>
</Value>
<Value name="28">
<Value>CustomObjects</Value>
</Value>
<Value name="29">
<Value>GenomicsOrders</Value>
</Value>
<Value name="30">
<Value>CarePlans</Value>
</Value>
<Value name="31">
<Value>HealthConcerns</Value>
</Value>
<Value name="32">
<Value>Goals</Value>
</Value>
<Value name="33">
<Value>SocialDeterminants</Value>
</Value>
<Value name="34">
<Value>SessionId</Value>
</Value>
<Value name="35">
<Value>ControlId</Value>
</Value>
<Value name="36">
<Value>Action</Value>
</Value>
<Value name="37">
<Value>EventDescription</Value>
</Value>
<Value name="38">
<Value>UpdateECRDemographics</Value>
</Value>
<Value name="39">
<Value>SendingFacility</Value>
</Value>
<Value name="40">
<Value>ObservationGroups</Value>
</Value>
</Data>
</Storage>
</Class>


<Class name="Synthea.SDASplitter">
<Description>
Class for methods to manipulate patient SDA files</Description>
<TimeChanged>65190,59859.380937</TimeChanged>
<TimeCreated>65190,59859.380937</TimeCreated>

<Method name="ReadPatientFile">
<Description><![CDATA[
Usage: set st = ##class(PatientManip.SDASplitter).ReadPatientFile(pPatientPath, .pPatientObj) <br>
Puts patient data from an SDA file into a container object for easy manipulation <br>
pPatientPath - the file path of the patient file to read <br>
pPatientObj  - that patient file in an SDA3 container object <br>]]></Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>pPatientPath:%String,*pPatientObj:HS.SDA3.Container</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
		
		
		set tReader = ##class(%XML.Reader).%New()
		set tSC = tReader.OpenFile(pPatientPath)
		if '$$$ISOK(tSC) return tSC
		
		
		do tReader.Correlate("Container", "HS.SDA3.Container")
		do tReader.Next(.pPatientObj, .tSC)
		
		
		return tSC
]]></Implementation>
</Method>

<Method name="SplitSDAByEncounter">
<Description><![CDATA[
Usage: set outputList = ##class(pPatientObj) <br>
Takes an SDA container object and an array for output, splits the SDA by date, and places the resulting new SDA container objects in the array <br>
Returns a %ListOfObjects, not a status <br>
pPatientObj - the patient container object to be split <br>]]></Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>pPatientObj:HS.SDA3.Container</FormalSpec>
<ReturnType>%ListOfObjects</ReturnType>
<Implementation><![CDATA[
		set tNumNewSDAs = pPatientObj.Encounters.Size
		set tDateKeyArray = "" //one way to access SDAs--by date
		set tEncounterNumberKeyArray = "" //another way to access SDAs--by encounter number
		set tNewSDAList = ##class(%ListOfObjects).%New() //another way to access SDAs--by numerical key
		
		//loop through total number of encounters, and create new SDAs with constant info and one encounter each
		for i = 1:1:tNumNewSDAs {
					
			//only generate a new SDA if the encounter's date is NOT a match to a previous encounter (since they are in chronological order, it compares with the previous encounter)
			if i > 1 {
				if $EXTRACT(pPatientObj.Encounters.GetAt(i).FromTime, 1, 10) '= $EXTRACT(pPatientObj.Encounters.GetAt(i-1).FromTime, 1, 10) { //if dates don't match, generate new SDA
					//write !, "Stacking encounter"
					do tNewSDAList.Insert(##class(HS.SDA3.Container).%New())
				}
			} else { //if this is the first iteration, generate a new SDA
				//write !, "Entry number: ", tNewSDAList.Previous("")
				do tNewSDAList.Insert(##class(HS.SDA3.Container).%New())
			}
			
			//add the selected encounter to the right SDA
			do tNewSDAList.GetAt(tNewSDAList.Previous("")).Encounters.Insert(pPatientObj.Encounters.GetAt(i).%ConstructClone(1))

			//set constants that all new SDAs will have
			set tNewSDAList.GetAt(tNewSDAList.Previous("")).SendingFacility = pPatientObj.SendingFacility //string
			set tNewSDAList.GetAt(tNewSDAList.Previous("")).EventDescription = pPatientObj.EventDescription //string
			set tNewSDAList.GetAt(tNewSDAList.Previous("")).Patient = pPatientObj.Patient.%ConstructClone(1)
			set tNewSDAList.GetAt(tNewSDAList.Previous("")).Allergies = pPatientObj.Allergies.%ConstructClone(1)
			//set tNewSDAList.GetAt(tNewSDAList.Previous("")).FamilyHistories = pPatientObj.FamilyHistories.%ConstructClone(1) //NOT GENERATED BY SYNTHEA
			//set tNewSDAList.GetAt(tNewSDAList.Previous("")).SocialHistories = pPatientObj.SocialHistories.%ConstructClone(1) //NOT GENERATED BY SYNTHEA
			//set tNewSDAList.GetAt(tNewSDAList.Previous("")).SocialDeterminants = pPatientObj.SocialDeterminants.%ConstructClone(1) //NOT GENERATED BY SYNTHEA
			//set tNewSDAList.GetAt(tNewSDAList.Previous("")).IllnessHistories = pPatientObj.IllnessHistories.%ConstructClone(1) //NOT GENERATED BY SYNTHEA
			
						
			//link the keyed arrays to the rest
			set tDateKeyArray(pPatientObj.Encounters.GetAt(i).FromTime) = tNewSDAList.GetAt(tNewSDAList.Previous(""))
			set tEncounterNumberKeyArray(pPatientObj.Encounters.GetAt(i).EncounterNumber) = tNewSDAList.GetAt(tNewSDAList.Previous(""))
			
		}

		//loop through documents to populate corresponding SDAs - NOT GENERATED BY SYNTHEA
		//if pPatientObj.Documents.Size > 0 set st = ..SearchStreamletsForMatches(pPatientObj, pPatientObj.Documents, "FromTime", "", "Documents", .tDateKeyArray, .tEncounterNumberKeyArray)

		//loop through observations to populate corresponding SDAs
		if pPatientObj.Observations.Size > 0 set st = ..SearchStreamletsForMatches(pPatientObj, pPatientObj.Observations, "ObservationTime", "", "Observations", .tDateKeyArray, .tEncounterNumberKeyArray)

		//loop through physical exams to populate corresponding SDAs - NOT GENERATED BY SYNTHEA
		//if pPatientObj.PhysicalExams.Size > 0 set st = ..SearchStreamletsForMatches(pPatientObj, pPatientObj.PhysicalExams, "FromTime", "", "PhysicalExams", .tDateKeyArray, .tEncounterNumberKeyArray)		

		//loop through diagnoses to populate corresponding SDAs - NOT GENERATED BY SYNTHEA
		//if pPatientObj.Diagnoses.Size > 0 set st = ..SearchStreamletsForMatches(pPatientObj, pPatientObj.Diagnoses, "FromTime", "", "Diagnoses", .tDateKeyArray, .tEncounterNumberKeyArray)		

		//loop through problems to populate corresponding SDAs
		if pPatientObj.Problems.Size > 0 set st = ..SearchStreamletsForMatches(pPatientObj, pPatientObj.Problems, "FromTime", "", "Problems", .tDateKeyArray, .tEncounterNumberKeyArray)
		
		//loop through procedures to populate corresponding SDAs
		if pPatientObj.Procedures.Size > 0 set st = ..SearchStreamletsForMatches(pPatientObj, pPatientObj.Procedures, "ProcedureTime", "", "Procedures", .tDateKeyArray, .tEncounterNumberKeyArray)		
		
		//loop through lab orders to populate corresponding SDAs
		if pPatientObj.LabOrders.Size > 0 set st = ..SearchStreamletsForMatches(pPatientObj, pPatientObj.LabOrders, "Result", "ResultTime", "LabOrders", .tDateKeyArray, .tEncounterNumberKeyArray)
		
		//loop through radiology orders to populate corresponding SDAs - NOT GENERATED BY SYNTHEA
		//if pPatientObj.RadOrders.Size > 0 set st = ..SearchStreamletsForMatches(pPatientObj, pPatientObj.RadOrders, "FromTime", "", "RadOrders", .tDateKeyArray, .tEncounterNumberKeyArray)
		
		//loop through other orders to populate corresponding SDAs - NOT GENERATED BY SYNTHEA
		//if pPatientObj.OtherOrders.Size > 0 set st = ..SearchStreamletsForMatches(pPatientObj, pPatientObj.OtherOrders, "FromTime", "", "OtherOrders", .tDateKeyArray, .tEncounterNumberKeyArray)
		
		//loop through medications to populate corresponding SDAs
		if pPatientObj.Medications.Size > 0 set st = ..SearchStreamletsForMatches(pPatientObj, pPatientObj.Medications, "FromTime", "", "Medications", .tDateKeyArray, .tEncounterNumberKeyArray)

		//loop through vaccinations to populate corresponding SDAs
		if pPatientObj.Vaccinations.Size > 0 set st = ..SearchStreamletsForMatches(pPatientObj, pPatientObj.Vaccinations, "FromTime", "", "Vaccinations", .tDateKeyArray, .tEncounterNumberKeyArray)
		
		return tNewSDAList
]]></Implementation>
</Method>

<Method name="SearchStreamletsForMatches">
<Description><![CDATA[
Usage: set st = ##class(.PatientManipulator).SearchStreamletsForMatches(pPatientObj, pStreamletList, pDateType, pDateSubType, pStreamletName, pDateKeyArray, pEncounterNumberKeyArray) <br>
Helper method that searches through a streamlet list and matches each element to one of the previously-generated SDAs <br>
pPatientObj    			- the patient container object to be searched <br>
pStreamletList 			- the list of streamlets of the given category to be searched <br>
pDateType      			- the name of the streamlet containing the date in the container object <br>
pDateSubType   			- if there are two layers of streamlets to get to the date, this is the second layer (optional) <br>
pStreamletName 			- the name of the category of streamlets to be searched <br>
pDateKeyArray  			- an array with dates as keys, used for matching streamlets to encounters <br>
pEncounterNumberKeyArray - an array with encounter numbers as keys, used for matching streamlets to encounters <br>]]></Description>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pPatientObj:HS.SDA3.Container,pStreamletList:%ListOfObjects,pDateType:%String,pDateSubType:%String,pStreamletName:%String,&pDateKeyArray:HS.SDA3.Container,&pEncounterNumberKeyArray:HS.SDA3.Container]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
		//write !, pStreamletName
		set tNumStreamlets = pStreamletList.Size
		for i = 1:1:tNumStreamlets {
			if pStreamletList.GetAt(i).EncounterNumber = "" {
			
				//check for nested date string (only supports one extra level)
				if pDateSubType '= "" {
					set tSelectedDate = $PROPERTY($PROPERTY(pStreamletList.GetAt(i), pDateType), pDateSubType)
				} else {
					set tSelectedDate = $PROPERTY(pStreamletList.GetAt(i), pDateType)
				}
				
				//set encounter number, since none was detected
				if $GET(pDateKeyArray(tSelectedDate)) '= "" {
					set tSelectedSDA = pDateKeyArray(tSelectedDate)
					set tNumEncounters = tSelectedSDA.Encounters.Size
					
					if tNumEncounters > 1 { //if more than one encounter, scan them all to see which one is the right time
						for j = 1:1:tNumEncounters {
							if tSelectedSDA.Encounters.GetAt(j).FromTime = tSelectedDate {
								set pStreamletList.GetAt(i).EncounterNumber = tSelectedSDA.Encounters.GetAt(j).EncounterNumber
							}
						}
					} else { //if only one encounter, that is automatically the right one
						set pStreamletList.GetAt(i).EncounterNumber = pDateKeyArray(tSelectedDate).Encounters.GetAt(1).EncounterNumber
					}
					
					//add this streamlet to the right SDA
					set st = ..AddToSDAByIdentifier(tSelectedDate, .pDateKeyArray, .pStreamletList, pStreamletName, i)
					
				} else {
					//write !, "No encounter found for ", pStreamletName, " at time ", tSelectedDate
				}
				
			} else { //if an encounter number is available, match by encounter number
				set tSelectedEncounterNumber = pStreamletList.GetAt(i).EncounterNumber
				set st = ..AddToSDAByIdentifier(tSelectedEncounterNumber, .pEncounterNumberKeyArray, .pStreamletList, pStreamletName, i)
			}
		}
		return 1
]]></Implementation>
</Method>

<Method name="AddToSDAByIdentifier">
<Description><![CDATA[
Usage: set st = ##class(.PatientManipulator).AddToSDAByIdentifier(pIdentifier, pIdentifierKeyArray, pStreamletList, pPropertyName, pIndex) <br>
Internal utility method to clean up encounter number reading in SplitSDAByEncounter <br>
pIdentifier		   - the pIdentifier (date or encounter number) to be matched against the pIdentifierKeyArray <br>
pIdentifierKeyArray - the array of identifiers (dates or encounter numbers) to be checked against <br>
pStreamletList 	   - the list of this given streamlet type to be searched <br>
pPropertyName	   - the name of the property/streamlet being added to the SDA <br>
pIndex			   - the pIndex of the streamlet being added, to be used with pStreamletList <br>]]></Description>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pIdentifier:%String,&pIdentifierKeyArray:HS.SDA3.Container,&pStreamletList:%ListOfObjects,pPropertyName:%String,pIndex:%Integer]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
		
		//if encounter number is valid, insert this streamlet into the SDA for that encounter
		if pIdentifierKeyArray(pIdentifier) '= "" {
			set tNewStreamlet = pStreamletList.GetAt(pIndex).%ConstructClone(1)
			set tNewDestination = $PROPERTY(pIdentifierKeyArray(pIdentifier), pPropertyName)
			do tNewDestination.Insert(tNewStreamlet)
		} else {
			write !, "Invalid pIdentifier: ", pIdentifier
			return 0
		}
		
		return 1
]]></Implementation>
</Method>

<Method name="WritePatientFile">
<Description><![CDATA[
Usage: set st = ##class(.PatientManipulator).WritePatientFile(pOutputPath, pPatientObj) <br>
Takes an SDA container object and saves it as an XML file <br>
pOutputPath - the file path for the file to be written <br>
pPatientObj - the patient container object to be written as a file <br>]]></Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>pOutputPath:%String,pPatientObj:HS.SDA3.Container</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
		
		//SLOW non-SDA (standard XML) way to write an XML-enabled container
		/* 
		//set tStartTime = $EXTRACT($NOW(), 7, 20)
		set writer = ##class(%XML.Writer).%New()
		set writer.Indent = 1
		//set tEndTime = $EXTRACT($NOW(), 7, 20) write !, "Time elapsed to create XML.Writer class: ", tEndTime - tStartTime, " seconds"
		
		//set tStartTime = $EXTRACT($NOW(), 7, 20)
		set st = writer.OutputToFile(pOutputPath)
		if '$$$ISOK(st) return st
		//set tEndTime = $EXTRACT($NOW(), 7, 20) write !, "Time elapsed to set output path: ", tEndTime - tStartTime, " seconds"
		
		//set tStartTime = $EXTRACT($NOW(), 7, 20)		
		set st = writer.StartDocument()
		if '$$$ISOK(st) return st
		//set tEndTime = $EXTRACT($NOW(), 7, 20) write !, "Time elapsed to start writing: ", tEndTime - tStartTime, " seconds"
			
		//set tStartTime = $EXTRACT($NOW(), 7, 20)	
		set st = writer.RootObject(pPatientObj)
		if '$$$ISOK(st) return st
		//set tEndTime = $EXTRACT($NOW(), 7, 20) write !, "Time elapsed to set root object: ", tEndTime - tStartTime, " seconds"
		
		//set tStartTime = $EXTRACT($NOW(), 7, 20)
		set st = writer.EndDocument()
		if '$$$ISOK(st) return st
		//set tEndTime = $EXTRACT($NOW(), 7, 20) write !, "Time elapsed to end writing: ", tEndTime - tStartTime, " seconds"
		*/
		
		//FASTEST (?) SDA-specific way to write an SDA container
		
		set tOutputStream = ##class(%Stream.FileCharacter).%New()
		set tOutputStream.Filename = pOutputPath
		set tSC = pPatientObj.ToQuickXMLStream(.tOutputStream)
		if '$$$ISOK(tSC) return tSC
		set st = tOutputStream.%Save() //overridden for %FileBinary, so should save to file, not to database
		
		//FASTER SDA-specific way to write an SDA container
		
		/*
		set tSC = pPatientObj.ToQuickXMLStream(.tOutputStream)
		
		set file = ##class(%File).%New(pOutputPath)
		do file.Open("WSN") //"WSN" means that this will create or overwrite a file at the chosen path
		
		//transcribe the stream to the opened text file
		while 'tOutputStream.AtEnd {
			set line = tOutputStream.Read()
			set st = file.Write(line)
			if st '= 1 do $system.Status.DisplayError(st) return st
		} */
		
		return 1
]]></Implementation>
</Method>

<Method name="WriteHL7toDB">
<Description>
2019-05-06 - Kuljeet Tuteja
Added this method to handle new requirement write HL7 string to database 
Leveraging existing code and making mininmal modifcation to all other supporting classes/scripts</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>pPatientObj:HS.SDA3.Container</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	#dim tHL7 as EnsLib.HL7.Message
	Set tSC = $$$OK
		
	Do pPatientObj.ToQuickXMLStream(.tStream)
	Set tVDoc=##class(EnsLib.EDI.XML.Document).ImportFromLibraryStream(tStream)
	Quit:$$$ISERR(tSC)
	Set tVDoc.DocType="HS.SDA3:Container"
		
	//transform message
	Set tSC = ##class(Synthea.SDAtoADTA08Transformation).Transform(tVDoc,.tHL7)
	Quit:$$$ISERR(tSC)
	
	Set tSyntheaRow = ##class(Synthea.HL7Table).%New()
	//Set tSyntheaRow.HL7 = tHL7
	Set tSyntheaRow.HL7 = tHL7.RawContent
	
	Set tSyntheaRow.EncounterDate = pPatientObj.Encounters.GetAt(1).FromTime
	Set tSyntheaRow.MRN = pPatientObj.Patient.PatientNumbers.GetAt(1).Number
	Set tSyntheaRow.PatientSeed = pPatientObj.Patient.PatientNumbers.GetAt(2).Number
	Set tSyntheaRow.PopulationSeed = pPatientObj.Patient.PatientNumbers.GetAt(3).Number
	Set tSyntheaRow.Facility = pPatientObj.SendingFacility
	Set tSyntheaRow.DateCreated = $ZDATE($PIECE($NOW(),",",1),3)
	Do tSyntheaRow.%Save()
	
	return tSC
]]></Implementation>
</Method>

<Method name="AutomatedSplitSDA">
<Description><![CDATA[
Usage: set st = ##class(.PatientManipulator).AutomatedSplitSDA(pInputPath, pOutputPath) <br>
Takes the path of an SDA file and the path of a destination directory, splits the SDA file, and puts the resulting SDAs in the destination directory, ordered by date <br>
pInputPath  - the path of the file to be split <br>
pOutputPath - the path of the folder where the split files will be placed <br>]]></Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>pInputPath:%String="C:\Users\dkirk\synthea\output\sda\Destiny_Jakolsky.xml",pOutputPath:%String="C:\Users\dkirk\synthea\output\sda\split\",pFuturePath="/home/synthea/output/sdarepo/split"</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	
		
		//read the input SDA and split it
		//set tStartTime = $EXTRACT($NOW(), 7, 20)
		//write !, "Reading file... "
		set tSC = ..ReadPatientFile(pInputPath, .pPatientObj)
		if '$$$ISOK(tSC) Quit
		//set tEndTime = $EXTRACT($NOW(), 7, 20) write ?30, "Time elapsed: ", tEndTime - tStartTime, " seconds", ?90, "[DONE]"
		
		//set tStartTime = $EXTRACT($NOW(), 7, 20)
		//write !, "Splitting SDA... "
		set tOutputList = ..SplitSDAByEncounter(pPatientObj)
		set tSize = tOutputList.Size
		//set tEndTime = $EXTRACT($NOW(), 7, 20) write ?30, "Time elapsed: ", tEndTime - tStartTime, " seconds", ?90, "[DONE]"
		 
		
		//save all new SDAs to output directory with name in the format [DATE]_[FIRSTNAME]_[LASTNAME].xml
		//set tStartTime = $EXTRACT($NOW(), 7, 20)
		//write !, "Writing new files... "
		set tFirstName = tOutputList.GetAt(1).Patient.Name.GivenName
		set tLastName = tOutputList.GetAt(1).Patient.Name.FamilyName
		
		for i = 1:1:tSize {
			s tFromTime = tOutputList.GetAt(1).Encounters.GetAt(1).FromTime
			set MRN = tOutputList.GetAt(1).Patient.PatientNumbers.GetAt(1).Number
			set HospitalName = tOutputList.GetAt(1).Encounters.GetAt(1).HealthCareFacility.Code
				
			/*if ($ZDATEH(tFromTime,3) < $p($h,",",1)){
				set tFilename = pOutputPath_ "/Data/"_HospitalName_"/SD/"_$EXTRACT(tFromTime, 1, 10) _ "_" _ tFirstName _ "_" _ tLastName _ ".xml"
			}
			else{
				set tFilename = pFuturePath _"/"_HospitalName_"/"_ $EXTRACT(tFromTime, 1, 10) _"/"_$EXTRACT(tFromTime, 1, 10)_ "_" _ tFirstName _ "_" _ tLastName _ "-"_MRN_".xml"
			    write !, tFilename
			}*/
			
			//set tFilename = "/home/ktutectr/output/hl7/"_$EXTRACT(tFromTime, 1, 10) _ "_" _ tFirstName _ "_" _ tLastName _ ".xml"
			
			//set tSC = ..WritePatientFile(tFilename,tOutputList.GetAt(1))
			
			set tSC = ..WriteHL7toDB(tOutputList.GetAt(1))
			
			if tSC '= 1 {
				do $system.Status.DisplayError(tSC)
				return tSC
			}
			do tOutputList.RemoveAt(1) //IMPORTANT--prevents running out of memory
			//write !, tFilename
			if '$$$ISOK(tSC) Quit
		}
		//set tEndTime = $EXTRACT($NOW(), 7, 20) write ?30, "Time elapsed: ", tEndTime - tStartTime, " seconds", ?90, "[DONE]"
		
		//set tEndTime = $EXTRACT($NOW(), 7, 20) write !, "Time elapsed do everything: ", tEndTime - tStartTime, " seconds"
		return 1
]]></Implementation>
</Method>

<Method name="SplitDirectory">
<Description><![CDATA[
Usage: set st = ##class(.PatientManipulator).SplitDirectory(pInputDir, pOutputDir) <br>
Goes through a folder and splits each SDA in it--assumes all files are SDAs <br>
pInputDir  - the path of the directory containing the SDAs to be split <br>
pOutputDir - the path of the directory where the split files will go <br>]]></Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>pInputDir:%String="/home/synthea/output/sdarepo",pOutputDir:%String="/home/synthea/output/sdarepo/split",pFutureDirectory:%String="/home/synthea/output/sdarepo/split/future",pFilename:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
		
		set tStartTime = $EXTRACT($NOW(), 7, 20)
		
		Set tSC = ..GetFilesFromSourceDirectory(pInputDir, pOutputDir, .pArray, pFilename)
		If $$$ISERR(tSC) {
			do $system.Status.DisplayError(tSC)
			Return tSC
		}
			
		For tFileCounter = 1:1:pArray {
			set tSelectedFilePath = pArray(tFileCounter, "PathAndName")
			
			if $EXTRACT(tSelectedFilePath, *-3, *) '= ".xml" {
				write !, "Not XML: ", tSelectedFilePath
			}
			write !, "Splitting ", pArray(tFileCounter, "Name")
			set tSC = ..AutomatedSplitSDA(tSelectedFilePath, pOutputDir, pFutureDirectory)
		
			kill pArray(tFileCounter) //removes this array element from memory
		}
		
		// KT - remove SDA file, we are done with it at this point
		//Set tSC = $ZF(-100,"","sudo","rm","-f",tSelectedFilePath)
		
		set tEndTime = $EXTRACT($NOW(), 7, 20)
		write !, "Time elapsed: ", tEndTime - tStartTime, " seconds"
		
		return tSC
]]></Implementation>
</Method>

<Method name="GetFilesFromSourceDirectory">
<Description><![CDATA[
Usage: set st = ##class(.PatientManipulator).GetFilesFromSourceDirectory(pSourceDirectory, pTargetDirectory, pArray) <br>
Taken from qd.user.ImportSyntheaData <br>
pSourceDirectory - the directory to be read
pTargetDirectory - a directory that may be used for file output <br>
pArray 			 - an array of file names and file paths for every file in pSourceDirectory <br>]]></Description>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pSourceDirectory:%String,pTargetDirectory:%String,&pArray,pFilename:%String]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
		If (##class(%File).DirectoryExists(pSourceDirectory)=0) {
			Quit $$$ERROR(5001,"Source directory does not exist  "_pSourceDirectory)
		}
		If (##class(%File).DirectoryExists(pTargetDirectory)=0) {
			Quit $$$ERROR(5001,"Target directory does not exist  "_pTargetDirectory)
		}
		
		Set tSC = ##class(QDHS.Util.Files).GetFiles(pSourceDirectory, .pArray, , pFilename)
		If $$$ISERR(tSC) {
			do $system.Status.DisplayError(tSC)
			Quit tSC
		}
		Quit $$$OK
]]></Implementation>
</Method>
</Class>


<Class name="Synthea.SDAtoADTA08Transformation">
<Description>
******************* KT 2019-01-09 *******************
Created for purposes of Stress Test project
This class will:
1. Transform the SDA to HL7 ADT^A08
*****************************************************</Description>
<Super>Ens.DataTransformDTL</Super>
<TimeChanged>65190,59860.38035</TimeChanged>
<TimeCreated>65190,59860.38035</TimeCreated>
<DependsOn>EnsLib.EDI.XML.Document,EnsLib.HL7.Message</DependsOn>

<Parameter name="IGNOREMISSINGSOURCE">
<Default>1</Default>
</Parameter>

<Parameter name="REPORTERRORS">
<Default>1</Default>
</Parameter>

<XData name="DTL">
<XMLNamespace>http://www.intersystems.com/dtl</XMLNamespace>
<Data><![CDATA[
<transform sourceClass='EnsLib.EDI.XML.Document' targetClass='EnsLib.HL7.Message' sourceDocType='HS.SDA3:Container' targetDocType='2.5.1:ADT_A01' create='new' language='objectscript' >
<code>
<![CDATA[ 
 #;
 #; MSH  
 #; 
]]]]><![CDATA[></code>
<assign value='"|"' property='target.{MSH:1}' action='set' />
<assign value='"^~\&amp;"' property='target.{MSH:2}' action='set' />
<assign value='source.GetValueAt("/Container/SendingFacility")' property='tFacilityName' action='set' />
<assign value='"{XX}"' property='target.{MSH:4.1}' action='set' />
<assign value='..Lookup("FacilityNameToNISTID",target.{MSH:4.1})' property='target.{MSH:4.2}' action='set' />
<assign value='"NPI"' property='target.{MSH:4.3}' action='set' />
<assign value='##class(HS.Gateway.SDA3.SDA3ToHL7.TransformUtil).DateTime()' property='target.{MSH:7}' action='set' />
<assign value='"ADT^A08"' property='target.{MSH:9}' action='set' />
<assign value='$ZTS' property='target.{MSH:10}' action='set' />
<assign value='"P"' property='target.{MSH:11}' action='set' />
<assign value='"2.5.1"' property='target.{MSH:12}' action='set' />
<assign value='"PH_SS-NoAck^SS Sender^2.16.840.1.114222.4.10.3^ISO"' property='target.{MSH:21}' action='set' />
<code>
<![CDATA[ 
 #;
 #; EVN
 #; 
]]]]><![CDATA[></code>
<assign value='target.{MSH:4}' property='target.{EVN:EventFacility}' action='set' />
<assign value='##class(HS.Gateway.SDA3.SDA3ToHL7.TransformUtil).DateTime(,1)' property='target.{EVN:RecordedDateTime}' action='set' />
<code>
<![CDATA[ 
 #;
 #; PID
 #; 
]]]]><![CDATA[></code>
<assign value='##class(EnsLib.EDI.XML.Document).ImportFromString("&lt;Patient&gt;"_source.GetValueAt("/Container/Patient/")_"&lt;/Patient&gt;")' property='tPatient' action='set' />
<subtransform class='HS.Gateway.SDA3.SDA3ToHL7.SubTransform.PatientToPID' targetObj='target.{PID}' sourceObj='tPatient' />
<foreach property='target.{PID:3()}' key='k1' >
<annotation>Change MRN to MR</annotation>
<if condition='target.{PID:3(k1).5}="MRN"' >
<true>
<assign value='"MR"' property='target.{PID:3(k1).5}' action='set' />
</true>
</if>
<assign value='""' property='target.{PID:3(k1).4}' action='set' />
<assign value='source.GetValueAt("/Container/Patient/PatientNumbers/PatientNumber/Organization/Code")' property='target.{PID:3(k1).4}' action='set' />
</foreach>
<if condition='target.{PID:30}="N"' >
<true>
<assign value='""' property='target.{PID:30}' action='set' />
</true>
</if>
<code>
<![CDATA[ 
 #;
 #; All this is just removing un-used parts to make comparisons easier
 #; Not strictly necessary
]]]]><![CDATA[></code>
<assign value='""' property='target.{PID:5(1).7}' action='set' />
<assign value='""' property='target.{PID:15}' action='set' />
<assign value='""' property='target.{PID:16}' action='set' />
<assign value='""' property='target.{PID:17}' action='set' />
<if condition='$Length(target.{PID:10})' >
<true>
<assign value='target.{PID:10}' property='target.{PID:33}' action='set' />
<assign value='""' property='target.{PID:10}' action='set' />
<assign value='target.{PID:33.1}' property='target.{PID:10.1}' action='set' />
<assign value='target.{PID:33.2}' property='target.{PID:10.2}' action='set' />
<assign value='target.{PID:33.3}' property='target.{PID:10.3}' action='set' />
</true>
</if>
<if condition='$Length(target.{PID:22})' >
<true>
<assign value='target.{PID:22}' property='target.{PID:33}' action='set' />
<assign value='""' property='target.{PID:22}' action='set' />
<assign value='target.{PID:33.1}' property='target.{PID:22.1}' action='set' />
<assign value='target.{PID:33.2}' property='target.{PID:22.2}' action='set' />
<assign value='target.{PID:33.3}' property='target.{PID:22.3}' action='set' />
</true>
</if>
<assign value='$Extract(target.{PID:29},1,12)' property='target.{PID:29}' action='set' />
<assign value='""' property='target.{PID:33}' action='set' />
<assign value='""' property='target.{PID:34}' action='set' />
<code>
<![CDATA[ 
 #;
 #; PV1/PV2
 #; 
]]]]><![CDATA[></code>
<if condition='+$Length(source.{/Container/Encounters/[1]})' >
<true>
<assign value='##class(EnsLib.EDI.XML.Document).ImportFromString("&lt;Encounter&gt;"_source.{/Container/Encounters/[1]}_"&lt;/Encounter&gt;")' property='tEncounter' action='set' />
<subtransform class='HS.Gateway.SDA3.SDA3ToHL7.SubTransform.EncounterToPV1' targetObj='target.{PV1}' sourceObj='tEncounter' />
<code>
<![CDATA[ 
 #;
 #; PV2
 #; 
]]]]><![CDATA[></code>
<assign value='$Extract(target.{PV1:44},1,12)' property='target.{PV1:44}' action='set' >
<annotation>Strictly not necessary just for comparison reasons</annotation>
</assign>
<if condition='+$Length(source.{/Container/Encounters/[1]/AdmitReason/Code})' >
<true>
<subtransform class='HS.Gateway.SDA3.SDA3ToHL7.SubTransform.EncounterToPV2' targetObj='target.{PV2}' sourceObj='tEncounter' />
</true>
</if>
</true>
</if>
<code>
<![CDATA[ 
 #;
 #; DG1
 #; 
]]]]><![CDATA[></code>
<foreach property='source.{Diagnoses()}' key='k1' >
<assign value='k1' property='target.{DG1(k1):SetIDDG1}' action='set' />
<assign value='source.GetValueAt("/Container/Diagnoses/["_k1_"]/Diagnosis/Code")' property='target.{DG1(k1):DiagnosisCodeDG1.Identifier}' action='set' />
<assign value='source.GetValueAt("/Container/Diagnoses/["_k1_"]/Diagnosis/Description")' property='target.{DG1(k1):DiagnosisCodeDG1.Text}' action='set' />
<assign value='source.GetValueAt("/Container/Diagnoses/["_k1_"]/Diagnosis/SDACodingStandard")' property='target.{DG1(k1):DiagnosisCodeDG1.NameofCodingSystem}' action='set' />
<assign value='source.GetValueAt("/Container/Diagnoses/["_k1_"]/DiagnosisType/Code")' property='target.{DG1(k1):DiagnosisType}' action='set' />
</foreach>
<foreach property='source.{Observations()}' key='k3' >
<assign value='""' property='tObservation' action='set' />
<assign value='##class(EnsLib.EDI.XML.Document).ImportFromString("&lt;Observation&gt;"_source.GetValueAt("/Container/Observations/["_k3_"]")_"&lt;/Observation&gt;")' property='tObservation' action='set' />
<code>
<![CDATA[ 
 #;
 #; OBX
 #; 
]]]]><![CDATA[></code>
<subtransform class='HS.Gateway.SDA3.SDA3ToHL7.SubTransform.ObservationToOBX' targetObj='target.{OBX(k3)}' sourceObj='tObservation' />
<assign value='k3' property='target.{OBX(k3):1}' action='set' />
<if condition='+$Length(target.{OBX(k3):6})' >
<annotation>Not necessary but added for easier comparison of source and target messages</annotation>
<true>
<assign value='target.{OBX(k3):6.1}' property='tSystem' action='set' />
<assign value='target.{OBX(k3):6.3}' property='tCode' action='set' />
<assign value='""' property='target.{OBX(k3):6}' action='set' />
<assign value='tSystem' property='target.{OBX(k3):6.1}' action='set' />
<assign value='tCode' property='target.{OBX(k3):6.3}' action='set' />
</true>
</if>
</foreach>
</transform>
]]></Data>
</XData>
</Class>


<Class name="Synthea.StressMetrics">
<Super>%Persistent</Super>
<TimeChanged>65237,58281.3618</TimeChanged>
<TimeCreated>65190,59859.149724</TimeCreated>

<Property name="Start">
<Type>%String</Type>
</Property>

<Property name="End">
<Type>%String</Type>
</Property>

<Property name="Type">
<Type>%String</Type>
</Property>

<Property name="Elapsed">
<Type>%String</Type>
</Property>

<Property name="ClassName">
<Type>%String</Type>
</Property>

<Property name="LineStart">
<Type>%Integer</Type>
</Property>

<Property name="LineEnd">
<Type>%Integer</Type>
</Property>

<UDLText name="T">
<Content><![CDATA[
// Property Size As %Integer;

]]></Content>
</UDLText>

<Method name="Save">
<Implementation><![CDATA[
	// Allows for method/manipulation before save
	try {
		if ((^stConfig("consumehooks") [ ..Type) 
		|| (^stConfig("requesthooks") [ ..Type)
		|| (^stConfig("searchhooks") [ ..Type)) {
				set ^hooks(..Type) = 1
				return $this.%Save()
			}
		else
			{
				set ^hooks(..Type) = 0
			}
	}
	catch {
		return $this.%Save()
	}
]]></Implementation>
</Method>

<Method name="GrabHooks">
<ClassMethod>1</ClassMethod>
<FormalSpec>type,start,end</FormalSpec>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
	try {
		
		
		&sql(declare types cursor for select distinct Type into :type from Synthea.StressMetrics where Start > :start and "End" < :end) 
		&sql(open types)
		if SQLCODE '= 0 {
			return ""	
		}
		&sql(fetch types)
		
		set tList = ""
		while (SQLCODE = 0) {
			set tList = tList_","_type
			&sql(fetch types)
		}	
		
		&sql(close types)
		
		return tList
	}
	catch {
		return ""
	}
]]></Implementation>
</Method>

<Method name="CalcEnd">
<ClassMethod>1</ClassMethod>
<FormalSpec>End="9999-12-23 23:59:59.999"</FormalSpec>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
	if (End = "") {set End = $zdatetime($H, 3, 1, 3)}
	&sql(select MAX("END") into :nd from Synthea.StressMetrics where "END" < :End)
	QUIT nd
]]></Implementation>
</Method>

<Method name="CountMsg">
<ClassMethod>1</ClassMethod>
<FormalSpec>hType:%String,tStart:%String,tEnd=""</FormalSpec>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
	if (tEnd = "")
	{
		set tEnd = $zdatetime($H, 3, 1, 3)	
	}
	&sql(select COUNT(ID) into :nd from Synthea.StressMetrics where Type = :hType and Start > :tStart and "End" < :tEnd)
	return nd
]]></Implementation>
</Method>

<Method name="CalcAvg">
<ClassMethod>1</ClassMethod>
<FormalSpec>hType:%String,tStart:%String,tEnd=""</FormalSpec>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
	if (tEnd = "")
	{
		set tEnd = $zdatetime($H, 3, 1, 3)	
	}
	//2019-08-01 12:12:12.000
	&sql(SELECT AVG(Elapsed) INTO :avg FROM Synthea.StressMetrics WHERE Type = :hType and Start>=:tStart and "End" <= :tEnd) 
	return avg
]]></Implementation>
</Method>

<Method name="CalcMax">
<ClassMethod>1</ClassMethod>
<FormalSpec>hType:%String,tStart:%String,tEnd=""</FormalSpec>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
	if (tEnd = "")
	{
		set tEnd = $zdatetime($H, 3, 1, 3)	
	}
	&sql(SELECT MAX(Elapsed) INTO :max FROM Synthea.StressMetrics WHERE Type = :hType and Start>=:tStart and "End" <= :tEnd)
	return max
]]></Implementation>
</Method>

<UDLText name="T">
<Content><![CDATA[
// Update to just go from first message to last message

]]></Content>
</UDLText>

<Method name="CalcRate">
<ClassMethod>1</ClassMethod>
<FormalSpec>hType:%String,tStart:%String,tEnd=""</FormalSpec>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
	if (tEnd = "")
	{
		set tEnd = $zdatetime($H, 3, 1, 3)	
	}
	
	&sql(SELECT COUNT(Start), MIN(Start), MAX("End") into :cnt, :sDT, :eDT from Synthea.StressMetrics WHERE Type = :hType and Start >= :tStart and "End" <= :tEnd)
	set meDT = $zdatetimeh(eDT, 3, 1, 3)
	set msDT = $zdatetimeh(sDT, 3, 1, 3)
	
	set dys = (meDT - msDT) * 24 * 60 * 60
	set scs = $PIECE(meDT,",",2) - $PIECE(msDT,",",2)
	
	return cnt/(dys+scs)
]]></Implementation>
</Method>

<Method name="GetAll">
<ClassMethod>1</ClassMethod>
<FormalSpec>hType:%String,tStart:%String,tEnd=""</FormalSpec>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
	if ($g(^hooks(hType)) '= 1) {
		return ""
	}
	
	set AT = ..CalcAvg(hType, tStart, tEnd)
	set MT = ..CalcMax(hType, tStart, tEnd)
	set CR = ..CalcRate(hType, tStart, tEnd)
	set MC = ..CountMsg(hType, tStart, tEnd)
	set s = ","
	
	return AT_s_MT_s_CR_s_MC
]]></Implementation>
</Method>

<Method name="WriteAll">
<ClassMethod>1</ClassMethod>
<FormalSpec>hType:%String,tStart:%String,tEnd=""</FormalSpec>
<Implementation><![CDATA[
	w !
	w "Avg: ", ..CalcAvg(hType, tStart, tEnd), !
	w "Rate: ", ..CalcRate(hType, tStart, tEnd), !
	w "Msg  : ", ..CountMsg(hType, tStart, tEnd), !
]]></Implementation>
</Method>

<Storage name="Default">
<Type>%Library.CacheStorage</Type>
<DataLocation>^Synthea.StressMetricsD</DataLocation>
<DefaultData>StressMetricsDefaultData</DefaultData>
<IdLocation>^Synthea.StressMetricsD</IdLocation>
<IndexLocation>^Synthea.StressMetricsI</IndexLocation>
<StreamLocation>^Synthea.StressMetricsS</StreamLocation>
<Data name="StressMetricsDefaultData">
<Value name="1">
<Value>%%CLASSNAME</Value>
</Value>
<Value name="2">
<Value>Start</Value>
</Value>
<Value name="3">
<Value>End</Value>
</Value>
<Value name="4">
<Value>Type</Value>
</Value>
<Value name="5">
<Value>Elapsed</Value>
</Value>
<Value name="6">
<Value>Class</Value>
</Value>
<Value name="7">
<Value>Line</Value>
</Value>
<Value name="8">
<Value>ClassName</Value>
</Value>
<Value name="9">
<Value>LineStart</Value>
</Value>
<Value name="10">
<Value>LineEnd</Value>
</Value>
</Data>
</Storage>
</Class>


<Class name="Synthea.StressViewer">
<Abstract>1</Abstract>
<TimeChanged>65237,67979.526318</TimeChanged>
<TimeCreated>65090,40675.380472</TimeCreated>

<Method name="Launch">
<Description>

Date:  03/26/2019
Author:  Kuljeet Tuteja
Version:  1.0
Description:  Stress Testing Patient Search and Fetch from an Access Gateway

Updated 8/12/2019
Alex Sosa
Version 1.1
Update: Changing search method, implementing configuration via stConfig
</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>End=0</FormalSpec>
<Implementation><![CDATA[
	
	
	if (End = 1) {
		set ^stConfig("Preconsume") = 0
		do ..Run($G(^stConfig("PostConsumeSearches")), $G(^stConfig("SearchesPerSecond")))
	}
	else {
		set rate = $G(^stConfig("SearchesPerSecond"))
		while $G(^stConfig("Preconsume")) {
			for i = 1:1:(rate*10) {
				JOB ..SearchAndFetch()
			
				h 1/rate
			}
		}	
	}
]]></Implementation>
</Method>

<Method name="Run">
<ClassMethod>1</ClassMethod>
<FormalSpec>pRequests:%String="5",pRequestsPerSecond:%Integer="25"</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tSC = $$$OK		
	Set tRequests = pRequests
	Set tRequestsPerSecond = pRequestsPerSecond
	
	For i = 1:1:tRequests
	{
		JOB ..SearchAndFetch()
		// hanging for 1/pThreadsPerSecond = number of jobs executed per second. This simulates number of concurrent users on the system
		h 1/tRequestsPerSecond
	}
	
	return tSC
]]></Implementation>
</Method>

<Method name="SearchAndFetch">
<ClassMethod>1</ClassMethod>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[

	//With MPI, Birthday Searches
	//Invalid dates Still Yeild Response
	//yyyy-mm-dd
	set base = 30000 // = 02/20/23
	set spread = 35000 // 65000 = 12/18/2018
	
	//Get Date  between two numbers above
	set selection = $R(spread) + base
	set date = $ZD(selection, 3)
	
	Set tRequest = ##class(HS.Message.PatientSearchRequest).%New()
	Set tRequest.DOB = date
	
	
	If ^stConfig("LogBool")  { 
		Set tMetric = ##class(Synthea.StressMetrics).%New()
		Set tMetric.Type = "CVSearch"
		Set tMetric.ClassName = $THIS
		Set tMetric.LineStart = 73
		Set tMetric.Start = $ZDATETIME($H,3,1,3)
		set tStartZH = $ZH
	}
	
	Set tSC = ##class(HS.Viewer.Services).SendAsync(tRequest,.SearchId)
	
	Set status = "Unknown"
	while((status="Waiting") || (status="Unknown")){
		Set tSC = ##class(HS.Viewer.Services).GetResponse(SearchId,.response,.status)
	}
	
	If status="Done" {
		
		If response.%IsA("HS.Message.PatientSearchResponse") {  // Patient Search (MPI) response
			
			Set tTotalRows = response.ResultsCount
			Set tResponseId = response.%Id()	
		} 
	}
	
	If ^stConfig("LogBool") { 
		set tMetric.Elapsed = $ZH - tStartZH
		Set tMetric.End = $ZDATETIME($H,3,1,3)
		Set tMetric.LineEnd = 94
		Set ltSC = tMetric.Save()
		Quit:$$$ISERR(ltSC)
	}
	
	#dim tMatchList As %ListOfObjects
	#dim tMPIMatch As HS.Message.PatientMPIMatch
	#dim tSearchMatch As HS.Message.PatientSearchMatch
	Set batch=""
	Set tMatchCount=0
	Set tMatchId = 1
	Set tSC=$$$OK

	//Make requests depending on search
	Set RemainingRatio = $G(^stConfig("RequestRatio"))*100
	//Maybe don't hardcode? Instead pass in?
	
	while (RemainingRequests > 0 & $R(100) > RemainingRequests) {
		Set RemainingRatio = RemainingRatio - 100
	
		//pick a random mpiid match to work with
		Set tMatchList=##Class(HS.Message.PatientSearchResponse).%OpenId(tResponseId).MPIIDList
		Set tMatchCount = tMatchList.Count()
		Set tMatchId = $R(tMatchCount) + 1
		Set tMPIMatch = tMatchList.GetAt(tMatchId)
		
		//loop through each of the results for that mpiidmatch and add to the batch request
		For i=1:1:tMPIMatch.SearchMatches.Count() {
			Set tId = tMPIMatch.SearchMatches.GetAt(i)
			Set tSearchMatch = ##class(HS.Message.PatientSearchResponse).%OpenId(tResponseId).Results.GetAt(tId)
			
			if batch="" {
				Set tSC=##Class(HS.Message.PatientBatchFetchRequestAsync).CopyFrom(tMPIMatch,.batch)
			}
		
			set request = ##class(HS.Message.PatientFetchRequestAsync).%New()
			set request.MRN = tSearchMatch.MRN
			set request.Facility = tSearchMatch.Facility
			set request.AssigningAuthority = tSearchMatch.AssigningAuthority
			set request.MPIID= tSearchMatch.MPIID
			set request.Gateway = tSearchMatch.Gateway
		
			Do batch.Requests.Insert(request)
		}
		
		// Submit batch to fetch all selected records and load them into the AG cache
		JOB ..Fetch(batch)
	}
]]></Implementation>
</Method>

<Method name="Fetch">
<ClassMethod>1</ClassMethod>
<FormalSpec>batch</FormalSpec>
<Implementation><![CDATA[
	If ^stConfig("LogBool")  { 
		Set tMetric = ##class(Synthea.StressMetrics).%New()
		Set tMetric.Type = "CVRequest"
		Set tMetric.ClassName = $THIS
		Set tMetric.LineStart = 152
		Set tMetric.Start = $ZDATETIME($H,3,1,3)
		set tStartZH = $ZH
	}
	
	Set tSC = ##class(HS.Viewer.Services).SendAsync(batch,.lookupId)
	
	Set status = "Unknown"
	while((status="Waiting") || (status="Unknown")){
		Set tSC = ##class(HS.Viewer.Services).GetResponse(lookupId,.response,.status)
	}
	
	If ^stConfig("LogBool") { 
		set tMetric.Elapsed = $ZH - tStartZH
		Set tMetric.End = $ZDATETIME($H,3,1,3)
		Set tMetric.LineEnd = 162
		Set ltSC = tMetric.Save()
		Quit:$$$ISERR(ltSC)
	}
]]></Implementation>
</Method>
</Class>


<Class name="Synthea.Util">
<Super>%Persistent</Super>
<TimeChanged>65237,54779.81943</TimeChanged>
<TimeCreated>65190,59858.919337</TimeCreated>

<Method name="RunStressLocal">
<ClassMethod>1</ClassMethod>
<Implementation><![CDATA[
	//Easy Connection to Start Running and Recording Stress Test on this Machine
	if ($NAMESPACE = "%SYS") {
		do ..PerMachine()
	}
]]></Implementation>
</Method>

<Method name="EndStressLocal">
<ClassMethod>1</ClassMethod>
<Implementation><![CDATA[
	//Easy Connection to End StressTest recording on this machine
	if ($NAMESPACE = "%SYS") {
			do ..PerMachine(1)
	}
]]></Implementation>
</Method>

<Method name="PerMachine">
<ClassMethod>1</ClassMethod>
<FormalSpec>End=0</FormalSpec>
<Implementation><![CDATA[
	//Used to Run/End Stress Test Per Machine
	if ^stConfig("TrackpButtons") {
		if End {
			set logName = ^stConfig("pButtonLog")
			do ##class(Synthea.pButtonMetrics).Collect(logName)
			w "Collected pButton", !
			do ##class(Synthea.pButtonMetrics).Load(logName)
			w "Loaded", !
		} 
		else {
			set EHr = 9*(^stConfig("MaxPatients")/100000)*$LENGTH(^stConfig("PopulateFrom"), ",")
			set ^stConfig("pButtonLog") = ##class(Synthea.pButtonMetrics).RunMeasure($NUMBER(1+EHr, 0))	
		}
	}
	
	//Moving to Namespaces
	
	Set tFacilityList = "REGISTRY,HSPI,VIEWER,"_$ZSTRIP(^stConfig("HospitalList"),"*W") //Config
	Set tListLength = $LENGTH(tFacilityList,",")
	
	for i = 1:1:tListLength {
		set eNamespace = $PIECE(tFacilityList, ",", i)
		if ##class(%SYS.Namespace).Exists(eNamespace) {
			ZN eNamespace
			do ..PerSpace(End)
			ZN "%SYS"
		}
	}
]]></Implementation>
</Method>

<Method name="PerSpace">
<ClassMethod>1</ClassMethod>
<FormalSpec>End</FormalSpec>
<Implementation><![CDATA[
	//Runs these methods PerSpace mentioned
	if ^stConfig("TrackQueue") {
		if End {
			do ##class(Synthea.QueueMetrics).EndTrack()	
		}
		else {
			JOB ##class(Synthea.QueueMetrics).Track(300)	
		}
	}
]]></Implementation>
</Method>

<Method name="ConsumePatients">
<ClassMethod>1</ClassMethod>
<Implementation><![CDATA[
	//Enables HL7Generator on Production to ConsumePatients
	set x = ##class(Ens.Config.Production).OpenItemByConfigName("Synthea.HL7Generator")
	set x.Enabled = 1
	do x.%Save()
	do ##class(Ens.Production).Update(10, 1)
]]></Implementation>
</Method>

<Method name="SetValue">
<ClassMethod>1</ClassMethod>
<FormalSpec>var:%String,val:%String</FormalSpec>
<Implementation><![CDATA[
	//Sets value of Global ^stConfig
	set ^stConfig($ZSTRIP(var,"*W")) = $ZSTRIP(val,"*W")
]]></Implementation>
</Method>

<Method name="GrabTimer">
<ClassMethod>1</ClassMethod>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
	//Returns start_query, start, end
	set d = "_"
	return $g(^timer("start query"))_d_$g(^timer("start"))_d_$g(^timer("end"))
]]></Implementation>
</Method>

<Method name="GetSystem">
<ClassMethod>1</ClassMethod>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
	//Returns machine
	return $PIECE($SYSTEM, ":", 1)
]]></Implementation>
</Method>

<Method name="GetNamespace">
<ClassMethod>1</ClassMethod>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
	//Returns current namespace
	return $NAMESPACE
]]></Implementation>
</Method>

<Method name="AtEnd">
<ClassMethod>1</ClassMethod>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	//Returns whether the stress test has ended on this namespace
	set difference = 60
	
	&sql(select TOP 1 "End" into :nd from Synthea.StressMetrics order by ID desc)
	if (SQLCODE '= 0) {
		return 1
	}
	set lr = $ZDATETIMEH(nd, 3, 1, 3)
	set lastRecord = lr + (($PIECE(lr, ",", 2) + difference)/(24*60*60))
	set n = $H
	set currentTime = n + ($PIECE(n, ",", 2)/(24*60*60))
	return (currentTime > lastRecord)
]]></Implementation>
</Method>

<Method name="DateTimeToDay">
<ClassMethod>1</ClassMethod>
<FormalSpec>DateTime</FormalSpec>
<Implementation><![CDATA[
		//Converts form of date and current time to the day past epoch + decimal place of time
		set lr = $ZDATETIMEH(DateTime, 3, 1, 3)
		set day = $PIECE(lr, ",", 1)
		set time = $PIECE(lr, ",", 2)/(24*60*60)
		return day+time
]]></Implementation>
</Method>

<Storage name="Default">
<Type>%Library.CacheStorage</Type>
<DataLocation>^Synthea.UtilD</DataLocation>
<DefaultData>UtilDefaultData</DefaultData>
<IdLocation>^Synthea.UtilD</IdLocation>
<IndexLocation>^Synthea.UtilI</IndexLocation>
<StreamLocation>^Synthea.UtilS</StreamLocation>
<Data name="UtilDefaultData">
<Value name="1">
<Value>%%CLASSNAME</Value>
</Value>
<Value name="2">
<Value>Name</Value>
</Value>
<Value name="3">
<Value>ConfigContents</Value>
</Value>
</Data>
</Storage>
</Class>


<Class name="Synthea.pButtonMetrics">
<Super>%Persistent</Super>
<TimeChanged>65237,55006.074884</TimeChanged>
<TimeCreated>65203,43460.182216</TimeCreated>

<Property name="Record">
<Type>%String</Type>
<Parameter name="MAXLEN" value="100"/>
</Property>

<Property name="Machine">
<Type>%String</Type>
</Property>

<Property name="Date">
<Type>%String</Type>
</Property>

<Property name="Time">
<Type>%String</Type>
</Property>

<Property name="UsedRAM">
<Type>%Numeric</Type>
</Property>

<Property name="AvailableRAM">
<Type>%Numeric</Type>
</Property>

<Property name="CPUUse">
<Type>%Numeric</Type>
</Property>

<Property name="CPUIdle">
<Type>%Numeric</Type>
</Property>

<Property name="iowait">
<Type>%Numeric</Type>
</Property>

<Method name="RunMeasure">
<ClassMethod>1</ClassMethod>
<FormalSpec>EHr:%Numeric</FormalSpec>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
		// Runs a pbutton report for EHr hours, collecting every 5 minutes
		set amount = EHr * 12
		set name = EHr_"HrSynthea"
		set rc=$$addprofile^pButtons(name,"A "_EHr_"-hr run sampling every 5 minutes",300,amount)
		
		set runid=$$run^pButtons(name)
		return runid
]]></Implementation>
</Method>

<Method name="Collect">
<ClassMethod>1</ClassMethod>
<FormalSpec>id:%String</FormalSpec>
<Implementation><![CDATA[
		// Force stops pButton and forces creation of html pButton file
		set cc = $$Collect^pButtons(id)
		if ('cc) {
			set cs = $$Stop^pButtons(id, 0)
			while ('cc) {
				set cc =  $$Collect^pButtons(id)
				h 5
			}
		}
]]></Implementation>
</Method>

<Method name="GetLogId">
<ClassMethod>1</ClassMethod>
<FormalSpec>Date:%String,Time:%String,Record:%String</FormalSpec>
<Implementation><![CDATA[
		//Attempts to find a log with associated Date, Time, and Record
		//If unsuccessful, creates one
		try {
			&sql(select ID into :id from Synthea.pButtonMetrics where "Date" = :Date and "Time" = :Time and "Record" = :Record)
			if ('(id < 1)) {return id}
			THROW SQLCODE
		}
		catch
		{
			set s = ##class(Synthea.pButtonMetrics).%New()
			set s.Date = Date
			set s.Time = Time
			set s.Record = Record
			set s.Machine = $PIECE(Record, "_", 1)
			set src = s.%Save()
			&sql(select ID into :id from Synthea.pButtonMetrics where "Date" = :Date and "Time" = :Time and "Record" = :Record)
			if ('(id < 1)) {return id}
			w !
			w Date_":"_Time_":"_Record, !
			w id, !
			THROW src
		}
		w !
		w "2"_Date_"_"_Time_"_"_Record, !
		THROW SQLCODE
]]></Implementation>
</Method>

<Method name="Load">
<ClassMethod>1</ClassMethod>
<FormalSpec>id="",timeout=10</FormalSpec>
<Implementation><![CDATA[
		//Loads pButton report into SQL table Synthea.pButtonMetrics
		//id in form date_time_config
	
		if id = "" {
			set id = ^stConfig("pButtonLog")
		}
	
		set id = $REPLACE($SYSTEM, ":", "_")_"_"_id_".html"
	
		set str = ##class(%Stream.FileCharacter).%New()
		set sc = str.LinkToFile("/home/stress-test/instances/STRESS/mgr/"_id)
		if (str.AtEnd)
		{
			h 10	
		}
		
		if (str.AtEnd)
		{
			w "File DNE"
			return 0
		}
		
		set date = $zdate($zdateh($PIECE(id, "_", 3), 8), 3)

		set utab = "     " //5 spaces
		set startSarU = "<!-- end_vmstat -->"
		set startSarD = "</pre><p align=""right""><font size=""3""><a href=""#Topofpage"">Back to top</a></font></p><hr size=""4"" noshade><b><font face=""Arial, Helvetica, sans-serif"" size=""4"" color=""#0000FF""><div id=sar-d></div>sar -d</font></b><br><pre>"
		set startFree = "<!-- end_sar_u -->"
		//Go to Sar -u
		
		while ((str.ReadLine() '= startSarU) & (str.AtEnd '= "1")) {}
		
		if str.AtEnd
			{
				return "0"
			}
		
		for i = 1:1:3 {set line = str.ReadLine()}
		
		if (line = startFree) {QUIT}
		
		set line = str.ReadLine()
		
		while (($PIECE(line, " ", 1) '= "Average:") & (line '= startFree))
		{
			set time = $ztime($ztimeh($PIECE(line, utab, 1),3),1)
			
			set logid = ..GetLogId(date, time, id)
			set log = ..%OpenId(logid)
			
			set log.CPUUse = $ZSTRIP($PIECE(line, utab, 3), "*W")
			set log.CPUIdle = $ZSTRIP($PIECE(line, utab, 8), "*W")
			set log.iowait = $ZSTRIP($PIECE(line, utab, 6), "*W")
			
			set src = log.%Save()
			if src '= 1 {zw src}
			
			set line = str.ReadLine()
		}
		//Free
		
		
		while (line '= startFree) 
			{
				set line = str.ReadLine()
			}
		do str.ReadLine()
		set line = str.ReadLine()
		
		while ((line '= "") & (($PIECE(line, " ", 1) '= "</pre><p")) & (line '= "An empty file was created."))
		{
			set time = $PIECE(line, ", ", 2)
			
			set logid = ..GetLogId(date, time, id)
			set log = ..%OpenId(logid)
			set log.AvailableRAM = $ZSTRIP($PIECE(line, ", ", 4),"*W")
			set log.UsedRAM = $ZSTRIP($PIECE(line, ", ", 8),"*W")
			do log.%Save()
			
			set line = str.ReadLine()
		}
]]></Implementation>
</Method>

<Method name="GetAverages">
<ClassMethod>1</ClassMethod>
<FormalSpec>id=""</FormalSpec>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
	if (id = "") {
		set id = ^stConfig("pButtonLog")	
	}
	//Returns the following averages:
	//Used, Available, CPUUse, CPUIdle, iowait
	set d = "_"
	&sql(select AVG(UsedRAM), AVG(AvailableRAM), AVG(CPUUse), AVG(CPUIdle), AVG(iowait) into :aURAM, :aARAM, :aCPUUse, :aCPUIdle, :aiowait from Synthea.pButtonMetrics where Record = :id and CPUUse > 3)
	return aURAM_d_aARAM_d_aCPUUse_d_aCPUIdle_d_aiowait
]]></Implementation>
</Method>

<Storage name="Default">
<Type>%Library.CacheStorage</Type>
<DataLocation>^Synthea.pButtonMetricsD</DataLocation>
<DefaultData>pButtonMetricsDefaultData</DefaultData>
<IdLocation>^Synthea.pButtonMetricsD</IdLocation>
<IndexLocation>^Synthea.pButtonMetricsI</IndexLocation>
<StreamLocation>^Synthea.pButtonMetricsS</StreamLocation>
<Data name="pButtonMetricsDefaultData">
<Value name="1">
<Value>%%CLASSNAME</Value>
</Value>
<Value name="2">
<Value>Machine</Value>
</Value>
<Value name="3">
<Value>Date</Value>
</Value>
<Value name="4">
<Value>Time</Value>
</Value>
<Value name="5">
<Value>AvailableRAM</Value>
</Value>
<Value name="6">
<Value>TotalRAM</Value>
</Value>
<Value name="7">
<Value>CPUUse</Value>
</Value>
<Value name="8">
<Value>CPUIdle</Value>
</Value>
<Value name="9">
<Value>Record</Value>
</Value>
<Value name="10">
<Value>UsedRAM</Value>
</Value>
<Value name="11">
<Value>iowait</Value>
</Value>
</Data>
</Storage>
</Class>


<Package name="Synthea" sqlname="Synthea"/>
</Export>
